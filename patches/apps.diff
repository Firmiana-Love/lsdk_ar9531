diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/makefile.artmod apps_1.2/art/makefile.artmod
--- apps/art/makefile.artmod	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/makefile.artmod	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,116 @@
+KDIR	:= $(KERNELPATH)
+
+PWD	:= $(shell pwd)
+
+ROOTDIR := $(PWD)/modules
+
+
+# Default architecture is MIPS
+ifndef $(KERNELARCH)
+KERNELARCH=mips
+endif
+
+
+ARC = $(KERNELARCH)
+CROSS_CC=$(ARC)-linux-uclibc-
+
+ifeq ($(POWERPC),1)
+ARC     :=powerpc
+CROSS_CC :=powerpc-none-linux-gnuspe-
+endif
+
+
+export KDIR
+
+export ROOTDIR
+
+export CROSS_CC
+
+
+all: default
+
+
+default:
+
+	@echo Making generic AP art module build. This build target is used for 3rd party AP processor. 
+
+	make ARCH=$(ARC) PB42=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+hydra:
+
+	@echo Making art module for Atheros hydra based design.
+
+	make ARCH=$(ARC) PB42=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+howl:
+
+	@echo Making art module for Atheros howl based design.
+
+	make ARCH=$(ARC) AP83=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+python:
+
+	@echo Making art module for Atheros python based design.
+
+	make ARCH=$(ARC) PYTHON_EMU=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+wasp:
+
+	@echo Making art module for Atheros wasp based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+	
+
+honeybee:
+
+	@echo Making art module for Atheros wasp based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules	
+
+
+wasp_osprey:
+
+	@echo Making art module for Atheros wasp-osprey DBSC based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 PYTHON_EMU=1 WASP_OSPREY=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+scorpion:
+
+	@echo Making art module for Atheros wasp based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+scorpion_pci:
+
+	@echo Making art module for Atheros Scorpion-peacock_pci slot 1 or 2 DBSC based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 PYTHON_EMU=1 WASP_OSPREY=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+dragonfly:
+
+	@echo Making art module for Atheros wasp based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+dragonfly_pci:
+
+	@echo Making art module for Atheros dragonfly_pci slot 1 based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 PYTHON_EMU=1 WASP_OSPREY=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+p1020:
+	@echo Making art module for Freescale powepc ref resigns
+	make ARCH=$(ARC) PB42=1 P1020=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+clean:
+
+	cd modules && make clean
\ No newline at end of file
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/client.c apps_1.2/art/modules/client.c
--- apps/art/modules/client.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/client.c	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,866 @@
+/* client.c */
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#include <linux/pci.h>
+#endif
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/page-flags.h>
+#include <linux/version.h>
+#include <asm/io.h>
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#ifdef PCI_BUS
+#include "dk_pci_bus.h"
+#endif
+#endif
+
+#include "dk.h"
+#include "dk_ioctl.h"
+#include "dk_event.h"
+#include "client.h"
+
+#define ORDER 9
+#define ORDER_COMM_CLASS 8
+#define ATHEROS_VENDOR_ID 0x168c
+#define HOWL_RTC_BASE_ADDRESS 0xb80e0000
+#define HOWL_WMAC_BASE_VIR_ADDRESS 0xb80c0000
+#define HORNET_RTC_BASE_ADDRESS 0xb8100000
+#define HORNET_WMAC_BASE_VIR_ADDRESS 0xb8100000
+/* global variables */
+#if defined(P1020)
+extern A_UINT_PTR get_pci_virt_addr();
+
+#endif
+static atheros_dev dev_table[MAX_CLIENTS_SUPPORTED];
+static long unsigned int mem_table[MAX_CLIENTS_SUPPORTED];
+static UINT32 mem_page_order[MAX_CLIENTS_SUPPORTED];
+
+/* extern declarations */
+extern irqreturn_t dk_intr_handler(INT32,VOID *,struct pt_regs *);
+
+/* forward declarations */
+static VOID reset_device(INT32 cli_id);
+
+VOID init_client
+(
+ 	VOID
+)
+{
+	UINT32 i;
+
+#ifdef DK_DEBUG
+	printk("DK::Init dev table \n");
+#endif
+
+	for (i=0;i<MAX_CLIENTS_SUPPORTED;i++) {
+			dev_table[i].cli_id = INVALID_CLIENT;
+			mem_table[i] = 0;
+	}
+		
+}
+
+static VOID init_atheros_dev
+(
+ 	p_atheros_dev dev
+)
+{
+        int iIndex;
+
+		dev->bus_dev = NULL;
+		dev->reg_phy_addr = 0;
+		dev->reg_ker_vir_addr = 0;
+		dev->reg_range = 0;
+		dev->mem_phy_addr = 0;
+		dev->mem_ker_vir_addr = 0;
+		dev->mem_size = 0;
+		dev->irq = 0;
+		dev->dev_busy = 0;
+		dev->cli_id = INVALID_CLIENT;
+		memset(&dev->isr_event_q,0,sizeof(event_queue));
+		memset(&dev->trigered_event_q,0,sizeof(event_queue));
+        for(iIndex=0; iIndex<MAX_BARS; iIndex++) {
+		     dev->areg_phy_addr[iIndex] = 0;
+		     dev->areg_ker_vir_addr[iIndex] = 0;
+		     dev->areg_range[iIndex] = 0;
+        }
+}
+
+/*
+ * Get the client for this device
+ * The table give the mapping between the device and the client 
+ * in the dev_table. The minor number is used to idenitfy the client
+ * for the device.
+ *  Device    client       minor 
+ * /dev/dk0 - dev_table[0]   0
+ * /dev/dk1 - dev_table[1]   1
+ * /dev/dk2 - dev_table[2]   2
+ * /dev/dk3 - dev_table[3]   3
+ */
+static INT32 get_client_id
+(
+ 	INT32 major,
+ 	INT32 minor
+)
+{
+#ifdef DK_DEBUG
+	printk("DK::get_client_id:major=%d:minor=%d\n", major, minor);
+#endif
+	if (major == DK_UART_MAJOR_NUMBER) {
+		return dev_table[minor + UART_FN_DEV_START_NUM].cli_id;
+	}
+	else
+		return dev_table[minor].cli_id;
+}
+
+p_atheros_dev get_client
+(
+ 	INT32 cli_id
+)
+{
+	p_atheros_dev dev;
+
+	dev = &dev_table[cli_id];
+	if (!VALID_CLIENT(dev))  {
+		return NULL;
+	}
+
+	return dev;
+}
+
+INT32 add_client
+(
+ 	VOID *bus_dev,
+	A_UINT_PTR baseaddr[MAX_BARS],
+	UINT32 len[MAX_BARS],
+	UINT32 irq,
+    UINT32 numBars,
+    UINT32 sIndex,
+    int pci
+)
+{
+		UINT32 i;
+		INT32 cli_id;
+		p_atheros_dev dev;
+		A_UINT_PTR reg_vir_addr[MAX_BARS];
+		A_UINT_PTR mem_phy_addr;
+		long unsigned int *mem;
+		struct page *page;
+		UINT32 no_pages, iIndex;
+
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+        INT8 ret_val;
+#endif
+        UINT32 page_order=ORDER;
+#if defined(OCTEON)
+        dma_addr_t dma_handle;
+#endif
+
+
+		dev = NULL;
+		mem = NULL;
+		cli_id = INVALID_CLIENT;
+		mem_phy_addr = 0;
+
+		for (i=sIndex;i<MAX_CLIENTS_SUPPORTED;i++) {
+				if (dev_table[i].cli_id == INVALID_CLIENT) {
+						cli_id = i;
+						dev = &dev_table[i];
+						mem = &mem_table[i];
+						break;
+				}
+		}
+
+		if (cli_id == INVALID_CLIENT) {
+			printk("DK:: Only %d clients supported \n",MAX_CLIENTS_SUPPORTED);
+			return -1;
+		}
+		
+		printk("DK::Add client %d \n",cli_id);
+
+		init_atheros_dev(dev);		
+
+        for(iIndex=0; iIndex<numBars; iIndex++) {
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#if defined(P1020)
+
+                      reg_vir_addr[iIndex] = (A_UINT_PTR)get_pci_virt_addr();
+
+			printk(KERN_ERR" Reg Virtual address :0x%08lx\n", reg_vir_addr[iIndex]);
+#endif
+if(pci){
+            (void)pci_read_config_byte(bus_dev, PCI_BASE_ADDRESS_0 + (iIndex *4), &ret_val);
+            if (ret_val&0x1) {
+               // IO region mapping
+               /*
+		       printk("DK:: Requesting IO region=%x:range=%d\n", baseaddr[iIndex], len[iIndex]);
+		       if (request_region(baseaddr[iIndex],len[iIndex],DRV_NAME) == NULL) {
+		          printk(KERN_ERR "DK:: unable to request io region for Bar %d: len = %d\n", iIndex, len[iIndex]);
+				  return -1;
+	           }
+               */
+            }
+            else {
+
+		      printk("DK:: Requesting MEM region=%lx:range=%d\n", baseaddr[iIndex], len[iIndex]);
+
+		      if (request_mem_region(baseaddr[iIndex],len[iIndex],DRV_NAME) == NULL) {
+		          printk(KERN_ERR "DK:: unable to request mem region for Bar %d: len = %d\n", iIndex, len[iIndex]);
+				  return -1;
+	          }
+
+                      reg_vir_addr[iIndex] = (A_UINT_PTR)ioremap_nocache(baseaddr[iIndex],len[iIndex]);
+                      if ((VOID *)reg_vir_addr[iIndex] == NULL) {
+                                free_irq(irq,(void *)dev);
+                                for(iIndex=0; iIndex<numBars; iIndex++) {
+                                          iounmap((VOID *)reg_vir_addr[iIndex]);
+                                          //release_mem_region(baseaddr[iIndex],len[iIndex]);
+                                }
+                                printk(KERN_ERR "DK:: unable to remap registers \n");
+                                return -1;
+                      }
+            }
+}
+#endif
+#ifdef AP83
+if(!pci){
+		      reg_vir_addr[iIndex] = (UINT32)ioremap_nocache(baseaddr[iIndex],len[iIndex]);
+		      if ((VOID *)reg_vir_addr[iIndex] == NULL) {
+				free_irq(irq,(void *)dev);
+                                for(iIndex=0; iIndex<numBars; iIndex++) {
+			        	  iounmap((VOID *)reg_vir_addr[iIndex]);
+		        	  	  //release_mem_region(baseaddr[iIndex],len[iIndex]);
+                                }   
+				printk(KERN_ERR "DK:: unable to remap registers \n");
+				return -1;
+		      }
+}
+#endif
+        } // end of for
+
+		   /* Pass the pointer to the client id */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+		   if (request_irq(irq,(void *)dk_intr_handler,SA_SHIRQ,DRV_NAME,(void *)dev) != 0) {
+#else
+		   if (request_irq(irq,(void *)dk_intr_handler,IRQF_SHARED,DRV_NAME,(void *)dev) != 0) {
+#endif
+              for(iIndex=0; iIndex<numBars; iIndex++) {
+				iounmap((VOID *)reg_vir_addr[iIndex]);
+				release_mem_region(baseaddr[iIndex],len[iIndex]);
+              }
+		        printk(KERN_ERR "DK:: unable to request irq \n");
+				return -1;
+		   }
+
+
+        for(iIndex=0; iIndex<numBars; iIndex++) {
+   
+		printk("DK::Reg phy addr = %lx vir Addr = %lx \n",baseaddr[iIndex],reg_vir_addr[iIndex]);
+
+        }
+		printk("DK::Irq = %x \n",irq);
+
+
+		if (*mem == 0) {
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#if defined (P1020)
+
+		    *mem = __get_free_pages(GFP_KERNEL|GFP_DMA,ORDER);
+                    page_order = ORDER;
+#endif
+if(pci){
+                (void)pci_read_config_byte(bus_dev, 0xb, &ret_val);
+                if (ret_val == SIMPLE_COMM_CLASS) {
+				    *mem = __get_free_pages(GFP_KERNEL,ORDER_COMM_CLASS);
+                    page_order = ORDER_COMM_CLASS;
+                }
+                else {
+				    *mem = __get_free_pages(GFP_KERNEL|GFP_DMA,ORDER);
+				      //*mem = ioremap_nocache(0xf00000, 0x100000);
+                    page_order = ORDER;
+                }
+}
+#endif
+#ifdef AP83
+if(!pci){
+                    *mem = __get_free_pages(GFP_KERNEL|GFP_DMA,ORDER);
+                    page_order = ORDER;
+
+}
+#endif
+		if (*mem == 0) {
+                    for(iIndex=0; iIndex<numBars; iIndex++) {
+					   iounmap((VOID *)reg_vir_addr[iIndex]);
+					   free_irq(irq,(void *)dev);
+					   release_mem_region(baseaddr[iIndex],len[iIndex]);
+                    }
+					   printk(KERN_ERR "DK:: unable to allocate contigous memory \n");
+					   return -1;
+		}
+				// map the pages as reserved,
+				// otherwise remap_page_range wont 
+				// do what we expect
+
+				page =  virt_to_page((void *)(*mem));
+				no_pages = 1 << page_order;
+                		mem_page_order[cli_id] = page_order;
+				for (i=0;i<no_pages;i++) {
+					SetPageReserved(page);
+					page++;
+				}
+				
+				printk("DK::Allocated 0x%x bytes memory \n", (UINT32) (PAGE_SIZE * (1<<page_order)));
+		} else {
+				printk("DK::Using memory already allocated at %lx \n",*mem);
+		}
+#if defined(OCTEON)
+                mem_phy_addr = virt_to_phys(pci_alloc_consistent(bus_dev, PAGE_SIZE * (1<<page_order), &dma_handle));
+		printk("DK::DMA addr 0x%lx, mem phy addr %lx\n", dma_handle, mem_phy_addr);
+#else
+                mem_phy_addr = __pa(*mem);
+#endif
+		printk("DK::memory vir Addr = %lx phy Addr = %lx \n",*mem,mem_phy_addr);
+
+		/* 
+		 * TO DO: (if necessary)
+		 * Kernel already has a mapping for this physical pages. 
+		 * They are part of the identity mapping, so they may be 
+		 * cached. Remap it to another virtual address space 
+		 * if the memory will be accessed from the kernel
+		 */
+		
+		dev->bus_dev = bus_dev;
+        for(iIndex=0; iIndex<numBars; iIndex++) {
+		   dev->areg_phy_addr[iIndex] = baseaddr[iIndex];
+		   dev->areg_ker_vir_addr[iIndex] = reg_vir_addr[iIndex];
+		   dev->areg_range[iIndex] = len[iIndex];
+        }
+		dev->reg_phy_addr = baseaddr[0];
+		dev->reg_ker_vir_addr = reg_vir_addr[0];
+		dev->reg_range = len[0];
+        	dev->numBars = numBars;
+		dev->mem_ker_vir_addr = *mem;
+		dev->mem_phy_addr = mem_phy_addr;
+		dev->mem_size = (1 << page_order) * PAGE_SIZE;
+		dev->irq = irq;
+		dev->cli_id = cli_id;
+#if defined(OCTEON)
+        dev->dma_mem_addr = dma_handle;
+#endif 
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+if(pci){
+		cli_cfg_read(cli_id,8,4,&dev->device_class);
+}
+#endif 
+        	dev->device_class >>= 24;
+
+		reset_device(cli_id);
+		return 0;
+}
+
+
+VOID remove_client
+(
+ 	VOID *bus_dev
+)
+{
+		UINT32 i, iIndex;
+		p_atheros_dev dev;
+
+		printk("DK::Remove client \n");
+
+		dev = NULL;
+		for (i=0;i<MAX_CLIENTS_SUPPORTED;i++) {
+				if (dev_table[i].cli_id == INVALID_CLIENT) continue;
+			   	if (dev_table[i].bus_dev == bus_dev) {
+						dev = &dev_table[i];
+						break;
+				}
+		}
+		
+		if (dev == NULL) {
+			printk("DK:: Invalid client in remove_client \n");
+			return;
+		}
+		
+		reset_device(dev->cli_id);
+
+        for(iIndex=0; iIndex<dev->numBars; iIndex++) {
+		    iounmap((VOID *)dev->areg_ker_vir_addr[iIndex]);
+		    release_mem_region(dev->areg_phy_addr[iIndex], dev->areg_range[iIndex]);
+		    printk("DK::Free reg space phy=%lx vir=%lx \n",dev->areg_phy_addr[iIndex],dev->areg_ker_vir_addr[iIndex]);
+        }
+		
+		free_irq(dev->irq,(void *)dev);
+		printk("DK::Free irq = %x \n",dev->irq);
+
+		init_atheros_dev(dev);		
+
+		return;
+}
+
+
+VOID cleanup_client
+(
+ 	VOID
+)
+{
+		UINT32 i;
+		UINT32 j;
+		struct page *page;
+		UINT32 no_pages;
+
+#ifdef DK_DEBUG
+		printk("DK::Cleanup dev table \n");
+#endif // DK_DEBUG
+		for (i=0;i<MAX_CLIENTS_SUPPORTED;i++) {
+				if (dev_table[i].cli_id != INVALID_CLIENT) {
+						remove_client(dev_table[i].bus_dev);
+						dev_table[i].cli_id = INVALID_CLIENT;
+				}
+				if (mem_table[i] != 0) {
+						printk("DK::Freeing memory at %lx \n",mem_table[i]);
+						// remove the reserved flag
+						
+						page = virt_to_page((void *)mem_table[i]);
+						no_pages = 1 << mem_page_order[i];
+                        printk("page order=%d\n", mem_page_order[i]);
+						for (j=0;j<no_pages;j++) {
+							 ClearPageReserved(page);
+							page++;
+						}
+						
+						free_pages(mem_table[i],8);
+						mem_table[i] = 0;
+				}
+		}
+		return;
+}
+
+INT32 register_client
+(
+ 	INT32 major,
+ 	INT32 minor
+)
+{
+	INT32 cli_id;
+	p_atheros_dev dev;
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+	UINT32 vendor_id;
+#endif
+	/* get the client for this device */
+	cli_id = get_client_id(major, minor);
+
+	if (cli_id == INVALID_CLIENT) {
+		printk("DK::register_client:Device not found \n");
+	 	return -ENODEV;
+	}
+
+	printk("DK::Regsitering client %d \n",cli_id);
+	dev = &dev_table[cli_id];
+
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::register_client:Invalid client \n");
+	 	return -ENODEV;
+    }
+
+	if (BUSY_CLIENT(dev)) {
+		printk("DK::register_client:Client alreay in use \n");
+		return -EACCES;
+	}
+#if !defined (P1020)	
+
+	// check whether the device is present
+	// by reading the vendor id
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#ifdef WASP_OSPREY
+   if(cli_id!=0){ // For DBDC operation, Wasp radio's client ID is zero; 
+#endif
+	cli_cfg_read(cli_id,0,4,&vendor_id);
+	if ((vendor_id & 0xffff) != ATHEROS_VENDOR_ID) {
+		printk("DK::Device not present \n");
+	 	return -ENODEV;
+	}
+
+#ifdef WASP_OSPREY
+   }
+#endif
+#ifndef PYTHON_EMU
+	if (bus_dev_init(dev->bus_dev) < 0) {
+		printk("DK::register_client:Cannot initialize client \n");
+		return -EACCES;
+	}
+#endif
+#endif
+#endif
+	initEventQueue(&dev->isr_event_q);
+	initEventQueue(&dev->trigered_event_q);
+	
+	reset_device(cli_id);
+					
+	dev->dev_busy = 1;
+				  
+	return dev->cli_id;
+}
+
+VOID unregister_client
+(
+ 	INT32 cli_id
+)
+{
+	p_atheros_dev dev;
+
+	printk("DK::Unregsitering client %d \n",cli_id);
+	
+	dev = &dev_table[cli_id];
+
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::unregister_client:Invalid client \n");
+	 	return;
+    }
+	if (!BUSY_CLIENT(dev)) {
+		printk("DK::unregister_client:Client not registered \n");
+		return;
+	}
+	
+	reset_device(dev->cli_id);
+	
+	deleteEventQueue(&dev->isr_event_q);
+	deleteEventQueue(&dev->trigered_event_q);
+#if defined(OWL_PB42) || defined(PYTHON_EMU)	
+	bus_dev_exit(dev->bus_dev);
+#endif
+	dev->dev_busy = 0;
+	
+	return;
+}
+
+INT32 cli_reg_read
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	UINT32 *data
+)
+{
+	p_atheros_dev dev;
+	UINT32 *addr;
+	
+	dev = &dev_table[cli_id];
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::reg_read:Invalid client \n");
+	 	return -1;
+    }
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+	addr = (UINT32 *)(dev->areg_ker_vir_addr[0] + offset);
+#endif
+#ifdef AP83
+#ifndef WASP_OSPREY
+	#ifdef HORNET
+        addr = (UINT32 *)(HORNET_WMAC_BASE_VIR_ADDRESS + offset);
+	#else
+        addr = (UINT32 *)(HOWL_WMAC_BASE_VIR_ADDRESS + offset);
+	#endif        
+#endif
+#endif
+	*data = readl(addr);
+#ifdef DK_DEBUG
+	printk("DK::Reg read @ 0x%08lx : 0x%04x \n",(A_UINT_PTR)addr,*data);
+#endif
+
+	return 0;
+}
+
+INT32 cli_reg_write
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	UINT32 data
+)
+{
+	p_atheros_dev dev;
+	UINT32 *addr;
+
+	dev = &dev_table[cli_id];
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::reg_write:Invalid client \n");
+	 	return -1;
+    }
+#if defined(OWL_PB42) || defined(PYTHON_EMU)	
+	addr = (UINT32 *)(dev->areg_ker_vir_addr[0] + offset);
+#endif
+#ifdef AP83
+#ifndef WASP_OSPREY
+	#ifdef HORNET
+        addr = (UINT32 *)(HORNET_WMAC_BASE_VIR_ADDRESS + offset);
+	#else
+        addr = (UINT32 *)(HOWL_WMAC_BASE_VIR_ADDRESS + offset);
+	#endif        
+#endif
+#endif
+	writel(data,addr);
+#ifdef DK_DEBUG
+	printk("DK::Reg write @ 0x%08lx : 0x%04x \n",(A_UINT_PTR)addr,data);
+#endif
+
+	return 0;
+}
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+INT32 cli_cfg_read
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	INT32 size,
+	INT32 *ret_val
+)
+{
+	p_atheros_dev dev;
+
+	dev = &dev_table[cli_id];
+	
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::cfg_read:Invalid client \n");
+	 	return -1;
+    }
+	
+	return bus_cfg_read(dev->bus_dev,offset,size,ret_val);
+}
+#endif
+
+#if defined(AP83) || defined(PYTHON_EMU)
+INT32 full_addr_read
+(
+        INT32 cli_id,           
+        INT32 offset,                   
+        INT32 *ret_val                  
+)                               
+{
+        p_atheros_dev dev;      
+        UINT32 *addr;           
+
+        dev = &dev_table[cli_id];
+        if (!VALID_CLIENT(dev)) {
+                printk("DK::rtc_reg_read:Invalid client \n");
+                return -1;      
+    }                                           
+          addr = (UINT32 *)(0x00000000+offset);
+          *ret_val = readl(addr);
+          return 0;
+                                
+} 
+INT32 full_addr_write
+(
+        INT32 cli_id,
+        INT32 offset,
+        UINT32 data
+)
+{
+        p_atheros_dev dev;
+        UINT32 *addr;
+
+        dev = &dev_table[cli_id];
+        if (!VALID_CLIENT(dev)) {
+                printk("DK::reg_write:Invalid client \n");
+                return -1;
+        }
+
+        addr = (UINT32 *)(0x000000 + offset);
+        writel(data,addr);
+
+
+        return 0;
+}
+#endif
+
+#if !defined(OCTEON) 
+INT32 rtc_reg_read
+(
+        INT32 cli_id,           
+        INT32 offset,                   
+        INT32 *ret_val                  
+)                               
+{
+        p_atheros_dev dev;      
+        UINT32 *addr;           
+
+        dev = &dev_table[cli_id];
+        if (!VALID_CLIENT(dev)) {
+                printk("DK::rtc_reg_read:Invalid client \n");
+                return -1;      
+    }                                           
+			#ifdef HORNET
+          addr = (UINT32 *)(HORNET_RTC_BASE_ADDRESS+offset);
+			#else
+          addr = (UINT32 *)(HOWL_RTC_BASE_ADDRESS+offset);
+			#endif          
+          *ret_val = readl(addr);
+          return 0;
+                                
+} 
+
+INT32 get_chip_id                     
+(                               
+        INT32 cli_id,                   
+        INT32 offset,           
+        INT32 size,             
+        INT32 *ret_val          
+)                       
+{                               
+        p_atheros_dev dev;                      
+        UINT32 *addr;           
+        dev = &dev_table[cli_id];
+                                        
+        if (!VALID_CLIENT(dev)) { 
+                printk("DK::cfg_read:Invalid client \n");
+                return -1;      
+    }                           
+          addr = (UINT32 *)(0x00000000+offset);
+          *ret_val = readl(addr);               
+          return 0;             
+                                
+}
+
+INT32 rtc_reg_write
+(
+        INT32 cli_id,
+        INT32 offset,
+        UINT32 data
+)
+{
+        p_atheros_dev dev;
+        UINT32 *addr;
+
+        dev = &dev_table[cli_id];
+        if (!VALID_CLIENT(dev)) {
+                printk("DK::reg_write:Invalid client \n");
+                return -1;
+        }
+
+			#ifdef HORNET
+        addr = (UINT32 *)(HORNET_RTC_BASE_ADDRESS + offset);
+			#else
+        addr = (UINT32 *)(HOWL_RTC_BASE_ADDRESS + offset);
+			#endif        
+        writel(data,addr);
+
+
+        return 0;
+}
+#endif  //end OCTEON def
+
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)  
+INT32 cli_cfg_write
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	INT32 size,
+	INT32 ret_val
+)
+{
+	p_atheros_dev dev;
+	
+	dev = &dev_table[cli_id];
+	
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::cfg_write:Invalid client \n");
+	 	return -1;
+    }
+	
+	return bus_cfg_write(dev->bus_dev,offset,size,ret_val);
+}
+#endif
+
+
+INT32 get_cli_info
+(
+ 	INT32 cli_id,
+	struct client_info *ci
+)
+{
+	p_atheros_dev dev;
+    int iIndex;
+	
+	dev = &dev_table[cli_id];
+	
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::get_client_info:Invalid client \n");
+	 	return -1;
+    }
+	
+	ci->reg_phy_addr = dev->areg_phy_addr[0];
+	ci->reg_range = dev->areg_range[0];
+    for (iIndex=0; iIndex<dev->numBars; iIndex++) {
+	   ci->areg_phy_addr[iIndex] = dev->areg_phy_addr[iIndex];
+	   ci->areg_range[iIndex] = dev->areg_range[iIndex];
+    }
+    ci->numBars = dev->numBars;
+	ci->mem_phy_addr = dev->mem_phy_addr;
+	ci->mem_size = dev->mem_size;
+	ci->irq = dev->irq;
+    ci->device_class = dev->device_class;
+    ci->dma_mem_addr = dev->dma_mem_addr;
+
+	return 0;
+}
+
+static VOID reset_device
+(
+ 	INT32 cli_id
+)
+{
+	UINT32 out;
+#ifdef DK_DEBUG
+	printk("DK::Disable the interrupts and reset the device \n");	
+#ifdef PYTHON_EMU
+	cli_reg_read(cli_id, 0x4020, &out);
+	printk("Device Mac Rev : 0x%x\n",out);			
+#endif 
+#endif
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+	if (dev_table[cli_id].device_class == NETWORK_CLASS) {
+	   // disable interrupts 	
+	   cli_reg_write(cli_id,0x0024,0x0);
+	   // put the device in reset state		
+	   cli_reg_write(cli_id,0x704c,0x1); 				
+	   cli_reg_write(cli_id,0x7040,0x0); 				
+	   cli_reg_write(cli_id,0x7040,0x1); 	
+
+	   cli_reg_read(cli_id, 0x7044, &out);
+	   printk("Device Status is : 0x%x\n",out);			
+	}
+	if (dev_table[cli_id].device_class == SIMPLE_COMM_CLASS) {
+	   cli_reg_write(cli_id,0x4,0x0); // IER
+	   cli_reg_write(cli_id,0x114,0x0); // Extended IER
+	   cli_reg_write(cli_id,0x104,0x1); // RC
+	}
+#endif
+#ifdef AP83
+#ifndef WASP
+        //if (dev_table[cli_id].device_class == NETWORK_CLASS) {
+           // disable interrupts
+           cli_reg_write(cli_id,0x0024,0x0);
+           // put the device in reset state
+           rtc_reg_write(cli_id,0x004c,0x1);
+           rtc_reg_write(cli_id,0x0040,0x0);
+           rtc_reg_write(cli_id,0x0040,0x1);
+
+           rtc_reg_read(cli_id, 0x0044, &out);
+           printk("Device Status is : 0x%x\n",out);
+
+//}
+        /*if (dev_table[cli_id].device_class == SIMPLE_COMM_CLASS) {
+           cli_reg_write(cli_id,0x4,0x0); // IER
+           cli_reg_write(cli_id,0x114,0x0); // Extended IER
+           cli_reg_write(cli_id,0x104,0x1); // RC
+        }*/
+
+
+#endif
+#endif
+
+
+	return;
+}	
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/dk_event.c apps_1.2/art/modules/dk_event.c
--- apps/art/modules/dk_event.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/dk_event.c	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,363 @@
+/* anwievent.c - functions for event handling */
+
+
+/*
+                Copyright (c) 2014 Qualcomm Atheros, Inc. All rights reserved.
+                Qualcomm is a trademark of Qualcomm Technologies Incorporated, registered in the United States and other countries.
+                All Qualcomm Technologies Incorporated trademarks are used with permission.
+                Atheros is a trademark of Qualcomm Atheros, Inc., registered in the United States and other countries.
+                Other products and brand names may be trademarks or registered trademarks of their respective owners.
+*/
+
+/*
+DESCRIPTION
+Contains low level functions for event handling.
+*/
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+
+
+#include "dk_event.h"
+
+//void acquireLock(p_event_queue);
+//void releaseLock(p_event_queue);
+
+
+
+spinlock_t driver_lock = SPIN_LOCK_UNLOCKED;
+
+
+// initEventQueue - initialize an event queue
+void initEventQueue(p_event_queue pQueue) 
+{
+	pQueue->pHead = pQueue->pTail = NULL;
+	pQueue->queueSize = 0;
+	return;
+}
+
+
+// deleteEventQueue - delete and cleanup a created event queue
+// This routine will remove and delete all the event structures in the 
+// queue. Performs any other cleanup  needed
+// RETURNS: N/A
+void deleteEventQueue(p_event_queue pQueue)
+{
+	p_event_struct pNextEvent;
+	if (!pQueue) {
+		return;
+	}
+
+	// acquireLock(pQueue);
+	spin_lock_irq(&driver_lock);
+    
+	// cleanup the events in the queue 
+	while (pQueue->pHead) {
+		pNextEvent = pQueue->pHead->pNext;
+		kfree(pQueue->pHead);
+#ifdef DK_DEBUG
+		printk("DK::Free event = %lx \n",(A_UINT_PTR)pQueue->pHead);
+#endif
+		pQueue->queueSize--;
+		pQueue->pHead = pNextEvent;
+	}
+
+//	releaseLock(pQueue);
+	spin_unlock_irq(&driver_lock);
+
+	return;
+}
+
+
+/**************************************************************************
+* createEvent - Create an event
+*
+* This routine will allocate memory for an event and perform any 
+* initialization.  Note that this does not add the event to any Q
+*
+* RETURNS: pointer to the event of NULL if error
+*/
+p_event_struct createEvent
+(
+	UINT32 type,          /* the event ID */
+	UINT32 persistent,    /* set if want a persistent event */
+	UINT32 param1,        /* optional args */
+	UINT32 param2,
+	UINT32 param3,
+	event_handle eventHandle  
+)
+{
+	p_event_struct pEvent;    
+	UINT32	i;
+
+	pEvent = (p_event_struct)kmalloc(sizeof(event_struct),GFP_KERNEL);
+#ifdef DK_DEBUG
+	printk("DK::Create Event:Event Ptr = %x \n",(UINT32)pEvent);
+#endif
+
+	if(!pEvent) {
+		printk("DK:: Unable to allocate memory in createEvent()!\n");
+		return(NULL);
+	}
+
+	// perform initialization of members 
+	pEvent->type = type;
+	pEvent->persistent = persistent;
+	pEvent->param1 = param1;
+	pEvent->param2 = param2;
+	pEvent->param3 = param3;
+	pEvent->pNext = NULL;
+	pEvent->pLast = NULL;
+	for (i=0;i<6;i++) {
+		pEvent->result[i]=0;
+	}
+
+	pEvent->eventHandle = eventHandle;
+
+	return(pEvent);
+}
+
+/* copyEvent - Copy an event struct
+*
+* This routine will allocate memory for a new event and copy member 
+* variables from existing event into new event
+*
+* RETURNS: pointer to the event of NULL if error
+*/
+p_event_struct copyEvent
+(
+	p_event_struct pExistingEvent     /* pointer to event to copy */
+)
+{
+	p_event_struct pNewEvent;    /* pointer to event struct created */
+	UINT32 i;
+
+	if(!pExistingEvent) {
+		printk("DK::Illegal pointer passed to copyEvent!\n");
+		return(NULL);
+	}
+    
+	//pNewEvent = (p_event_struct)kmalloc(sizeof(event_struct),GFP_KERNEL);
+	pNewEvent = (p_event_struct)kmalloc(sizeof(event_struct),GFP_ATOMIC);
+#ifdef DK_DEBUG
+	printk("DK::Copy Event:Event Ptr = %lx \n",(A_UINT_PTR)pNewEvent);
+#endif
+
+
+	if(!pNewEvent) {
+		printk("Error: Unable to allocate memory for new event!\n");
+		return(NULL);
+	}
+
+	pNewEvent->type = pExistingEvent->type;
+	pNewEvent->persistent = pExistingEvent->persistent;
+	pNewEvent->param1 = pExistingEvent->param1;
+	pNewEvent->param2 = pExistingEvent->param2;
+	pNewEvent->param3 = pExistingEvent->param3;
+	pNewEvent->pNext = NULL;
+	pNewEvent->pLast = NULL;
+
+	for (i=0;i<6;i++) {
+		pNewEvent->result[i]=pExistingEvent->result[i];
+	}
+
+	pNewEvent->eventHandle.eventID = pExistingEvent->eventHandle.eventID;
+	pNewEvent->eventHandle.f2Handle = pExistingEvent->eventHandle.f2Handle;
+
+	return(pNewEvent);
+}
+
+/**************************************************************************
+* pushEvent - Put event at tail of eventQueue
+*
+* This routine will put the supplied event at the end of the specified Q.
+* don't want any other threads accessing the Q while doing this, so need
+* to obtain the Q mutex to be able to perform this operation
+*
+* RETURNS: 1 if successful, 0 if not
+*/
+UINT16 pushEvent
+(
+	p_event_struct pEvent,   // pointer to event to add 
+	p_event_queue pQueue,    // pointer to queue to add 
+	BOOLEAN        protect      
+)
+{
+	if(!pQueue || !pEvent) {
+		printk("DK::illegal pointer passed to pushEvent()!\n");
+		return(0);
+	}
+
+	if (protect) {
+		// acquireLock(pQueue);
+		spin_lock_irq(&driver_lock);
+	}
+
+	// add the event to the tail 
+	if (NULL == pQueue->pHead) {
+		// queue is empty, this will be the first item 
+		pQueue->pHead = pEvent;
+		pQueue->pTail = pEvent;    
+	} else {
+		pQueue->pTail->pNext = pEvent;
+		pEvent->pLast = pQueue->pTail;
+		pQueue->pTail = pEvent;
+	}
+	pQueue->queueSize++;
+
+	if (protect) {
+		//releaseLock(pQueue);
+		spin_unlock_irq(&driver_lock);
+	}
+
+	return(1);
+}
+
+/**************************************************************************
+* popEvent - Pop an event from eventQueue head
+*
+* This routine will pop an event from the head of the specified Q.
+* Don't want any other threads accessing the Q while doing this, so need
+* to obtain the Q mutex to be able to perform this operation.
+*
+* RETURNS: pointer to event that was poped, null if fail
+*/
+p_event_struct popEvent
+(
+	p_event_queue pQueue,        // pointer to queue to add to 
+	BOOLEAN        protect      
+)
+{
+	p_event_struct pEvent;        // event that will be poped from queue 
+   
+	if (protect) { 
+		// acquireLock(pQueue);
+		spin_lock_irq(&driver_lock);
+	}
+
+    // get the event from head and update pointers 
+	pEvent = pQueue->pHead;
+	if (pEvent) {
+		pQueue->pHead = pEvent->pNext;    
+		pEvent->pNext = NULL;            
+
+		if(!pQueue->pHead) {
+			// queue is now empty to make tail also null 
+			pQueue->pTail = NULL;
+		} else {
+			pQueue->pHead->pLast = NULL;    // head has no previous link 
+		}
+		pQueue->queueSize--;
+	}
+
+	if (protect) {
+		//releaseLock(pQueue);
+		spin_unlock_irq(&driver_lock);
+	}
+
+    return(pEvent);
+}
+
+
+/**************************************************************************
+* removeEvent - remove an event from eventQueue (anywhere)
+*
+* This routine will remove an event from anywhere (ie middle) in Q.
+* The event to be removed is passed in.
+*
+* RETURNS: 1 if removed, 0 if not
+*/ 
+UINT16 removeEvent
+(
+	p_event_struct pEvent, // event that will be removed from queue 
+	p_event_queue pQueue, // pointer to queue to add to 
+	BOOLEAN        protect      
+)
+{
+	if(!pQueue || !pEvent) {
+		printk("DK::illegal pointer passed to removeEvent()\n");
+		return(0);
+        }
+
+	if(protect) {
+		// acquireLock(pQueue);
+		spin_lock_irq(&driver_lock);
+	}
+
+	// first take care of previous member's forward link
+	if ( pEvent->pLast ) {
+		// this is not the head
+		pEvent->pLast->pNext = pEvent->pNext;
+	} else {
+		// this is the head
+		pQueue->pHead = pEvent->pNext;
+	}
+
+	// next take care of next member's backward link
+	if ( pEvent->pNext ) {
+		// this is not the tail
+		pEvent->pNext->pLast = pEvent->pLast;
+	} else {
+		// this is the tail
+		pQueue->pTail = pEvent->pLast;
+	}	
+
+	// clear event to be no longer linked 
+	pEvent->pLast = NULL;
+	pEvent->pNext = NULL;
+	pQueue->queueSize--;
+
+	// release the mutex 
+	if(protect) {
+		//releaseLock(pQueue);
+		spin_unlock_irq(&driver_lock);
+	}
+
+	return(1);
+}
+
+/**************************************************************************
+* CheckForEvents - Check if queue has any events
+*
+* This routine will check to see if an event queue has any events in it.
+* Need this to be a mutually exclusive operation so need to get mutex
+*
+* RETURNS: Return 1 if events, 0 if not or there are errors
+*/
+UINT16 checkForEvents
+(
+	p_event_queue pQueue,    // Pointer to event queue to start scan 
+	BOOLEAN        protect      
+)
+{
+	UINT16    returnValue;
+
+	if (!pQueue) {
+		printk("DK::illegal pointer passed to checkForEvents()\n");
+		return(0);
+	}
+
+	if (protect) {
+//		acquireLock(pQueue);
+		spin_lock_irq(&driver_lock);
+		
+	}
+
+	if(!pQueue->pHead) {
+		returnValue = 0; // queue is empty, there are no events 
+	} else {
+		returnValue = 1; // queue contains events 
+	}
+
+	if (protect) {
+//		releaseLock(pQueue);
+		spin_unlock_irq(&driver_lock);
+	}
+
+	return(returnValue);
+}
+/*
+*/
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/dk_flash.c apps_1.2/art/modules/dk_flash.c
--- apps/art/modules/dk_flash.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/dk_flash.c	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,1247 @@
+/*
+ * This MTD supports CFI flash devices:
+ *	- BCS or SCS parts such as Intel.
+ *	- AMD/FJ parts such as Toshiba.
+ *
+ * For the AR531X flash design we split the flash into 3 sections:
+ *	0		bootrom
+ *	ROM_SIZE	tffs area
+ *	N-3 sectors	configuration area
+ *
+ * This is optimized for a top boot block part so small sectors can
+ * be used configuration - boot line, radio "eeprom" configuration,
+ * and board configuration.  It is anticipated that the board and
+ * radio sectors will be write protected after programming.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include "dk.h"
+#include "dk_pci_bus.h"
+#include "client.h"
+#include "dk_flash.h"
+#include  "flbase.h"
+#include  "flflash.h"
+
+
+#define NFLC            3 
+#define FLC_BOOTLINE    0 
+#define FLC_BOARDDATA   1 
+#define FLC_RADIOCFG    2
+#define INCLUDE_CFI_AMDFJ               /* AMD/FJ part for production */
+
+
+
+/* CFI commands */
+#define CFI_QUERY			0x98
+
+/* BCS/SCS commands */
+#define SCS_CONFIRM_SET_LOCKBIT		0x01
+#define SCS_SETUP_BLOCK_ERASE		0x20
+#define SCS_SETUP_QUEUE_ERASE		0x28
+#define SCS_SETUP_CHIP_ERASE		0x30
+#define SCS_CLEAR_STATUS		0x50
+#define SCS_SET_LOCKBIT			0x60
+#define SCS_CLEAR_LOCKBIT		0x60
+#define SCS_READ_STATUS			0x70
+#define SCS_READ_ID			0x90
+#define SCS_SUSPEND_WRITE		0xb0
+#define SCS_SUSPEND_ERASE		0xb0
+#define SCS_CONFIG			0xb8
+#define SCS_CONFIRM_WRITE		0xd0
+#define SCS_RESUME_WRITE		0xd0
+#define SCS_CONFIRM_ERASE		0xd0
+#define SCS_RESUME_ERASE		0xd0
+#define SCS_CONFIRM_CLEAR_LOCKBIT	0xd0
+#define SCS_WRITE_TO_BUFFER		0xe8
+#define SCS_READ_ARRAY			0xff
+
+#define SCS_WSM_ERROR		0x3a	/* BCS/SCS status register bits */
+#define SCS_SR_BLOCK_LOCK	0x02
+#define SCS_SR_WRITE_SUSPEND	0x04
+#define SCS_SR_VPP_ERROR	0x08
+#define SCS_SR_WRITE_ERROR	0x10
+#define SCS_SR_LOCK_SET_ERROR	0x10
+#define SCS_SR_ERASE_ERROR	0x20
+#define SCS_SR_LOCK_RESET_ERROR	0x20
+#define SCS_SR_ERASE_SUSPEND	0x40
+#define SCS_SR_READY		0x80
+
+/* AMD commands */
+#define AMD_SETUP_ERASE		0x80
+#define AMD_SETUP_WRITE		0xa0
+#define AMD_READ_ID 		0x90
+#define AMD_SUSPEND_ERASE	0xb0
+#define AMD_SECTOR_ERASE	0x30
+#define AMD_RESUME_ERASE	0x30
+#define AMD_RESET_ARRAY		0xf0
+
+/*
+ * SST flash distinguishes between SECTOR_ERASE (0x1000 bytes)
+ * and BLOCK_ERASE (0x10000 bytes).
+ */
+#define SST_BLOCK_ERASE         0x50
+
+#define	AMD_UNLOCK_1		0xaa
+#define AMD_UNLOCK_2		0x55
+
+#define AMD_UNLOCK_ADDR1	0x555
+#define	AMD_UNLOCK_ADDR2	0x2aa
+
+#define	AMD_D2			4	/* Toggles when erase suspended */
+#define AMD_D5			0x20	/* Set when programming timeout */
+#define	AMD_D6			0x40	/* Toggles when programming */
+
+/* CFI command set IDs */
+#define INTEL_COMMAND_SET	0x0001
+#define AMDFUJ_COMMAND_SET	0x0002
+
+/* CFI identification strings */
+#define ID_STR_LENGTH		3
+#define QUERY_ID_STR		"QRY"
+#define PRIMARY_ID_STR		"PRI"
+#define ALTERNATE_ID_STR	"ALT"
+
+/* optional commands support */
+#define CHIP_ERASE_SUPPORT	0x0001
+#define SUSPEND_ERASE_SUPPORT	0x0002
+#define SUSPEND_WRITE_SUPPORT	0x0004
+#define LOCK_SUPPORT		0x0008
+#define QUEUED_ERASE_SUPPORT	0x0010
+
+#ifndef DEBUG_PRINT
+#define DEBUG_PRINT(args)
+#endif
+
+/*
+ * Indicates that we're using an SST flash part (39VF160).
+ * This part uses an AMD/Fujitsu flash command set, but with
+ * different addresses than usual (0x5555 rather than 0x555,
+ * and 0x2aaa rather than 0x2aa).
+ */
+static BOOLEAN SSTflash;
+
+/*
+ * Structure to hold flash parameters.  Stores additional data for
+ * sysFlash interface.
+ */
+struct cfi {
+    UINT8 *base;	        /* base of config flash */
+    UINT16 type;		/* type of flash device */
+    UINT32 size;		/* size of flash device */
+    UINT32 blockSize;		/* erase block size for tffs */
+    UINT32 cap;			/* size CAP for tffs */
+    UINT16 wb;			/* write buffer depth */
+    UINT16 cmdSet;		/* Intel or AMD */
+    UINT32 eraseTimeoutMs;	/* Max erase timeout in milliseconds */
+    UINT32 writeTimeoutUs;	/* Max write timeout in microseconds */
+    BOOLEAN vpp;		/* true if need vpp */
+    BOOLEAN x16;		/* width of device */
+    BOOLEAN ok;			/* sysFlashConfigInit status */
+    BOOLEAN top;		/* top boot block part */
+    UINT8 *flcPtr[NFLC];	/* segment base address */
+    int flcSize[NFLC];		/* segment size */
+    int flcReq[NFLC];		/* segment required size */
+    FLStatus (*write)(FlashPTR flashPtr, int offset, UINT8 *p, int len);
+    FLStatus (*erase)(FlashPTR flashPtr);
+    INT8 readCmd;		/* READ_ARRAY command */
+    UINT32 eBlocks;             /* cache of erase block layout */
+#define MAX_EBLOCKS 8
+    UINT32 ebSize[MAX_EBLOCKS];
+    UINT32 ebNum[MAX_EBLOCKS];
+} cfi;
+
+#define QRY(FP, mul) \
+	(((char)FP[0x10*(mul)] == 'Q') && \
+	 ((char)FP[0x11*(mul)] == 'R') && \
+	 ((char)FP[0x12*(mul)] == 'Y'))
+
+/*
+ * Mutual exclusion for tffs vs config and boot rom update.
+ *
+ * On flash mode changes (erase and write) we need to prevent
+ * mixed access to the flash device.  Reads are also special
+ * as tffs reads are done outside the driver, so boot accesses
+ * also prevent rescheduling for the duration of their access.
+ *
+ * Boot changes are infrequent and usually quick for config
+ * updates, so this is not a major issue.
+ *
+ * It is ok for the sema allocation to not take place.  This
+ * can happen during boot rom start-up.  In this environment
+ * there are no races anyway.
+ */
+static int *flSem = NULL;
+#define FL_LOCK_BOOT	0x01
+#define FL_LOCK_WRITE	0x02
+static int
+cfiLock(int mode)
+{
+    int rc = 0;
+
+    if (flSem == NULL) {
+        //flSem = semBCreate(SEM_Q_PRIORITY, SEM_FULL);
+    }
+    if (flSem != NULL) {
+        //semTake(flSem, WAIT_FOREVER);
+        if (mode & FL_LOCK_BOOT) {
+            //taskLock();
+        }
+    }
+
+    if (mode & FL_LOCK_WRITE) {
+//        rc = sysRegRead(AR531X_FLASHCTL0);
+//        sysRegWrite(AR531X_FLASHCTL0, rc & ~FLASHCTL_WP);
+    }
+
+    return rc;
+}
+
+static void
+cfiUnlock(int mode, int cookie)
+{
+    if (mode & FL_LOCK_WRITE) {
+//        sysRegWrite(AR531X_FLASHCTL0, cookie);
+    }
+
+    if (flSem) {
+        //semGive(flSem);
+        if (mode & FL_LOCK_BOOT) {
+            //taskUnlock();
+        }
+    }
+}
+
+#ifdef INCLUDE_MTD_CFISCS
+
+#include "backgrnd.h"
+
+#define thisCFI   ((struct cfi *)vol.mtdVars)
+
+/*
+ * cfiWrite - MTD write interface for all flash types.
+ */
+static FLStatus
+cfiWrite(FLFlash vol, CardAddress address, const void *buffer,
+         int length, int mode)
+{
+    FLStatus status = flOK;
+    int from, eachWrite;
+    FlashPTR flashPtr;
+    int s;
+
+    DEBUG_PRINT(("Debug: write 0x%x for %d.\n", (int)address, length));
+
+    /* Only write words on word-boundary for x16 devices */
+    if (thisCFI->x16 && ((length & 1) || (address & 1))) {
+        return flBadParameter;
+    }
+
+    if (flWriteProtected(vol.socket)) {
+        return flWriteProtect;
+    }
+
+#ifdef SOCKET_12_VOLTS
+    if (thisCFI->vpp) {
+        checkStatus(flNeedVpp(vol.socket));
+    }
+#endif
+
+    s = cfiLock(FL_LOCK_WRITE);
+
+    eachWrite = thisCFI->wb;
+
+    for (from = 0; from < length && status == flOK; from += eachWrite) {
+        flashPtr = (FlashPTR)flMap(vol.socket, address + from);
+        status = thisCFI->write(flashPtr, 0,
+                                ((char *)buffer) + from,
+                                min(length - from, eachWrite));
+    }
+
+#ifdef SOCKET_12_VOLTS
+    if (thisCFI->vpp) {
+        flDontNeedVpp(vol.socket);
+    }
+#endif
+
+    flashPtr = (FlashPTR) flMap(vol.socket, address);
+    /* verify the data */
+    if (status == flOK && tffscmp((void *)flashPtr, buffer, length)) {
+        printk("cfiscs: write failed in verification @ %p.\n",
+               (void *)flashPtr);
+        status = flWriteFault;
+    }
+
+    cfiUnlock(FL_LOCK_WRITE, s);
+
+    return status;
+}
+
+/*
+ * cfiErase - MTD erase wrapper.
+ */
+static FLStatus
+cfiErase(FLFlash vol, int firstErasableBlock, int numOfErasableBlocks)
+{
+    FLStatus status = flOK;       /* unless proven otherwise */
+    FlashPTR flashPtr;
+    int blk;
+    int s;
+
+    DEBUG_PRINT(("Debug: erase 0x%lx %d blocks.\n",
+                 firstErasableBlock  * vol.erasableBlockSize,
+                 numOfErasableBlocks));
+
+    if (flWriteProtected(vol.socket)) {
+        return flWriteProtect;
+    }
+
+#ifdef SOCKET_12_VOLTS
+    if (thisCFI->vpp) {
+        checkStatus(flNeedVpp(vol.socket));
+    }
+#endif
+
+    s = cfiLock(FL_LOCK_WRITE);
+
+    for (blk = 0; blk < numOfErasableBlocks && status == flOK; blk++) {
+        flashPtr = (FlashPTR)vol.map(&vol,
+                                     (firstErasableBlock + blk) * vol.erasableBlockSize,
+                                     vol.interleaving);
+
+        status = thisCFI->erase(flashPtr);
+    }
+
+    cfiUnlock(FL_LOCK_WRITE, s);
+
+#ifdef SOCKET_12_VOLTS
+    if (thisCFI->vpp) {
+        flDontNeedVpp(vol.socket);
+    }
+#endif
+
+    return status;
+}
+
+/*
+ * cfiscsIdentify - Identifies media based on CFI and registers as an
+ *                  MTD for such.
+ *
+ * This routine will be placed on the MTD list in custom.h.  It must be
+ * an extern routine.
+ *
+ * On successful identification, the Flash structure is filled out and
+ * the write and erase routines registered.
+ */
+FLStatus
+cfiscsIdentify(FLFlash vol)
+{
+    int s;
+
+    DEBUG_PRINT(("Debug: entering CFISCS identification routine.\n"));
+
+    flSetWindowSpeed(vol.socket, 120);    /* 120 nsec. */
+    flSetWindowSize(vol.socket, 2);       /* 8 KBytes */
+
+    /*
+     * Interleaving probing support has been removed for
+     * simplicity and to allow the boot and tffs interfaces
+     * to share code.
+     */
+    vol.interleaving = 1;
+    vol.mtdVars = &cfi;
+    vol.noOfChips = 1;
+
+    if (thisCFI->ok == FALSE) {
+        DEBUG_PRINT(("Debug: device not ok.\n"));
+        return flUnknownMedia;
+    }
+
+    s = cfiLock(FL_LOCK_WRITE);
+
+    flSetWindowBusWidth(vol.socket, thisCFI->x16 ? 16 : 8);
+
+    vol.write = cfiWrite;
+    vol.erase = cfiErase;
+    vol.type = thisCFI->type;
+    vol.erasableBlockSize = thisCFI->blockSize;
+    vol.chipSize = thisCFI->cap;
+
+    cfiUnlock(FL_LOCK_WRITE, s);
+    DEBUG_PRINT(("Debug: ok.\n"));
+
+    return flOK;
+}
+#endif /* INCLUDE_MTD_CFISCS */
+
+#ifdef INCLUDE_CFI_SCS
+/*
+ * cfiscsBlockErase_x8 - Erase the block pointed to by flashPtr.
+ */
+static FLStatus
+cfiscsBlockErase_x8(FlashPTR flashPtr)
+{
+    FLStatus status = flOK;       /* unless proven otherwise */
+    int maxTo = cfi.eraseTimeoutMs * 10;
+    FLBoolean finished;
+    int to = 0;
+
+    /* Intel part does not have queued erase support */
+    flashPtr[0] = SCS_SETUP_BLOCK_ERASE;
+    flashPtr[0] = SCS_CONFIRM_ERASE;
+
+    do {
+        finished = TRUE;
+        flashPtr[0] = SCS_READ_STATUS;
+        udelay(100);			/* .1ms */
+        if (!(flashPtr[0] & SCS_SR_READY)) {
+            finished = FALSE;
+        } else if (flashPtr[0] & SCS_SR_ERASE_SUSPEND) {
+            flashPtr[0] = SCS_RESUME_ERASE;
+            finished = FALSE;
+        } else if (to++ > maxTo) {
+            status = flTimedOut;
+            finished = TRUE;
+        } else {
+            if (flashPtr[0] & SCS_WSM_ERROR) {
+                DEBUG_PRINT(("Debug: CFISCS erase error.\n"));
+                status = (flashPtr[0] & SCS_SR_VPP_ERROR) ?
+                    flVppFailure : flWriteFault;
+                flashPtr[0] = SCS_CLEAR_STATUS;
+            }
+        }
+    } while (!finished);
+
+    flashPtr[0] = SCS_READ_ARRAY;
+
+    return status;
+}
+
+/*
+ * cfiscsBlockErase_x16 - Erase the block pointed to by flashPtr.
+ */
+static FLStatus
+cfiscsBlockErase_x16(FlashPTR bytePtr)
+{
+    FlashWPTR flashPtr = (FlashWPTR)bytePtr;
+    FLStatus status = flOK;       /* unless proven otherwise */
+    int maxTo = cfi.eraseTimeoutMs * 10;
+    FLBoolean finished;
+    int to = 0;
+
+    /* Intel part does not have queued erase support */
+    flashPtr[0] = SCS_SETUP_BLOCK_ERASE; /* FlashPtr points at block */
+    flashPtr[0] = SCS_CONFIRM_ERASE;
+
+    do {
+        finished = TRUE;
+        flashPtr[0] = SCS_READ_STATUS;
+        udelay(100);		/* .1ms */
+        if (!(flashPtr[0] & SCS_SR_READY)) {
+            finished = FALSE;
+        } else if (flashPtr[0] & SCS_SR_ERASE_SUSPEND) {
+            flashPtr[0] = SCS_RESUME_ERASE;
+            finished = FALSE;
+        } else if (to++ > maxTo) {
+            status = flTimedOut;
+            finished = TRUE;
+        } else {
+            if (flashPtr[0] & SCS_WSM_ERROR) {
+                DEBUG_PRINT(("Debug: CFISCS erase error.\n"));
+                status = (flashPtr[0] & SCS_SR_VPP_ERROR) ?
+                    flVppFailure : flWriteFault;
+                flashPtr[0] = SCS_CLEAR_STATUS;
+            }
+        }
+    } while (!finished);
+
+    flashPtr[0] = SCS_READ_ARRAY;
+
+    return status;
+}
+
+/*
+ * cfiscsBufferWrite_x8 - write len bytes from p at flashPtr.
+ */
+static FLStatus
+cfiscsBufferWrite_x8(FlashPTR flashPtr, int offset, UINT8 *p, int len)
+{
+    FLStatus status = flOK;
+    int i, to;
+
+    to = 0;
+    do {
+        *flashPtr = SCS_WRITE_TO_BUFFER;
+        udelay(20);
+    } while (!(*flashPtr & SCS_SR_READY) && (to++ < 1000));
+    if (!(*flashPtr & SCS_SR_READY)) {
+        printk("cfiscs: timeout error for WRITE_TO_BUFFER @ %p.\n",
+               flashPtr);
+        status = flTimedOut;
+    }
+
+    *flashPtr = len - 1;		/* 0 == 1 byte */
+
+    /* tffscpy() */
+    for (i = 0; i < len; i++) {
+        flashPtr[offset+i] = p[i];
+    }
+
+    *flashPtr = SCS_CONFIRM_WRITE;
+
+    for (to=0; !(*flashPtr & SCS_SR_READY) && (to < cfi.writeTimeoutUs); to++) {
+        udelay(1);
+    }
+    if (!(*flashPtr & SCS_SR_READY)) {
+        printk("cfiscs: timeout error for CONFIRM_WRITE @ %p.\n",
+               flashPtr);
+        status = flTimedOut;
+    }
+    if (*flashPtr & SCS_WSM_ERROR) {
+        printk("cfiscs: WSM_ERROR @ %p.\n", flashPtr);
+        status = (*flashPtr & SCS_SR_VPP_ERROR) ? flVppFailure : flWriteFault;
+        *flashPtr = SCS_CLEAR_STATUS;
+    }
+
+    *flashPtr = SCS_READ_ARRAY;
+
+    return status;
+}
+
+/*
+ * cfiscsBufferWrite_x16 - write len bytes from p at flashPtr.  Interface
+ * is in bytes, not words.
+ */
+static FLStatus
+cfiscsBufferWrite_x16(FlashPTR bytePtr, int offset, UINT8 *p, int len)
+{
+    FlashWPTR flashPtr = (FlashWPTR)bytePtr;
+    FLStatus status = flOK;
+    int i, idx, to;
+    UINT16 val;
+    int pad;
+
+    to = 0;
+    do {
+        *flashPtr = SCS_WRITE_TO_BUFFER;
+        udelay(20);
+    } while (!(*flashPtr & SCS_SR_READY) && (to++ < 1000));
+    if (!(*flashPtr & SCS_SR_READY)) {
+        printk("cfiscs: timeout error for WRITE_TO_BUFFER @ %p.\n",
+               flashPtr);
+        status = flTimedOut;
+    }
+
+    /* handle pad byte at start and/or end.  Caller accomidates this */
+    pad = (offset & 1) + ((offset & 1) ^ (len & 1));
+    *flashPtr = ((len + pad) >> 1) - 1;		/* 0 == 1 word */
+
+    /* tffscpy() */
+    for (i = 0; i < len; ) {
+        idx = (offset + i) >> 1;
+        if (((offset+i) & 1) == 0) {
+            val = p[i++] << 8;
+            val |= (i < len) ? (p[i++] & 0xff) : 0x00ff;
+        } else {
+            val = (p[i++] & 0xff) | 0xff00;
+        }
+        flashPtr[idx] = val;
+    }
+
+    *flashPtr = SCS_CONFIRM_WRITE;
+
+    for (to=0; !(*flashPtr & SCS_SR_READY) && (to < cfi.writeTimeoutUs); to++) {
+        udelay(1);
+    }
+    if (!(*flashPtr & SCS_SR_READY)) {
+        printk("cfiscs: timeout error for CONFIRM_WRITE @ %p.\n",
+               flashPtr);
+        status = flTimedOut;
+    }
+    if (*flashPtr & SCS_WSM_ERROR) {
+        printk("cfiscs: WSM_ERROR @ %p.\n", flashPtr);
+        status = (*flashPtr & SCS_SR_VPP_ERROR) ? flVppFailure : flWriteFault;
+        *flashPtr = SCS_CLEAR_STATUS;
+    }
+
+    *flashPtr = SCS_READ_ARRAY;
+
+    return status;
+}
+#endif  /* INCLUDE_MTD_CFISCS */
+
+#ifdef INCLUDE_CFI_AMDFJ
+/*
+ * cfiamdBlockErase_x8 - Erase the block pointed to by flashPtr.
+ */
+#ifdef UNUSED
+static FLStatus
+cfiamdBlockErase_x8(FlashPTR flashPtr)
+{
+    int maxTo = cfi.eraseTimeoutMs * 10;
+    int to = 0;
+
+    cfi.base[0xaaa] = AMD_UNLOCK_1;
+    cfi.base[0x555] = AMD_UNLOCK_2;
+    cfi.base[0xaaa] = AMD_SETUP_ERASE;
+    cfi.base[0xaaa] = AMD_UNLOCK_1;
+    cfi.base[0x555] = AMD_UNLOCK_2;
+    flashPtr[0] = AMD_SECTOR_ERASE;
+
+    while (1) {
+        udelay(100);			/* .1ms */
+        if (((flashPtr[0] ^ flashPtr[0]) & AMD_D6) == 0) {
+            break;
+        }
+        if (to++ > maxTo) {
+            printk("cfiamd: erase timeout @ %p\n", (void *)flashPtr);
+            *flashPtr = AMD_RESET_ARRAY;
+            return flWriteFault;
+        }
+    }
+    if (flashPtr[0] != 0xff) {
+        if (flashPtr[0] & AMD_D5) {
+            printk("cfiamd: D5 erase timeout @ %p\n", (void *)flashPtr);
+        } else {
+            printk("cfiamd: erase mismatch @ %p\n", (void *)flashPtr);
+        }
+        *flashPtr = AMD_RESET_ARRAY;
+        return flWriteFault;
+    }
+
+    return flOK;
+}
+#endif
+/*
+ * cfiamdBlockErase_x16 - Erase the block pointed to by flashPtr.
+ */
+static FLStatus
+cfiamdBlockErase_x16(FlashPTR bytePtr)
+{
+    FlashWPTR flashBase = (FlashWPTR)cfi.base;
+    FlashWPTR flashPtr = (FlashWPTR)bytePtr;
+    int maxTo = cfi.eraseTimeoutMs * 10;
+    int to = 0;
+
+    if (SSTflash) {
+        flashBase[0x5555] = AMD_UNLOCK_1;
+        flashBase[0x2aaa] = AMD_UNLOCK_2;
+        flashBase[0x5555] = AMD_SETUP_ERASE;
+        flashBase[0x5555] = AMD_UNLOCK_1;
+        flashBase[0x2aaa] = AMD_UNLOCK_2;
+        flashPtr[0] = SST_BLOCK_ERASE;
+    } else {
+        flashBase[0x555] = AMD_UNLOCK_1;
+        flashBase[0x2aa] = AMD_UNLOCK_2;
+        flashBase[0x555] = AMD_SETUP_ERASE;
+        flashBase[0x555] = AMD_UNLOCK_1;
+        flashBase[0x2aa] = AMD_UNLOCK_2;
+        flashPtr[0] = AMD_SECTOR_ERASE;
+    }
+
+    while (1) {
+        udelay(100);			/* 0.1ms */
+        if (((flashPtr[0] ^ flashPtr[0]) & AMD_D6) == 0) {
+            break;
+        }
+        if (to++ > maxTo) {
+            printk("cfiamd: erase timeout @ %p\n", (void *)flashPtr);
+            *flashPtr = AMD_RESET_ARRAY;
+            return flWriteFault;
+        }
+    }
+    if (flashPtr[0] != 0xffff) {
+        if (flashPtr[0] & AMD_D5) {
+            printk("cfiamd: D5 erase timeout @ %p\n", (void *)flashPtr);
+        } else {
+            printk("cfiamd: erase mismatch @ %p\n", (void *)flashPtr);
+        }
+        *flashPtr = AMD_RESET_ARRAY;
+        return flWriteFault;
+    }
+
+    return flOK;
+}
+
+/*
+ * cfiamdBufferWrite_x8 - write len bytes from p at flashPtr.
+ */
+#ifdef UNUSED
+static FLStatus
+cfiamdBufferWrite_x8(FlashPTR flashPtr, int offset, UINT8 *p, int len)
+{
+    FlashPTR flashBase = (FlashPTR)cfi.base;
+    int maxTo = cfi.writeTimeoutUs;
+    int i, to;
+
+    for (i = 0; i < len; i++) {
+        flashBase[0xaaa] = AMD_UNLOCK_1;
+        flashBase[0x555] = AMD_UNLOCK_2;
+        flashBase[0xaaa] = AMD_SETUP_WRITE;   
+        flashPtr[offset+i] = p[i];
+
+        to = 0;
+        while (1) {
+            udelay(1);
+            if (((flashPtr[offset+i] ^ flashPtr[offset+i]) & AMD_D6) == 0) {
+                break;
+            }
+            if (to++ > maxTo) {
+                printk("cfiamd: write timeout @ %p\n", (void *)flashPtr+offset+i);
+                *flashPtr = AMD_RESET_ARRAY;
+            }
+        }
+
+        if (flashPtr[offset+i] != p[i]) {
+            printk("cfiamd: write %s @ %p (%x != %x)\n",
+                   (flashPtr[offset+i] & AMD_D5) ? "D5 timeout" : "mismatch",
+                   (void *)flashPtr+offset+i, flashPtr[offset+i], p[i]);
+            *flashPtr = AMD_RESET_ARRAY;
+            return flWriteFault;
+        }
+    }
+
+    return flOK;
+}
+#endif
+/*
+ * cfiamdBufferWrite_x16 - write len bytes from p at flashPtr.  Interface
+ * is in bytes, not words.
+ */
+static FLStatus
+cfiamdBufferWrite_x16(FlashPTR bytePtr, int offset, UINT8 *p, int len)
+{
+    FlashWPTR flashBase = (FlashWPTR)cfi.base;
+    FlashWPTR flashPtr = (FlashWPTR)bytePtr;
+    int maxTo = cfi.writeTimeoutUs;
+    int i, idx, to;
+    UINT16 val;
+
+    for (i = 0; i < len; ) {
+
+        idx = (offset + i) >> 1;
+        if (((offset+i) & 1) == 0) {
+            val = p[i++] << 8;
+            val |= (i < len) ? (p[i++] & 0xff) : (flashPtr[idx] & 0xff);
+        } else {
+            val = (p[i++] & 0xff) | (flashPtr[idx] & 0xff00);
+        }
+        if (SSTflash) {
+            flashBase[0x5555] = AMD_UNLOCK_1;
+            flashBase[0x2aaa] = AMD_UNLOCK_2;
+            flashBase[0x5555] = AMD_SETUP_WRITE;
+        } else {
+            flashBase[0x555] = AMD_UNLOCK_1;
+            flashBase[0x2aa] = AMD_UNLOCK_2;
+            flashBase[0x555] = AMD_SETUP_WRITE;
+        }
+        flashPtr[idx] = val;
+
+        to = 0;
+        while (1) {
+            udelay(1);
+            if (((flashPtr[idx] ^ flashPtr[idx]) & AMD_D6) == 0) {
+                break;
+            }
+            if (to++ > maxTo) {
+                printk("cfiamd: write timeout @ %p\n", (void *)flashPtr+offset+i);
+                *flashPtr = AMD_RESET_ARRAY;
+            }
+        }
+        if (flashPtr[idx] != val) {
+            printk("cfiamd: write %s @ %p (%x != %x)\n",
+                   (flashPtr[idx] & AMD_D5) ? "D5 timeout" : "mismatch",
+                   (void *)flashPtr+offset+i, flashPtr[offset+i], val);
+            *flashPtr = AMD_RESET_ARRAY;
+            return flWriteFault;
+        }
+    }
+
+    return flOK;
+}
+
+/*
+ * EEPROM on flash emulation low level support.  Uses common low level
+ * code and locking to avoid boot vs tffs contention.
+ *
+ * The last NFLC flash sector are reserved for various
+ * configuration items that do not belong in the flash filesystem
+ * as they are low level configuration (bootline), or wish to
+ * use the locking features of the flash device (board config).
+ *
+ * A top boot block part is prefered as it will waste less space
+ * as these configuration items are saved at the end of the device.
+ */
+#endif
+#ifdef UNUSED
+static BOOLEAN
+sysFlashConfigInit_x8(FlashPTR flashPtr)
+{
+    int i, j, off, nb, sz;
+    char *base;
+
+    cfi.size = 0;
+
+    /* Query the flash device */
+    flashPtr[0] = SCS_READ_ARRAY;
+    flashPtr[0x55*2] = CFI_QUERY;
+
+    /* Some boards have a x8 AMD part stuffed -- skip it */
+    if (!QRY(flashPtr, 2)) {
+        return FALSE;
+    }
+
+    cfi.cmdSet = flashPtr[0x13*2] | ((unsigned)flashPtr[0x14*2] << 8);
+#ifdef INCLUDE_CFI_SCS
+    if (cfi.cmdSet == INTEL_COMMAND_SET) {
+        cfi.write = cfiscsBufferWrite_x8;
+        cfi.erase = cfiscsBlockErase_x8;
+        cfi.readCmd = SCS_READ_ARRAY;
+    }
+#endif
+#ifdef INCLUDE_CFI_AMDFJ
+    if (cfi.cmdSet == AMDFUJ_COMMAND_SET) {
+        cfi.write = cfiamdBufferWrite_x8;
+        cfi.erase = cfiamdBlockErase_x8;
+        cfi.readCmd = AMD_RESET_ARRAY;
+    }
+#endif
+    if (cfi.write == NULL) {
+        return FALSE;
+    }
+
+    cfi.size = 1L << flashPtr[0x27*2];
+    cfi.type = (FlashType) ((flashPtr[0] << 8) | flashPtr[0x1*2]);
+    cfi.vpp = (flashPtr[0x1d*2] != 0) ? TRUE : FALSE;
+    cfi.wb = 1L << (flashPtr[0x2a*2] | ((unsigned)flashPtr[0x2b*2] << 8));
+
+    cfi.eraseTimeoutMs = (1 << flashPtr[0x21*2]) * (1 << flashPtr[0x25*2]);
+    if (cfi.wb == 1) {
+        /* single write */
+        cfi.writeTimeoutUs = (1 << flashPtr[0x1f*2]) * (1 << flashPtr[0x23*2]);
+    } else {
+        /* buffer write */
+        cfi.writeTimeoutUs = (1 << flashPtr[0x20*2]) * (1 << flashPtr[0x24*2]);
+    }
+
+    if (cfi.cmdSet == AMDFUJ_COMMAND_SET) {
+        /* check for top part */
+        off = flashPtr[0x15*2] | ((unsigned)flashPtr[0x16*2]<<8);
+        cfi.top = (flashPtr[(off+0xf)*2] == 3) ? TRUE : FALSE;
+    }
+
+    cfi.blockSize = 0;
+    cfi.eBlocks = flashPtr[0x2c*2];
+    off = 0x2d;
+    if (cfi.top) {
+        for (i=cfi.eBlocks-1; i >= 0; i--) {
+            cfi.ebNum[i] = (flashPtr[off*2] |
+                            ((unsigned)flashPtr[(off+1)*2]) << 8) + 1;
+            cfi.ebSize[i] = (flashPtr[(off+2)*2] |
+                             ((unsigned)flashPtr[(off+3)*2]) << 8) * 0x100;
+            if (cfi.ebSize[i] > cfi.blockSize) {
+                cfi.blockSize = cfi.ebSize[i];
+            }
+            off += 4;
+        }
+    } else {
+        for (i=0; i < cfi.eBlocks; i++) {
+            cfi.ebNum[i] = (flashPtr[off*2] |
+                            ((unsigned)flashPtr[(off+1)*2]) << 8) + 1;
+            cfi.ebSize[i] = (flashPtr[(off+2)*2] |
+                             ((unsigned)flashPtr[(off+3)*2]) << 8) * 0x100;
+            if (cfi.ebSize[i] > cfi.blockSize) {
+                cfi.blockSize = cfi.ebSize[i];
+            }
+            off += 4;
+        }
+    }
+    base = cfi.base + cfi.size;
+    off = cfi.eBlocks - 1;
+    i = NFLC - 1;
+    while (i >= 0) {
+        nb = cfi.ebNum[off];
+        //sz = cfi.ebSize[off];  // Siva
+        sz = (DK_BOARDCONFIG_SIZE > DK_RADIOCONFIG_SIZE)?DK_BOARDCONFIG_SIZE:DK_RADIOCONFIG_SIZE;
+        for (j=0; (j < nb) && (i >= 0); j++) {
+            base -= sz;
+            cfi.flcPtr[i] = base;
+            cfi.flcSize[i] = sz;
+            i--;
+        }
+        off--;
+    }
+
+    flashPtr[0] = cfi.readCmd;
+
+    return TRUE;
+}
+#endif
+/*
+ * We support two different varieties of flash parts with slightly
+ * different command sets (Intel versus AMD).  If a CFI QRY fails
+ * with the Intel command set, we try AMD.
+ *
+ * AR5311 flash parts all use Intel command set.
+ * AR5312 flash may use an SST flash part, which
+ * uses the AMD/Fujitsu command set at different addresses.
+ * We determine which part we have dynamically by trying
+ * several QRY commands and seeing which one works.
+ */
+static BOOLEAN
+sysFlashConfigInit_x16(FlashWPTR ptr)
+{
+    int i, off;
+    char *base;
+    FlashWPTR flashPtr;
+    char * basePtr;
+
+    cfi.size = 0;
+    cfi.base = (UINT8 *)(ioremap((phys_t)ptr, 0x10000));
+    flashPtr = (FlashWPTR)(cfi.base);
+
+    /* Query the flash device */
+    flashPtr[0] = SCS_READ_ARRAY;
+    flashPtr[0x55] = CFI_QUERY;
+
+printk("ptr is 0x%x\n", (unsigned int)ptr);
+printk("flashPtr is 0x%x\n", (unsigned int)flashPtr);
+
+    /* look for the query identification string "QRY" */
+    if (!QRY(flashPtr, 1)) {
+        flashPtr[0] = SCS_READ_ARRAY;
+        flashPtr[0x5555] = 0xaa;
+        flashPtr[0x2aaa] = 0x55;
+        flashPtr[0x5555] = CFI_QUERY;
+        if (!QRY(flashPtr, 1)) {
+            return FALSE;
+        } else {
+            /* Force SST device to look like AMD */
+            cfi.cmdSet = AMDFUJ_COMMAND_SET;
+            SSTflash = TRUE;
+        }
+    } else {
+        cfi.cmdSet = flashPtr[0x13] | (flashPtr[0x14] << 8);
+        SSTflash = FALSE;
+    }
+#ifdef INCLUDE_CFI_SCS
+    if (cfi.cmdSet == INTEL_COMMAND_SET) {
+        cfi.write = cfiscsBufferWrite_x16;
+        cfi.erase = cfiscsBlockErase_x16;
+        cfi.readCmd = SCS_READ_ARRAY;
+    }
+#endif
+#ifdef INCLUDE_CFI_AMDFJ
+    if (cfi.cmdSet == AMDFUJ_COMMAND_SET) {
+        cfi.write = cfiamdBufferWrite_x16;
+        cfi.erase = cfiamdBlockErase_x16;
+        cfi.readCmd = AMD_RESET_ARRAY;
+    }
+#endif
+    if (cfi.write == NULL) {
+        return FALSE;
+    }
+
+    cfi.size = 1L << flashPtr[0x27];
+    /* This is still bytes, which the low level code counts */
+    cfi.type = (flashPtr[0] << 8) | flashPtr[1];
+    cfi.vpp = (flashPtr[0x1d] != 0) ? TRUE : FALSE;
+    cfi.wb = 1L << (flashPtr[0x2a] | ((unsigned)flashPtr[0x2b] << 8));
+    if (cfi.wb > 2) {
+        /*
+         * Conservative for odd byte alignments, but stay a power
+         * of two to avoid odd erase block strides.
+         */
+        cfi.wb >>= 1;
+    }
+    /* AMD code only writes 1 x16 per cycle, so pass in more than 1B */
+    if (cfi.cmdSet == AMDFUJ_COMMAND_SET) {
+        if (cfi.wb == 1) {
+            cfi.wb = 16;
+        }
+        /* check for top part */
+        off = flashPtr[0x15] | ((unsigned)flashPtr[0x16]<<8);
+        cfi.top = (flashPtr[off+0xf] == 3) ? TRUE : FALSE;
+    }
+printk("cfi.size is 0x%x\n", cfi.size);
+printk("cfi.type is 0x%x\n", cfi.type);
+printk("cfi.vpp is 0x%x\n", cfi.vpp);
+printk("cfi.wb is 0x%x\n", cfi.wb);
+printk("cfi.top is 0x%x\n", cfi.top);
+
+    cfi.eraseTimeoutMs = (1 << flashPtr[0x21]) * (1 << flashPtr[0x25]);
+    cfi.writeTimeoutUs = (1 << flashPtr[0x1f]) * (1 << flashPtr[0x23]);
+printk("cfi.eraseTimeoutMs is 0x%x\n", cfi.eraseTimeoutMs);
+printk("cfi.writeTimeoutUs is 0x%x\n", cfi.writeTimeoutUs);
+
+    cfi.blockSize = 0;
+    cfi.eBlocks = flashPtr[0x2c];
+printk("cfi.bBlocks is 0x%x\n", cfi.eBlocks);
+    off = 0x2d;
+    if (cfi.top) {
+        for (i=cfi.eBlocks-1; i >= 0; i--) {
+            cfi.ebNum[i] = (flashPtr[off] |
+                            ((unsigned)flashPtr[(off+1)]) << 8) + 1;
+            cfi.ebSize[i] = (flashPtr[(off+2)] |
+                             ((unsigned)flashPtr[(off+3)]) << 8) * 0x100;
+            if (cfi.ebSize[i] > cfi.blockSize) {
+                cfi.blockSize = cfi.ebSize[i];
+            }
+            off += 4;
+        }
+    } else {
+        for (i=0; i < cfi.eBlocks; i++) {
+            cfi.ebNum[i] = (flashPtr[off] |
+                            ((unsigned)flashPtr[(off+1)]) << 8) + 1;
+            cfi.ebSize[i] = (flashPtr[(off+2)] |
+                             ((unsigned)flashPtr[(off+3)]) << 8) * 0x100;
+            if (cfi.ebSize[i] > cfi.blockSize) {
+                cfi.blockSize = cfi.ebSize[i];
+            }
+            off += 4;
+printk("i is %x, cfi.ebNum is 0x%x\n", i, cfi.ebNum[i]);
+printk("i is %x, cfi.ebSize is 0x%x\n", i, cfi.ebSize[i]);
+        }
+    }
+//    base = cfi.base + cfi.size;
+printk("ptr is 0x%x\n", (unsigned int)ptr);
+printk("cfi.base is 0x%x\n", cfi.size);
+printk("cfi.blockSize is 0x%x\n", cfi.blockSize);
+    off = cfi.eBlocks - 1;
+    base = (UINT8 *)(ptr) + cfi.size - cfi.ebSize[off];
+    basePtr = (UINT8 *)(ioremap((phys_t)base, cfi.ebSize[off]));
+    i = NFLC - 1;
+
+printk("base is 0x%x\n", (unsigned int)base);
+printk("basePtr is 0x%x\n", (unsigned int)basePtr);
+printk("off is 0x%x\n", off);
+    cfi.flcPtr[FLC_BOOTLINE] = basePtr;
+    cfi.flcSize[FLC_BOOTLINE] = 0;
+    cfi.flcPtr[FLC_BOARDDATA] = basePtr;
+    cfi.flcSize[FLC_BOARDDATA] = DK_BOARDCONFIG_SIZE;
+    cfi.flcPtr[FLC_RADIOCFG] = basePtr + DK_BOARDCONFIG_SIZE;
+    cfi.flcSize[FLC_RADIOCFG] = DK_RADIOCONFIG_SIZE;
+printk("i=0:fPtr=0x%x:fS=0x%x:ebSize=0x%x\n", (unsigned int)cfi.flcPtr[0], cfi.flcSize[0], cfi.ebSize[off]);
+printk("i=1:fPtr=0x%x:fS=0x%x:ebSize=0x%x\n", (unsigned int)cfi.flcPtr[1], cfi.flcSize[1], cfi.ebSize[off]);
+printk("i=2:fPtr=0x%x:fS=0x%x:ebSize=0x%x\n", (unsigned int)cfi.flcPtr[2], cfi.flcSize[2], cfi.ebSize[off]);
+
+    flashPtr[0] = cfi.readCmd;
+
+    return TRUE;
+}
+
+void
+sysFlashConfigInit(void *ptr, INT32 bl, INT32 bd, INT32 rc)
+{
+    int i;
+    if (cfi.ok == TRUE) {
+        /* No need to re-initialize the flash on reboot */
+        return;
+    }
+
+    cfi.ok = FALSE;
+    cfi.flcReq[FLC_BOOTLINE] = bl;
+    cfi.flcReq[FLC_BOARDDATA] = bd;
+    cfi.flcReq[FLC_RADIOCFG] = rc;
+    cfi.top = FALSE;
+    /* try x16 */
+    if (cfi.ok == FALSE) {
+        cfi.ok = sysFlashConfigInit_x16((FlashWPTR)ptr);
+        if (cfi.ok == FALSE) {
+            printk("\r\nCould not find flash device!\r\n");
+            return;
+        }
+        cfi.x16 = TRUE;
+    }
+
+    /* Calculate cap at end of the device */
+    cfi.cap = cfi.size;
+    if (cfi.top == TRUE) {
+        cfi.cap -= cfi.ebNum[cfi.eBlocks-1] * cfi.ebSize[cfi.eBlocks-1];
+    } else {
+        for (i=0; i < NFLC; i++) {
+            cfi.cap -= cfi.flcSize[i];
+        }
+    }
+}
+
+/*
+ * sysFlashConfigWriteX - write taking the device width into account.
+ */
+static FLStatus
+sysFlashConfigWriteX(FlashPTR flashPtr, int offset, UINT8 *p, int len)
+{
+    FLStatus rc = flOK;
+    int i;
+
+    for (i=0; i < len; i += cfi.wb) {
+        rc = cfi.write(flashPtr, offset+i, p+i, min((int)cfi.wb, len-i));
+        if (rc != flOK) {
+            break;
+        }
+    }
+    return rc;
+}
+
+static UINT8
+sysFlashConfigReadLocked(int flcn, int offset)
+{
+    volatile UINT8 *flashPtr = (volatile UINT8 *)cfi.flcPtr[flcn];
+
+    return (cfi.ok == TRUE) ? flashPtr[offset] : 'x';
+}
+
+UINT8
+sysFlashConfigRead(int flcn, int offset)
+{
+    UINT8 val;
+    int s;
+
+    s = cfiLock(FL_LOCK_BOOT);
+    val = sysFlashConfigReadLocked(flcn, offset);
+    cfiUnlock(FL_LOCK_BOOT, s);
+
+    return val;
+}
+
+static void
+sysFlashConfigEraseLocked(int flcn)
+{
+    FLStatus rc;
+
+    if (cfi.ok == TRUE) {
+        rc = cfi.erase(cfi.flcPtr[flcn]);
+    }
+
+    return;
+}
+
+void
+sysFlashConfigErase(int flcn)
+{
+    int s;
+
+    s = cfiLock(FL_LOCK_BOOT | FL_LOCK_WRITE);
+    sysFlashConfigEraseLocked(flcn);
+    cfiUnlock(FL_LOCK_BOOT | FL_LOCK_WRITE, s);
+
+    return;
+}
+
+unsigned int 
+sysFlashConfigWrite(int flcn, int offset, UINT8 *data, int len)
+{
+    int i, malloced = TRUE;
+    FLStatus rc;
+    UINT8 *p;
+    UINT8 b;
+    int s;
+
+    if (cfi.ok == FALSE) {
+		return (0);
+    }
+
+    //printk("sysFlashConfigWrite: flc=%d:offset=%d:len=%d\n", flcn, offset, len);
+    s = cfiLock(FL_LOCK_BOOT | FL_LOCK_WRITE);
+
+    for (i=0; i < len; i++) {
+        b = sysFlashConfigReadLocked(flcn, offset+i);
+        /* If any 0 bits need to be 1, then we need to erase */
+        if ((~b & data[i]) != 0) {
+            /* erase needed, save, merge, rewrite */
+//            p = kmalloc(cfi.flcReq[flcn], GFP_KERNEL);
+            /* all data are in one sector */
+            p = kmalloc(cfi.flcReq[FLC_BOOTLINE] + 
+                        cfi.flcReq[FLC_BOARDDATA] + 
+                        cfi.flcReq[FLC_RADIOCFG], GFP_KERNEL);
+            if (p == NULL) {
+                /* kmalloc can fail during early init */
+                malloced = FALSE;
+		printk("memory allocation fail\n");
+		return (-ENXIO);
+            }
+            for (i=0; i < cfi.flcReq[FLC_BOOTLINE]; i++) {
+                p[i]  = sysFlashConfigReadLocked(FLC_BOOTLINE, i);
+            }
+            for (i=0; i < cfi.flcReq[FLC_BOARDDATA]; i++) {
+                p[cfi.flcReq[FLC_BOOTLINE] + i]  = 
+                       sysFlashConfigReadLocked(FLC_BOARDDATA, i);
+            }
+            for (i=0; i < cfi.flcReq[FLC_RADIOCFG]; i++) {
+                p[cfi.flcReq[FLC_BOOTLINE] + cfi.flcReq[FLC_BOARDDATA] + i]  = 
+                       sysFlashConfigReadLocked(FLC_RADIOCFG, i);
+            }
+            for (i=0; i < len; i++) {
+                if(flcn == FLC_BOOTLINE) p[offset + i] = data[i];
+                if(flcn == FLC_BOARDDATA) 
+                    p[cfi.flcReq[FLC_BOOTLINE] + offset + i] = data[i];
+                if(flcn == FLC_RADIOCFG) 
+                    p[cfi.flcReq[FLC_BOOTLINE] + cfi.flcReq[FLC_BOARDDATA] + offset+i] = data[i];
+            }
+            sysFlashConfigEraseLocked(flcn);
+            rc = sysFlashConfigWriteX((FlashPTR)cfi.flcPtr[0], 0, p, 
+                  (cfi.flcReq[FLC_BOOTLINE] + 
+                  cfi.flcReq[FLC_BOARDDATA] + cfi.flcReq[FLC_RADIOCFG]));
+            cfiUnlock(FL_LOCK_BOOT | FL_LOCK_WRITE, s);
+            if (rc != flOK) {
+                printk("sysFlashConfigWrite: failed rc=%d\n", rc);
+		return (-EINVAL);
+            }
+            if (malloced) {
+                kfree(p);
+            }
+            return 1;
+        }
+    }
+    rc = sysFlashConfigWriteX(cfi.flcPtr[flcn], offset, data, len);
+    cfiUnlock(FL_LOCK_BOOT | FL_LOCK_WRITE, s);
+
+    if (rc != flOK) {
+        printk("sysFlashConfigWrite: failed rc=%d\n", rc);
+	return (-EINVAL);
+    }
+    return 1;
+}
+
+int flash_init(void) {
+
+
+    	sysFlashConfigInit((void *)(0x50000000),
+                       0,
+                       DK_BOARDCONFIG_SIZE,
+                       DK_RADIOCONFIG_SIZE);
+
+	 return 0;
+}
+
+void flash_exit(void) {
+     iounmap((void *)cfi.flcPtr[FLC_BOOTLINE]);
+     iounmap((void *)cfi.base);
+}
+
+unsigned int dk_flash_read (int flc, unsigned int offset, size_t len, UINT8 * buf) {
+   UINT16 iIndex;
+	
+   //Dprintk("buf=%x\n", buf);
+   for(iIndex=0; iIndex<len; iIndex++) 
+       buf[iIndex] = sysFlashConfigRead(flc, offset+iIndex);
+
+   return (1);
+
+}
+
+unsigned int dk_flash_write (int flc, unsigned int offset, size_t len, UINT8 * buf) {
+  return sysFlashConfigWrite(flc, offset, buf, len);
+}
+
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/dk_func.c apps_1.2/art/modules/dk_func.c
--- apps/art/modules/dk_func.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/dk_func.c	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,438 @@
+/* func.c contains the device functions */
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+
+#include "dk.h"
+#include "dk_ioctl.h"
+#include "client.h"
+
+
+
+static int dk_open
+(	
+ 	struct inode *inode, 
+	struct file *file
+)
+{
+		int minor;
+		int major;
+		int error;
+#ifdef DK_DEBUG
+		printk("DK:: dk_open \n");
+#endif
+		major = MAJOR(inode->i_rdev);
+		minor = MINOR(inode->i_rdev);
+		minor = minor & 0x0f;
+		
+#ifdef DK_DEBUG
+		printk("DK:: dk_open:minor=%d\n", minor);
+#endif
+		/* 
+		 * register client returns the cli id 
+		 * or error value
+		 */ 
+		error = register_client(major, minor);
+		if (error < 0) {
+				return error;
+		}
+		/*
+		 * Store the client id in the private data field
+		 */
+	
+
+		file->private_data = (void *)((unsigned long)error);
+
+		return 0;
+}
+static int dk_release
+(	
+ 	struct inode *inode, 
+	struct file *file
+)
+{
+		int cli_id;
+#ifdef DK_DEBUG
+		printk("DK:: dk_release \n");
+#endif
+
+		cli_id = (int) ((unsigned long)file->private_data);
+
+		unregister_client(cli_id);
+		return 0;
+}
+
+/*
+ * Architectures vary in how they handle caching for addresses
+ * outside of main memory.
+ *
+ */
+static inline int uncached_access(struct file *file, unsigned long addr)
+{
+         /*
+          * Accessing memory above the top the kernel knows about or through a file pointer
+          * that was marked O_SYNC will be done non-cached.
+          */
+         if (file->f_flags & O_SYNC)
+                 return 1;
+         return addr >= __pa(high_memory);
+}
+static int dk_mmap
+(
+ 	struct file *file,
+	struct vm_area_struct *vma
+)
+{
+
+#if defined(__HAVE_PHYS_MEM_ACCESS_PROT)
+        unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+        vma->vm_page_prot = phys_mem_access_prot(file, offset,
+                                                 vma->vm_end - vma->vm_start,
+                                                 vma->vm_page_prot);
+#elif defined(pgprot_noncached)
+        unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+        int uncached;
+        uncached = uncached_access(file, offset);
+        if (uncached)
+                vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+#endif
+
+
+
+        /* Remap-pfn-range will mark the range VM_IO and VM_RESERVED */
+        if (remap_pfn_range(vma,
+                            vma->vm_start,
+                            vma->vm_pgoff,
+                            vma->vm_end-vma->vm_start,
+                            vma->vm_page_prot))
+                return -EAGAIN;
+		return 0; 
+
+}
+
+
+
+static int dk_ioctl
+(
+ 	struct inode *inode, 
+	struct file *file,
+	unsigned int cmd,
+	unsigned long arg
+)
+{
+		INT32 ret=-1;
+		INT32 data;
+		struct cfg_op co;
+		INT32 cli_id;
+		INT32 i;
+		struct client_info ci;
+		struct event_op eo;
+		event_handle evt_hnd;
+		p_event_struct p_event;
+		p_atheros_dev p_client;
+		
+#ifdef DK_DEBUG
+		printk("DK::dk_ioctl \n");
+#endif
+
+		cli_id = (int) ((unsigned long)file->private_data);
+
+		p_client = get_client(cli_id);
+		if (p_client == NULL) {
+				printk("DK:: Invalid client \n");
+				return -1;
+		}
+		switch (cmd) {
+			case DK_IOCTL_GET_VERSION:
+#ifdef DK_DEBUG
+				printk("DK:: DK_IOCTL_GET_VERISION \n");
+#endif
+				data = (DRV_MAJOR_VERSION << 16) | (DRV_MINOR_VERSION);
+				ret = put_user(data, (INT32 *)arg);
+				break;
+			case DK_IOCTL_GET_CLIENT_INFO:
+#ifdef DK_DEBUG
+				printk("DK:: DK_IOCTL_GET_CLIENT_INFO \n");
+#endif
+				if (get_cli_info(cli_id,&ci) < 0) {
+					printk("DK:: get_cli_info failed, cli_id : %d \n", cli_id);
+					ret = -1;
+				} else {
+					ret = copy_to_user((void *)arg,(void *)&ci,sizeof(ci));
+				}
+				ret = 0;
+				break;
+			case DK_IOCTL_CFG_READ:
+#if !defined(P1020)
+				if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+						return -EFAULT;
+				}
+#ifdef DK_DEBUG
+				printk("DK::Cfg read @ offset %x \n",co.offset);
+#endif
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#ifdef WASP_OSPREY
+   if(cli_id!=0){ // For DBDC operation, Wasp radio's client ID is zero; 
+#endif
+				if (cli_cfg_read(cli_id,co.offset,co.size,&co.value) < 0) {
+					ret = -1;
+				} else {
+					ret = copy_to_user((void *)arg,(void *)&co,sizeof(co));
+				}
+#ifdef WASP_OSPREY
+  }
+#endif
+#endif
+#else
+                ret = -1;
+#endif
+				break;
+                        case DK_IOCTL_RTC_REG_READ:
+                                if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+                                                return -EFAULT;
+                                }
+#ifdef DK_DEBUG
+                                printk("DK::Rtc reg read @ offset %x \n",co.offset);
+#endif
+#ifndef OCTEON
+                                if (rtc_reg_read(cli_id,co.offset,&co.value) < 0) {
+                                        ret = -1;
+                                } else {
+                                        ret = copy_to_user((void *)arg,(void *)&co,sizeof(co));
+                                }
+#endif
+                                break;
+			case DK_IOCTL_GET_CHIP_ID:
+				if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+						return -EFAULT;
+				}
+#ifdef DK_DEBUG
+				printk("DK::Reading Chio ID @ offset %x \n",co.offset);
+#endif
+#ifndef OCTEON
+				if (get_chip_id(cli_id,co.offset,co.size,&co.value) < 0) {
+					ret = -1;
+				} else {
+					ret = copy_to_user((void *)arg,(void *)&co,sizeof(co));
+				}
+				break;
+#endif
+			case DK_IOCTL_CFG_WRITE:
+				if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+						return -EFAULT;
+				}
+#ifdef DK_DEBUG
+				printk("DK::Cfg write @ offset %x : %x \n",co.offset,co.value);
+#endif
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#ifdef WASP_OSPREY
+   if(cli_id!=0){ // For DBDC operation, Wasp radio's client ID is zero; 
+#endif
+				if (cli_cfg_write(cli_id,co.offset,co.size,co.value) < 0) {
+					ret = -1;
+				} else {
+					ret = 0;
+				}
+#ifdef WASP_OSPREY
+  }
+#endif
+#endif
+				break;
+                        case DK_IOCTL_SYS_REG_WRITE_32:
+						case DK_IOCTL_FULL_ADDR_WRITE:
+                                if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+                                                return -EFAULT;
+                                }
+#ifdef DK_DEBUG
+                                printk("DK::full addr write @ address %x : %x \n",co.offset,co.value);
+#endif
+#ifdef AP83
+                                if (full_addr_write(cli_id,co.offset,co.value) < 0) {
+                                        ret = -1;
+                                } else {
+                                        ret = 0;
+                                }
+#endif
+                                break;
+						case DK_IOCTL_SYS_REG_READ_32:
+                        case DK_IOCTL_FULL_ADDR_READ:
+                                if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+                                                return -EFAULT;
+                                }
+#ifdef DK_DEBUG
+                                printk("DK::Full add read @ address %x \n",co.offset);
+#endif
+#ifdef AP83
+                                if (full_addr_read(cli_id,co.offset,&co.value) < 0) {
+                                        ret = -1;
+                                } else {
+                                        ret = copy_to_user((void *)arg,(void *)&co,sizeof(co));
+                                }
+#endif
+                                break;
+                        case DK_IOCTL_RTC_REG_WRITE:
+                                if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+                                                return -EFAULT;
+                                }
+#ifdef DK_DEBUG
+                                printk("DK::rtc write @ offset %x : %x \n",co.offset,co.value);
+#endif
+#ifdef AP83
+#ifndef WASP
+                                if (rtc_reg_write(cli_id,co.offset,co.value) < 0) {
+                                        ret = -1;
+                                } else {
+                                        ret = 0;
+                                }
+#endif
+#endif
+                                break;
+			case DK_IOCTL_CREATE_EVENT:
+#ifdef DK_DEBUG
+				printk("DK::Create event \n");
+#endif
+				if (copy_from_user((void *)&eo,(void *)arg,sizeof(eo))) {
+						return -EFAULT;
+				}
+				ret = -1;
+				if (eo.valid) {
+			 		evt_hnd.eventID = eo.param[5] & 0xffff;
+					evt_hnd.f2Handle = (eo.param[5] >> 16) & 0xffff;
+					p_event = createEvent (eo.param[0], // type
+					                       eo.param[1], // persistent
+					                       eo.param[2], // param1
+					                       eo.param[3], // param2
+					                       eo.param[4], // param3
+					                       evt_hnd);
+					if (p_event != NULL) {
+						// need to look at the event type to see which queue
+						switch (p_event->type ) {
+							case ISR_INTERRUPT:
+								//if param1 is zero, we, by default
+								// set the "ISR IMR" to pass everything
+								if ( 0 == p_event->param1 ) {
+									p_event->param1 = 0xffffffff;
+								}
+								if (pushEvent(p_event, &p_client->isr_event_q,
+								               TRUE) ) {
+										ret = 0;
+								} else {
+									printk("DK::Push Event Failed \n");
+									kfree(p_event);
+								} 
+								break;
+							default:
+								printk("DK::Event Type %d not supported \n",p_event->type);
+								kfree(p_event);
+								break;
+						}
+					} 
+				}
+				break;
+			case DK_IOCTL_GET_NEXT_EVENT:
+#ifdef DK_DEBUG
+				printk("DK::Get next event \n");
+#endif
+				ret = 0;
+				eo.valid = 0;
+				if (p_client->trigered_event_q.queueSize) {
+					if (checkForEvents(&p_client->trigered_event_q,TRUE)){ 
+						p_event = popEvent(&p_client->trigered_event_q,TRUE);
+						eo.valid = 1;
+						eo.param[0] = p_event->type;
+						eo.param[1] = p_event->persistent;
+						eo.param[2] = p_event->param1; 
+						eo.param[3] = p_event->param2;
+						eo.param[4] = p_event->param3;
+						eo.param[5] = (p_event->eventHandle.f2Handle << 16) | 
+						               p_event->eventHandle.eventID; 
+						for (i=0;i<6;i++) { 
+							eo.param[6+i] = p_event->result[i]; 
+						} 
+					#ifdef DK_DEBUG 
+						printk("DK:: Pop event %x \n",(UINT32)p_event);
+					#endif 
+						kfree(p_event);
+					} 
+				}
+				ret = copy_to_user((void *)arg,(void *)&eo,sizeof(eo));
+				break;
+            case DK_IOCTL_FLASH_READ:
+                printk("DK:: Flash read is not supported any more from art driver\n");
+                break;
+            case DK_IOCTL_FLASH_WRITE:
+                printk("DK:: Flash read is not supported any more from art driver\n");
+                break; 
+/*
+#ifdef OWL_PB42
+            case DK_IOCTL_MAC_WRITE:
+#ifdef DK_DEBUG
+                 printk("DK::Get DK_IOCTL_MAC_WRITE\n ");
+#endif
+                 if (copy_from_user((void *)&flashMac,(void *)arg,sizeof(flashMac))) {
+                      printk("DK:: Copy_from_user failed 1\n");
+                      return -EFAULT;
+                 }
+                 if (copy_from_user((void *)mac0Addr,(void *)flashMac.pAddr0, 6)){
+                     printk("DK:: Copy_from_user failedi 2\n");
+                     return -EFAULT;
+                 }
+                 if (copy_from_user((void *)mac1Addr,(void *)flashMac.pAddr1, 6)){
+                     printk("DK:: Copy_from_user failed 3\n");
+                     return -EFAULT;
+                 }
+#ifdef DK_DEBUG
+                 printk("DK:: MAC Addr\n");
+				 for(i=0; i<6; i++)
+					printk("%x  ", mac0Addr[i]);
+				 printk("\n");
+				 for(i=0; i<6; i++)
+					printk("%x  ", mac1Addr[i]);
+				 printk("\n");
+#endif
+				memcpy(&hw_mac_cfg, 0xbf7f0000, 16);
+				ar7100_spi_sector_erase(0x7f0000);
+				// Copy mac address to ath_hw_cfg structure
+				for(i=0; i<6; i++)
+			        hw_mac_cfg.macAddr0[i] = mac0Addr[i];
+				for(i=0; i<6; i++)
+			        hw_mac_cfg.macAddr1[i] = mac1Addr[i];
+				ar7100_spi_write_page(0x7f0000, &hw_mac_cfg, 256);				
+				ret = 1;
+                break; 
+#endif
+*/
+			default:
+				printk("DK::Unreconginzed ioctl command %d \n",cmd);
+				break;
+		}
+		return ret;
+}
+
+static struct file_operations dk_fops = {
+	owner:	THIS_MODULE,
+	open:	dk_open,
+	release: dk_release,
+	mmap:	dk_mmap,
+
+	ioctl  : dk_ioctl
+
+};
+INT32  dk_dev_init(void) {
+		int status;
+		status = register_chrdev(DK_MAJOR_NUMBER,"dk",&dk_fops);
+		printk("dk_dev_init::status after register_chrdev(dk) = %d\n", status);
+#ifdef DK_UART
+	        status |= register_chrdev(DK_UART_MAJOR_NUMBER, "dk_uart", &dk_fops);
+		printk("dk_dev_init::status after register_chrdev(dk_uart) = %d\n", status);
+#endif
+		return status;
+}
+void dk_dev_exit(void) {
+		unregister_chrdev(DK_MAJOR_NUMBER,"dk");
+//#ifdef DK_UART
+		unregister_chrdev(DK_UART_MAJOR_NUMBER,"dk_uart");
+//#endif
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/dk_isr.c apps_1.2/art/modules/dk_isr.c
--- apps/art/modules/dk_isr.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/dk_isr.c	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,232 @@
+/* dk_irq.c - this file contains the interrupt handler for the dk driver */
+
+#include <asm/ptrace.h>
+#include <linux/kernel.h>
+
+#include "dk.h"
+#include "client.h"
+#include "dk_event.h"
+
+BOOLEAN dk_intr_handler
+(
+ 	INT32 irq,
+	VOID *param,
+	struct pt_regs *regs
+)
+{
+	p_event_struct p_event;
+	p_event_struct p_event_copy;
+	p_event_struct p_event_to_push;
+	p_event_queue p_isr_event_q;
+	p_event_queue p_trigered_event_q;
+	UINT32 priIsr;
+	UINT32 secIsr[5];
+	UINT32 i;
+	BOOLEAN bValidEvent;
+	p_atheros_dev p_client;
+	UINT32 cli_id;
+#ifndef AP83
+	INT32 reg_val;
+        UINT32 macRev;
+#endif
+
+	p_client = (p_atheros_dev)param;
+	cli_id = p_client->cli_id;
+#ifdef AP83
+       cli_reg_write(cli_id,0x0024,0x0); // disabling INT register..
+                /* Read the isr */
+                cli_reg_read(cli_id,0x00c0,&priIsr);
+               if(!priIsr) {
+                        //this might be first gen
+                        cli_reg_read(cli_id, 0x1c,&priIsr);
+                }
+
+#ifdef DK_DEBUG
+           printk("DK::Got interrupt:ISR = %x \n",priIsr);
+#endif
+
+                cli_reg_read(cli_id,0x00c4,&secIsr[0]);
+                cli_reg_read(cli_id,0x00c8,&secIsr[1]);
+                cli_reg_read(cli_id,0x00cc,&secIsr[2]);
+                cli_reg_read(cli_id,0x00d0,&secIsr[3]);
+                cli_reg_read(cli_id,0x00d4,&secIsr[4]);
+
+//        }
+
+
+        // catch spurios interrupts that comes before the client is registered
+        if (!BUSY_CLIENT(p_client)) return FALSE;
+
+        // start to scan the current queue of events
+        p_isr_event_q = &(p_client->isr_event_q);
+        p_trigered_event_q = &(p_client->trigered_event_q);
+        p_event = p_isr_event_q->pHead;
+
+        while ( p_event ) {
+
+                bValidEvent = FALSE;
+                switch ( p_event->type ) {
+                        case ISR_INTERRUPT: {
+                            if (priIsr & p_event->param1 ) {
+                                        // return the complete ISR value
+                                        // not anded with the mask
+                                        p_event->result[0] = priIsr;
+                                        for (i=0;i<5;i++) {
+                                                p_event->result[1+i] = secIsr[i];
+                                        }
+                                bValidEvent    = TRUE;
+                             }
+                             break;
+                        }
+                        default:
+                                printk("DK::Ilegal event type found in ISR event queue!\n");
+                                break;
+                } // switch
+
+                if ( !bValidEvent ) {
+                        p_event = p_event->pNext;
+                        continue;
+                }
+
+                // put the event in the event triggered Q,
+                // either move or copy event, depending
+                // on the persistent flag
+                if ( p_event->persistent ) {
+                        p_event_copy = copyEvent(p_event);
+                        if( !p_event_copy ) {
+                                printk("DK::Unable to copy event in interrupt\n");
+                                break;
+                        }
+                        p_event_to_push = p_event_copy;
+                } else {
+                        if (!removeEvent(p_event, p_isr_event_q, FALSE) ) {
+                                printk("DK::Unable to remove event from ISR queue \n");
+                                break;
+                        }
+                        p_event_to_push = p_event;
+                }
+
+                // push the event onto the triggered queue
+                if (!pushEvent(p_event_to_push, p_trigered_event_q,FALSE) ) {
+                        printk("DK::Unable to push event onto triggered queue\n");
+                        break;
+                }
+
+                // increment to next event
+                p_event = p_event->pNext;
+        } // while ( p_event )
+
+        return TRUE;
+
+#else  // end AP83
+
+        if (p_client->device_class == SIMPLE_COMM_CLASS) {
+	    cli_reg_read(cli_id, 0x8, &priIsr);
+#ifdef DK_DEBUG
+	    printk("DK::Got interrupt from simple comm class \n");
+#endif
+	}
+	
+	if (p_client->device_class == NETWORK_CLASS) {
+	   /* Read the interrupt pending register */
+	   
+                cli_reg_read(cli_id, 0x4020, &macRev); 
+	        printk("macRev is 0x%x  \n", macRev);
+                if (((macRev >= 0xc0) && (macRev <= 0xdf)) || ((macRev & 0xff) == 0xff)) {
+                    UINT32 h_intr_enable;
+                    UINT32 h_intr_cause;
+
+                    cli_reg_read(cli_id, 0x403c,&h_intr_enable); // async intr enable
+                    cli_reg_read(cli_id, 0x4038,&h_intr_cause); // async intr cause
+                    if (!(h_intr_enable & h_intr_cause))  return FALSE;
+                }
+                else  {
+                    cli_reg_read(cli_id,0x4008,&reg_val);
+     	            if ((reg_val & 0x00000001) == 0x0) return FALSE;
+                }
+ 	
+	        /* Read the isr */
+	        cli_reg_read(cli_id,0x00c0,&priIsr);
+               if(!priIsr) {
+                        //this might be first gen
+                        cli_reg_read(cli_id, 0x1c,&priIsr);
+                }
+
+#ifdef DK_DEBUG
+	   printk("DK::Got interrupt:ISR = %x \n",priIsr);
+#endif
+
+	        cli_reg_read(cli_id,0x00c4,&secIsr[0]);
+	        cli_reg_read(cli_id,0x00c8,&secIsr[1]);
+	        cli_reg_read(cli_id,0x00cc,&secIsr[2]);
+	        cli_reg_read(cli_id,0x00d0,&secIsr[3]);
+	        cli_reg_read(cli_id,0x00d4,&secIsr[4]);
+	
+	}
+    
+	// catch spurios interrupts that comes before the client is registered
+	if (!BUSY_CLIENT(p_client)) return FALSE; 
+	
+	// start to scan the current queue of events
+	p_isr_event_q = &(p_client->isr_event_q);
+	p_trigered_event_q = &(p_client->trigered_event_q);
+	p_event = p_isr_event_q->pHead;
+
+	while ( p_event ) {
+
+		bValidEvent = FALSE;
+		switch ( p_event->type ) {
+			case ISR_INTERRUPT: {
+
+	                    if (priIsr & p_event->param1 ) {
+					// return the complete ISR value
+					// not anded with the mask
+					p_event->result[0] = priIsr;
+					for (i=0;i<5;i++) {
+						p_event->result[1+i] = secIsr[i];
+					}
+				bValidEvent    = TRUE;
+			     }
+	                     break;
+                        }
+			default:
+				printk("DK::Ilegal event type found in ISR event queue!\n"); 
+				break;
+		} // switch
+
+		if ( !bValidEvent ) {
+			p_event = p_event->pNext;
+			continue;
+		}
+
+		// put the event in the event triggered Q,
+		// either move or copy event, depending
+		// on the persistent flag
+		if ( p_event->persistent ) {
+			p_event_copy = copyEvent(p_event);
+			if( !p_event_copy ) {
+				printk("DK::Unable to copy event in interrupt\n");
+				break;
+			}
+			p_event_to_push = p_event_copy;
+		} else {
+			if (!removeEvent(p_event, p_isr_event_q, FALSE) ) {
+				printk("DK::Unable to remove event from ISR queue \n");
+				break;
+			}
+			p_event_to_push = p_event;
+		}
+
+		// push the event onto the triggered queue
+		if (!pushEvent(p_event_to_push, p_trigered_event_q,FALSE) ) {
+			printk("DK::Unable to push event onto triggered queue\n");
+			break;
+		}
+
+		// increment to next event
+		p_event = p_event->pNext;
+	} // while ( p_event )
+		
+	return TRUE;
+#endif
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/dk_pci_bus.c apps_1.2/art/modules/dk_pci_bus.c
--- apps/art/modules/dk_pci_bus.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/dk_pci_bus.c	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,461 @@
+/* dk_pci_bus.c - contains functions specific to pci bus */
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include "dk.h"
+#include "client.h"
+#define ATHEROS_VENDOR_ID 0x168c
+#define MAX_CFG_OFFSET	256
+#define PCIE_1_LINK_ADDRESS 0xb80f0018
+#define PCIE_2_LINK_ADDRESS 0xb8280018
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static INT32 dk_pci_enable_wake
+(
+ 	struct pci_dev *dev,
+	UINT32 state,
+	INT32 enable
+)
+{
+#ifdef DK_DEBUG
+		printk("DK::Pci enable wake \n");
+#endif
+		return 0;
+}
+#endif
+
+static INT32 dk_pci_probe
+(
+ 	struct pci_dev *dev,
+	const struct pci_device_id *id
+)
+{
+	INT32 error;
+
+	A_UINT_PTR baseaddr[MAX_BARS];
+
+	UINT32 len[MAX_BARS];
+	UINT32 irq;
+#if  defined(PYTHON_EMU)
+        UINT32 *addr;
+	INT32 pci_ret_val;
+#endif
+#ifndef PYTHON_EMU
+	UINT8  csz;
+	UINT32 val;
+#endif
+	UINT32 iIndex, numBars;
+#ifdef DK_DEBUG
+    UINT32 device_id, vendor_id;
+#endif
+	INT8 ret_val;
+	UINT32 sIndex = WMAC_FN_DEV_START_NUM;
+
+#ifdef DK_DEBUG
+	printk("DK::Pci probe \n");
+#endif
+
+	error = pci_enable_device(dev);
+	if (error != 0) {
+			printk(KERN_ERR "DK:: pci_enable_device failed \n");
+			return error;
+	}
+#ifndef PYTHON_EMU
+        pci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &csz);
+        if (csz == 0) {
+                /*
+                 * Linux 2.4.18 (at least) writes the cache line size
+                 * register as a 16-bit wide register which is wrong.
+                 * We must have this setup properly for rx buffer
+                 * DMA to work so force a reasonable value here if it
+                 * comes up zero.
+                 */
+                csz = L1_CACHE_BYTES / sizeof(UINT32);
+                pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, csz);
+        }
+        /*
+         * The default setting of latency timer yields poor results,
+         * set it to the value used by other systems.  It may be worth
+         * tweaking this setting more.
+         */
+        pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0xa8);
+
+        pci_set_master(dev);
+
+        /*
+         * Disable the RETRY_TIMEOUT register (0x41) to keep
+         * PCI Tx retries from interfering with C3 CPU state.
+         *
+         * Code taken from ipw2100 driver - jg
+         */
+        pci_read_config_dword(dev, 0x40, &val);
+        if ((val & 0x0000ff00) != 0)
+                pci_write_config_dword(dev, 0x40, val & 0xffff00ff);
+
+#endif
+
+#ifdef PYTHON_EMU
+
+#define CHIP_ID_LOCATION 0xb8060090
+#ifndef OCTEON
+        INT32 chip_rev_id=0;
+#endif
+
+
+#ifndef OWL_PB42
+        get_chip_id(0,CHIP_ID_LOCATION,4,&chip_rev_id);
+#endif
+#define CHIP_REV_ID_SCORPION_A 0x013 // last nibble is for Chip revision which is ignored
+#define CHIP_REV_ID_SCORPION_B 0x113 // last nibble is for Chip revision which is ignored
+#define CHIP_REV_ID_DRANGONFLY 0x15
+	// Scorpion packages A and B (PCIE_2_LINK_ADDRESS is only valid for Scorpion)
+	// Dragonfly has one pcie at PCIE_2_LINK_ADDRESS.
+	if ((((chip_rev_id& 0xfff0)>>4) == CHIP_REV_ID_SCORPION_A)||
+	  (((chip_rev_id& 0xfff0)>>4) == CHIP_REV_ID_SCORPION_B)||
+	  (((chip_rev_id& 0x0ff0)>>4) == CHIP_REV_ID_DRANGONFLY)){
+		addr = (UINT32 *)(PCIE_2_LINK_ADDRESS);
+		pci_ret_val = readl(addr);
+		if(pci_ret_val==7){
+			pci_write_config_dword(dev,0x10,0x1201ffff);
+		}	  
+	}
+	if (((chip_rev_id& 0x0ff0)>>4) != CHIP_REV_ID_DRANGONFLY) {
+		addr = (UINT32 *)(PCIE_1_LINK_ADDRESS);
+		pci_ret_val = readl(addr);
+		if(pci_ret_val==7){
+			pci_write_config_dword(dev,0x10,0xffff);
+		}
+	}
+#endif
+
+    for (iIndex=0; iIndex<MAX_BARS; iIndex++) {
+	  baseaddr[iIndex] = pci_resource_start(dev,iIndex);
+
+	printk(KERN_ERR" Base Phsycal address :0x%08lx\n", baseaddr[iIndex]);
+
+	  len[iIndex] = pci_resource_len(dev,iIndex);
+      if (len[iIndex] == 0) break;
+    }
+    numBars = iIndex;
+#ifdef DK_DEBUG
+	printk("DK::num bars = %d\n", numBars);
+	(void) pci_read_config_dword(dev, PCI_DEVICE_ID, &device_id);
+	(void) pci_read_config_dword(dev, PCI_VENDOR_ID, &vendor_id);
+    printk("DK::Vendor Id=%x:Device id = %x\n", vendor_id, device_id);
+#endif
+	irq = dev->irq;
+
+#ifndef PYTHON_EMU
+    for (iIndex=0; iIndex<numBars; iIndex++) {
+
+	   pci_write_config_byte(dev,PCI_INTERRUPT_LINE, irq);
+    }
+#endif
+	(void) pci_read_config_byte(dev, 0xb, &ret_val); // Get the class code
+	if (ret_val == NETWORK_CLASS) {
+		sIndex = WMAC_FN_DEV_START_NUM;
+	}
+	if (ret_val == SIMPLE_COMM_CLASS) {
+		sIndex = UART_FN_DEV_START_NUM;
+	}
+	printk("Class code = %d:start search index=%d\n", ret_val, sIndex);
+
+	if (add_client(dev,baseaddr,len,irq, numBars, sIndex,1) < 0) {
+		printk(KERN_ERR "DK:: unable to add client \n");
+#if LINUX_VERSION_CODE > 132098
+		pci_disable_device(dev);
+#endif
+		return -ENODEV;
+	}
+
+#if 0
+	virmem = (UINT32)ioremap(pci_resource_start(dev, 0), pci_resource_len(dev,0));
+
+        printk(KERN_ERR"IOREMAP Addr: 0x%x\n", virmem);
+
+	writel(0x1, (UINT32*)((UINT8*)virmem+0x704c));
+	writel(0x0, (UINT32*)((UINT8*)virmem+0x7040));
+	writel(0x5, (UINT32*)((UINT8*)virmem+0x7040));
+	printk(KERN_ERR" Address: 0x%x, Status****: 0x%x\n", (UINT32)((UINT8*)virmem+0x7044), readl((UINT32*)((UINT8*)virmem+0x7044)));
+#endif
+	return 0;
+}
+
+static VOID dk_pci_remove
+(
+	struct pci_dev *dev
+)
+{
+#ifdef DK_DEBUG
+	printk("DK::Pci remove \n");
+#endif
+	remove_client(dev);
+#if LINUX_VERSION_CODE > 132098
+	pci_disable_device(dev);
+#endif
+
+	return;
+}
+
+#if LINUX_VERSION_CODE >= 132623
+static INT32 dk_pci_suspend
+(
+ 	struct pci_dev *dev,
+	pm_message_t state
+)
+#elif (LINUX_VERSION_CODE > 132098) && (LINUX_VERSION_CODE < 132623)
+static INT32 dk_pci_suspend
+(
+ 	struct pci_dev *dev,
+	UINT32 state
+)
+#else
+static VOID dk_pci_suspend
+(
+ 	struct pci_dev *dev
+)
+#endif
+{
+#ifdef DK_DEBUG
+		printk("DK::Pci suspend \n");
+#endif
+#if LINUX_VERSION_CODE > 132098
+		return 0;
+#else
+		return;
+#endif
+}
+
+#if LINUX_VERSION_CODE > 132098
+static INT32 dk_pci_resume
+(
+	struct pci_dev *dev
+)
+#else
+static VOID dk_pci_resume
+(
+	struct pci_dev *dev
+)
+#endif
+{
+#ifdef DK_DEBUG
+		printk("DK::Pci resume \n");
+#endif
+#if LINUX_VERSION_CODE > 132098
+		return 0;
+#else
+		return;
+#endif
+}
+
+
+static struct pci_device_id __devinitdata dk_id_tbl[] = {
+
+	{ATHEROS_VENDOR_ID, 0x0011, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"MAUI"},
+	{ATHEROS_VENDOR_ID, 0x0012, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OAHU"},
+	{ATHEROS_VENDOR_ID, 0x0013, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"VENICE"},
+	{ATHEROS_VENDOR_ID, 0x0014, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"VENICE_DERBY"},
+	{ATHEROS_VENDOR_ID, 0xff16, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"GRIFFIN_MAC"},
+	{ATHEROS_VENDOR_ID, 0x0023, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OWL"},
+	{ATHEROS_VENDOR_ID, 0x0026, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"NALA"},
+	{ATHEROS_VENDOR_ID, 0x0027, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"SOWL"},
+	{ATHEROS_VENDOR_ID, 0xff1c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"SOWL"},
+	{ATHEROS_VENDOR_ID, 0x0028, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"SOWL_PCIE"},
+	{ATHEROS_VENDOR_ID, 0x0029, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"MERLIN"},
+	{ATHEROS_VENDOR_ID, 0x002a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"MERLIN_PCIE"},
+	{ATHEROS_VENDOR_ID, 0x002b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"KITE_PCIE"},
+	{ATHEROS_VENDOR_ID, 0xff1d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OWL"},
+	{ATHEROS_VENDOR_ID, 0x001d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"NALA"},
+	{ATHEROS_VENDOR_ID, 0xff1a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"NALA"},
+    {ATHEROS_VENDOR_ID, 0x002d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"KIWI"},
+    {ATHEROS_VENDOR_ID, 0x002e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"KIWI_PCIE"},
+    {ATHEROS_VENDOR_ID, 0x0030, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OSPREY"},
+    {ATHEROS_VENDOR_ID, 0x0033, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"PEACOCK"},
+    {ATHEROS_VENDOR_ID, 0xabcd, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OSPREY"},
+	{0,}
+};
+
+
+#ifdef DK_UART
+static struct pci_device_id __devinitdata dk_uart_id_tbl[] = {
+	{ATHEROS_VENDOR_ID, 0xff96, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"GRIFFIN_UART"},
+	{0,}
+};
+#endif
+
+static struct pci_driver dkpci_driver = {
+		name:	"dkkernel",
+		id_table: dk_id_tbl,
+		probe: dk_pci_probe,
+		remove: dk_pci_remove,
+		suspend: dk_pci_suspend,
+		resume: dk_pci_resume,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+		enable_wake: dk_pci_enable_wake
+#endif
+};
+
+#ifdef DK_UART
+
+static struct pci_driver dkuart_pci_driver = {
+		name:	"dkuartkernel",
+		id_table: dk_uart_id_tbl,
+		probe: dk_pci_probe,
+		remove: dk_pci_remove,
+		suspend: dk_pci_suspend,
+		resume: dk_pci_resume,
+};
+
+#endif
+INT32 bus_module_init
+(
+ 	VOID
+)
+{
+	int status;
+#ifdef DK_DEBUG
+	printk("DK::Bus module init  \n");
+#endif // DK_DEBUG
+#ifdef MODULE
+#ifdef DK_DEBUG
+	printk("DK::MODULE\n");
+#endif // DK_DEBUG
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	status = pci_module_init(&dkpci_driver);
+#else
+	status = pci_register_driver(&dkpci_driver);
+#endif
+	printk("DK::bus_module_init:status=%d from dkpci_driver\n", status);
+#ifdef DK_UART
+	status |= pci_module_init(&dkuart_pci_driver);
+	printk("DK::bus_module_init:status=%d from dkuart_pci_driver\n", status);
+#endif
+	return status;
+#else
+	return pci_register_driver(&dkpci_driver);
+#endif // MODULE
+}
+
+VOID bus_module_exit
+(
+ 	VOID
+)
+{
+#ifdef DK_DEBUG
+	printk("DK::Bus module exit  \n");
+#endif // DK_DEBUG
+	pci_unregister_driver(&dkpci_driver);
+#ifdef DK_UART
+	pci_unregister_driver(&dkuart_pci_driver);
+#endif
+}
+
+#ifdef MODULE
+MODULE_DEVICE_TABLE(pci,dk_id_tbl);
+#endif
+
+INT32 bus_dev_init
+(
+ 	void  *bus_dev
+)
+{
+	struct pci_dev *dev;
+	UINT32 baseaddr;
+	UINT32 irq;
+
+	dev = (struct pci_dev *)bus_dev;
+	pci_set_master(dev);
+
+	baseaddr = pci_resource_start(dev,0);
+	irq = dev->irq;
+
+	/*
+	 * Program the base address and irq as the device may
+	 * be hotplugged without aware of the kernel
+	 */
+#ifndef PYTHON_EMU
+	pci_write_config_dword(dev,PCI_BASE_ADDRESS_0, baseaddr);
+	pci_write_config_byte(dev,PCI_INTERRUPT_LINE, irq);
+
+#endif
+	return 0;
+}
+
+VOID bus_dev_exit
+(
+ 	void  *bus_dev
+)
+{
+	return;
+}
+
+INT32 bus_cfg_read
+(
+ 	void  *bus_dev,
+ 	INT32 offset,
+	INT32 size,
+	INT32 *ret_val
+)
+{
+	struct pci_dev *dev;
+	int ret =  -1;
+
+	dev = (struct pci_dev *)bus_dev;
+
+	if (size < MAX_CFG_OFFSET) {
+		switch (size) {
+			case 1:
+				ret = pci_read_config_byte(dev,offset, (INT8 *)ret_val);
+				break;
+			case 2:
+				offset = offset & 0xfe;
+				ret = pci_read_config_word(dev,offset, (INT16 *)ret_val);
+				break;
+			case 4:
+				offset = offset & 0xfc;
+				ret = pci_read_config_dword(dev,offset, ret_val);
+				break;
+			default:
+				break;
+		}
+	}
+
+	return ret;
+
+}
+
+INT32 bus_cfg_write
+(
+ 	void  *bus_dev,
+ 	INT32 offset,
+	INT32 size,
+	INT32 val
+)
+{
+	struct pci_dev *dev;
+	int ret =  -1;
+
+	dev = (struct pci_dev *)bus_dev;
+	if (size < MAX_CFG_OFFSET) {
+		switch (size) {
+			case 1:
+				ret = pci_write_config_byte(dev,offset, val);
+				break;
+			case 2:
+				offset = offset & 0xfe;
+				ret = pci_write_config_word(dev,offset, val);
+				break;
+			case 4:
+				offset = offset & 0xfc;
+				ret = pci_write_config_dword(dev,offset,val);
+				break;
+			default:
+				break;
+		}
+	}
+
+	return ret;
+}
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/client.h apps_1.2/art/modules/include/client.h
--- apps/art/modules/include/client.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/client.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,164 @@
+#ifndef __CLIENT_H_
+#define __CLIENT_H_
+
+#include "dk.h"
+#include "dk_ioctl.h"
+#include "dk_event.h"
+
+#define MAX_CLIENTS_SUPPORTED 8
+#define INVALID_CLIENT -1
+#define DK_MAJOR_NUMBER 63
+#define DK_UART_MAJOR_NUMBER 64
+#define WMAC_FN_DEV_START_NUM      0
+#define UART_FN_DEV_START_NUM      4
+#define NETWORK_CLASS   0x2
+#define SIMPLE_COMM_CLASS       0x7
+
+
+
+/* atheros devices info */
+struct atheros_dev_ {
+    void *bus_dev;
+	A_UINT_PTR reg_phy_addr;
+	A_UINT_PTR reg_ker_vir_addr;
+	UINT32 reg_range;
+	A_UINT_PTR mem_phy_addr;
+	A_UINT_PTR mem_ker_vir_addr;
+	UINT32 mem_size;
+	UINT32 irq;
+    UINT32 dev_busy;
+	UINT32 cli_id;		// cli_id is same as the array index in the dev_table
+	event_queue isr_event_q;
+	event_queue trigered_event_q;
+	A_UINT_PTR areg_phy_addr[MAX_BARS];
+    A_UINT_PTR areg_ker_vir_addr[MAX_BARS];
+	UINT32 areg_range[MAX_BARS];
+    UINT32 numBars;
+    UINT32 device_class;
+	UINT32 dma_mem_addr;
+};
+
+typedef struct atheros_dev_ atheros_dev;
+typedef struct atheros_dev_ *p_atheros_dev;
+
+VOID init_client
+(
+ 	VOID
+);
+
+INT32 add_client
+(
+ 	VOID *bus_dev,
+	A_UINT_PTR baseaddr[MAX_BARS],
+	UINT32 len[MAX_BARS],
+	UINT32 irq,
+    UINT32 numBars,
+    UINT32 sIndex,
+    int pci
+);
+
+VOID remove_client
+(
+ 	VOID *bus_dev
+);
+
+VOID cleanup_client
+(
+     VOID
+);
+
+INT32 register_client
+(
+     INT32 major,
+     INT32 minor
+);
+
+
+VOID unregister_client
+(
+     INT32 cli_id
+);
+
+INT32 cli_cfg_read
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	INT32 size,
+	INT32 *ret_val
+);
+
+
+INT32 cli_cfg_write
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	INT32 size,
+	INT32 ret_val
+);
+
+INT32 cli_reg_read
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	UINT32 *ret_val
+);
+
+
+INT32 cli_reg_write
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	UINT32 ret_val
+);
+
+INT32 get_cli_info
+(
+     INT32 cli_id,
+     struct client_info *ci
+);
+
+p_atheros_dev get_client
+(
+     INT32 cli_id
+);
+
+INT32 rtc_reg_read
+(
+        INT32 cli_id,           
+        INT32 offset,                   
+        INT32 *ret_val                  
+);
+
+INT32 full_addr_read
+(
+        INT32 cli_id,
+        INT32 offset,
+        INT32 *ret_val
+);
+INT32 full_addr_write
+(
+        INT32 cli_id,           
+        INT32 offset,                   
+        UINT32 ret_val                  
+);
+
+INT32 get_chip_id                     
+(                               
+        INT32 cli_id,                   
+        INT32 offset,           
+        INT32 size,             
+        INT32 *ret_val          
+);                       
+
+INT32 rtc_reg_write
+(
+        INT32 cli_id,
+        INT32 offset,
+        UINT32 data
+);
+
+
+#define VALID_CLIENT(x) ((x)->cli_id != INVALID_CLIENT)
+#define BUSY_CLIENT(x) ((x)->dev_busy != 0)
+
+#endif // __CLIENT_H_
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/dk_event.h apps_1.2/art/modules/include/dk_event.h
--- apps/art/modules/include/dk_event.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/dk_event.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,93 @@
+/* dk_event.h - contains definitions for event.c */
+
+/*
+                Copyright (c) 2014 Qualcomm Atheros, Inc. All rights reserved.
+                Qualcomm is a trademark of Qualcomm Technologies Incorporated, registered in the United States and other countries.
+                All Qualcomm Technologies Incorporated trademarks are used with permission.
+                Atheros is a trademark of Qualcomm Atheros, Inc., registered in the United States and other countries.
+                Other products and brand names may be trademarks or registered trademarks of their respective owners.
+*/
+
+#ifndef __DK_EVENT_H_
+#define __DK_EVENT_H_
+
+#include "dk.h"
+
+#define INTERRUPT_F2    1
+#define TIMEOUT         4
+#define ISR_INTERRUPT   0x10
+#define DEFAULT_TIMEOUT 0xff
+
+typedef struct event_handle_ {
+    UINT32 eventID;
+    UINT32 f2Handle;
+} event_handle;
+
+struct event_struct_ {
+	struct event_struct_ *pNext;         // pointer to next event
+	struct event_struct_ *pLast;         // backward pointer to pervious event
+	event_handle    eventHandle;
+	UINT32            type;
+	UINT32            persistent;
+	UINT32            param1;
+	UINT32            param2;
+	UINT32            param3;
+	UINT32            result[6];
+};
+
+typedef struct event_struct_ event_struct;
+typedef struct event_struct_ *p_event_struct;
+
+typedef struct event_queue_ {
+	p_event_struct  pHead;     // pointer to first event in queue
+	p_event_struct   pTail;     // pointer to last event in queue
+	UINT16       queueSize;  // count of how many items are in queue
+	UINT32		flags;
+} event_queue, *p_event_queue;
+
+void initEventQueue(p_event_queue);
+
+void deleteEventQueue(p_event_queue);
+
+p_event_struct createEvent
+(
+	UINT32    type,          // the event ID
+	UINT32    persistent,    // set if want a persistent event
+	UINT32    param1,        // optional args
+	UINT32    param2,
+	UINT32    param3,
+	event_handle    eventHandle
+);
+
+p_event_struct copyEvent
+(
+	p_event_struct pExistingEvent // pointer to event to copy
+);
+
+UINT16 pushEvent
+(
+	p_event_struct pEvent,    // pointer to event to add
+	p_event_queue pQueue,     // pointer to queue to add to
+	BOOLEAN          protect
+);
+
+p_event_struct popEvent
+(
+	p_event_queue pQueue, // pointer to queue to add to
+	BOOLEAN          protect
+);
+
+UINT16 removeEvent
+(
+	p_event_struct    pEvent,
+	p_event_queue     pQueue,
+	BOOLEAN          protect
+);
+
+UINT16 checkForEvents
+(
+	p_event_queue pQueue,
+	BOOLEAN          protect
+);
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/dk_flash.h apps_1.2/art/modules/include/dk_flash.h
--- apps/art/modules/include/dk_flash.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/dk_flash.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,27 @@
+/*
+ * SPI Flash Memory support header file.
+ *
+ * $Id: //depot/sw/branches/art2_main_per_cs/src/art2/driver/linux/modules/include/dk_flash.h#1 $
+ *
+ *
+ * Copyright (c) 2005, Atheros Communications Inc.
+ *
+ * This code is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#define CYGNUM_FLASH_BLOCK_SIZE  0x10000
+#define FALSE 0
+#define TRUE 1
+#define CYGNUM_FLASH_END_RESERVED_BYTES 0x10000
+
+#define DK_BOARDCONFIG_SIZE 0x1000
+#define DK_RADIOCONFIG_SIZE 0x1000
+
+int flash_init(void);
+void flash_exit(void);
+unsigned int dk_flash_read (int flc, unsigned int offset, size_t len, UINT8 * buf);
+unsigned int dk_flash_write (int flc, unsigned int offset, size_t len, UINT8 * buf);
+
+/**********************************************************************/
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/dk.h apps_1.2/art/modules/include/dk.h
--- apps/art/modules/include/dk.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/dk.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,42 @@
+/* dk.h - contains variable declarations */
+
+#ifndef __DK_H_
+#define __DK_H_
+
+// Driver information
+#define DRV_NAME    "linuxdk"
+#define DRV_MAJOR_VERSION 1
+#define DRV_MINOR_VERSION 2
+
+#ifdef MODULE
+#define MOD_LICENCE "GPL"
+#define MOD_AUTHOR "muddin@atheros.com"
+#define MOD_DESCRIPTION "Linux MDK driver 1.0" 
+#endif
+
+// Common variable types are typedefed 
+typedef short INT16;
+typedef unsigned short UINT16;
+typedef int INT32;
+typedef long A_INT_PTR;
+typedef unsigned long A_UINT_PTR;
+typedef unsigned int UINT32;
+typedef char CHAR8;
+typedef unsigned char UCHAR8;
+typedef char INT8;
+typedef unsigned char UINT8;
+typedef void VOID;
+
+#ifndef NULL
+#define NULL (void *)0
+#endif
+
+#define MAX_BARS 6
+
+typedef enum 
+{
+		FALSE=0,
+		TRUE
+} BOOLEAN;
+
+#endif // __DK_H_
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/dk_ioctl.h apps_1.2/art/modules/include/dk_ioctl.h
--- apps/art/modules/include/dk_ioctl.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/dk_ioctl.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,64 @@
+#ifndef __DK_IOCTL_H_
+#define __DK_IOCTL_H_
+
+
+#define DK_IOCTL_GET_VERSION 1
+#define DK_IOCTL_GET_CLIENT_INFO 2
+#define DK_IOCTL_CFG_READ 3
+#define DK_IOCTL_CFG_WRITE 4
+#define DK_IOCTL_CREATE_EVENT 5
+#define DK_IOCTL_GET_NEXT_EVENT 6
+#define DK_IOCTL_SYS_REG_READ_32 7
+#define DK_IOCTL_SYS_REG_WRITE_32 8
+#define DK_IOCTL_FLASH_READ 9
+#define DK_IOCTL_FLASH_WRITE 10
+#define DK_IOCTL_MAC_WRITE 11
+#define DK_IOCTL_GET_CHIP_ID 12
+#define DK_IOCTL_RTC_REG_READ 13
+#define DK_IOCTL_RTC_REG_WRITE 14
+#define DK_IOCTL_FULL_ADDR_READ 15
+#define DK_IOCTL_FULL_ADDR_WRITE 16
+
+#undef MAX_BARS
+#define MAX_BARS    6
+
+struct cfg_op {
+	int offset;
+	int size;
+	int value;
+};
+struct client_info {
+    unsigned long reg_phy_addr;
+    int reg_range;
+    unsigned long mem_phy_addr;
+    int mem_size;
+    int irq;
+    unsigned long areg_phy_addr[MAX_BARS];
+    int areg_range[MAX_BARS];
+    int numBars;
+    int device_class;
+    unsigned int dma_mem_addr;
+};
+
+struct event_op {
+	unsigned int valid;
+	unsigned int param[16];
+};
+
+struct flash_op{
+	int fcl;
+	int offset;
+	int len;
+	int retlen;
+	unsigned char value;
+};
+
+struct flash_op_wr{
+	int fcl;
+	int offset;
+	int len;
+	int retlen;
+	unsigned char *pvalue;
+};
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/dk_pci_bus.h apps_1.2/art/modules/include/dk_pci_bus.h
--- apps/art/modules/include/dk_pci_bus.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/dk_pci_bus.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,47 @@
+/* pci_bus.h - contains declarations of the pci bus functions */
+
+#ifndef __DK_PCI_BUS_H_
+#define __DK_PCI_BUS_H_
+
+#include "dk.h"
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+INT32 bus_module_init
+(
+	VOID
+);
+
+VOID bus_module_exit
+(
+	VOID
+);
+
+INT32 bus_dev_init
+(
+     void *bus_dev
+);
+
+
+INT32 bus_dev_exit
+(
+     void  *bus_dev
+);
+
+INT32 bus_cfg_read
+(
+     void *bus_dev,
+     INT32 offset,
+     INT32 size,
+     INT32 *ret_val
+);
+
+INT32 bus_cfg_write
+(
+    void *bus_dev,
+    INT32 offset,
+	INT32 size,
+	INT32 ret_val
+);
+
+#endif
+		
+#endif //__PCI_BUS_H_
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/flbase.h apps_1.2/art/modules/include/flbase.h
--- apps/art/modules/include/flbase.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/flbase.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,188 @@
+
+#ifndef FLBASE_H
+#define FLBASE_H
+
+#include "flcustom.h"
+
+/* standard type definitions */
+typedef int 		FLBoolean;
+
+/* Boolean constants */
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+#ifndef TRUE
+#define	TRUE	1
+#endif
+
+#ifndef ON
+#define	ON	1
+#endif
+#ifndef OFF
+#define	OFF	0
+#endif
+
+#define SECTOR_SIZE		(1 << SECTOR_SIZE_BITS)
+
+
+
+#define FAR_LEVEL       0
+/* define SectorNo range according to media maximum size */
+#if (MAX_VOLUME_MBYTES * 0x100000l) / SECTOR_SIZE > 0x10000l
+typedef unsigned long SectorNo;
+#define	UNASSIGNED_SECTOR 0xffffffffl
+#else
+typedef unsigned short SectorNo;
+#define UNASSIGNED_SECTOR 0xffff
+#endif
+
+#if FAR_LEVEL > 0
+  #define FAR0	far
+#else
+  #define FAR0
+#endif
+
+#if FAR_LEVEL > 1
+  #define FAR1	far
+#else
+  #define FAR1
+#endif
+
+#if FAR_LEVEL > 2
+  #define FAR2	far
+#else
+  #define FAR2
+#endif
+
+
+#define vol (*pVol)
+
+
+#ifndef BIG_ENDIAN
+
+typedef unsigned short LEushort;
+typedef unsigned long LEulong;
+
+#define LE2(arg)	arg
+#define	toLE2(to,arg)	(to) = (arg)
+#define LE4(arg)	arg
+#define	toLE4(to,arg)	(to) = (arg)
+#define COPY2(to,arg)	(to) = (arg)
+#define COPY4(to,arg)	(to) = (arg)
+
+typedef unsigned char Unaligned[2];
+typedef Unaligned Unaligned4[2];
+
+#define UNAL2(arg)	fromUNAL(arg)
+#define toUNAL2(to,arg)	toUNAL(to,arg)
+
+#define UNAL4(arg)	fromUNALLONG(arg)
+#define toUNAL4(to,arg)	toUNALLONG(to,arg)
+
+extern void toUNAL(unsigned char FAR0 *unal, unsigned n);
+
+extern unsigned short fromUNAL(unsigned char const FAR0 *unal);
+
+extern void toUNALLONG(Unaligned FAR0 *unal, unsigned long n);
+
+extern unsigned long fromUNALLONG(Unaligned const FAR0 *unal);
+
+#else
+
+typedef unsigned char LEushort[2];
+typedef unsigned char LEulong[4];
+
+#define LE2(arg)	fromLEushort(arg)
+#define	toLE2(to,arg)	toLEushort(to,arg)
+#define LE4(arg)	fromLEulong(arg)
+#define	toLE4(to,arg)	toLEulong(to,arg)
+#define COPY2(to,arg)	copyShort(to,arg)
+#define COPY4(to,arg)	copyLong(to,arg)
+
+#define	Unaligned	LEushort
+#define	Unaligned4	LEulong
+
+extern void toLEushort(unsigned char FAR0 *le, unsigned n);
+
+extern unsigned short fromLEushort(unsigned char const FAR0 *le);
+
+extern void toLEulong(unsigned char FAR0 *le, unsigned long n);
+
+extern unsigned long fromLEulong(unsigned char const FAR0 *le);
+
+extern void copyShort(unsigned char FAR0 *to,
+		      unsigned char const FAR0 *from);
+
+extern void copyLong(unsigned char FAR0 *to,
+		     unsigned char const FAR0 *from);
+
+#define	UNAL2		LE2
+#define	toUNAL2		toLE2
+
+#define	UNAL4		LE4
+#define	toUNAL4		toLE4
+
+#endif /* BIG_ENDIAN */
+
+
+typedef enum {flOK 		= 0,	/* Status code for operation.
+					   A zero value indicates success,
+					   other codes are the extended
+					   DOS codes. */
+	     flBadFunction	= 1,
+	     flFileNotFound	= 2,
+	     flPathNotFound	= 3,
+	     flTooManyOpenFiles = 4,
+	     flNoWriteAccess	= 5,
+	     flBadFileHandle	= 6,
+	     flDriveNotAvailable = 9,
+	     flNonFATformat	= 10,
+	     flFormatNotSupported = 11,
+	     flNoMoreFiles	= 18,
+	     flWriteProtect 	= 19,
+	     flBadDriveHandle	= 20,
+	     flDriveNotReady 	= 21,
+	     flUnknownCmd 	= 22,
+	     flBadFormat	= 23,
+	     flBadLength	= 24,
+	     flDataError	= 25,
+	     flUnknownMedia 	= 26,
+	     flSectorNotFound 	= 27,
+	     flOutOfPaper 	= 28,
+	     flWriteFault 	= 29,
+	     flReadFault	= 30,
+	     flGeneralFailure 	= 31,
+	     flDiskChange 	= 34,
+	     flVppFailure	= 50,
+	     flBadParameter	= 51,
+	     flNoSpaceInVolume	= 52,
+	     flInvalidFATchain	= 53,
+	     flRootDirectoryFull = 54,
+	     flNotMounted	= 55,
+	     flPathIsRootDirectory = 56,
+	     flNotADirectory	= 57,
+	     flDirectoryNotEmpty = 58,
+	     flFileIsADirectory	= 59,
+	     flAdapterNotFound	= 60,
+	     flFormattingError	= 62,
+	     flNotEnoughMemory	= 63,
+	     flVolumeTooSmall	= 64,
+	     flBufferingError	= 65,
+	     flFileAlreadyExists = 80,
+
+	     flIncomplete	= 100,
+	     flTimedOut		= 101,
+	     flTooManyComponents = 102
+
+	     } FLStatus;
+
+/* call a procedure returning status and fail if it fails. This works only in
+   routines that return Status */
+
+#define checkStatus(exp)      {	FLStatus status = (exp); \
+				if (status != flOK)	 \
+				  return status; }
+
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/flbuffer.h apps_1.2/art/modules/include/flbuffer.h
--- apps/art/modules/include/flbuffer.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/flbuffer.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,44 @@
+
+/*
+ * $Log:   P:/user/amir/lite/vcs/flbuffer.h_v  $
+   
+      Rev 1.5   10 Sep 1997 16:15:52   danig
+   Got rid of generic names
+   
+      Rev 1.4   28 Aug 1997 16:47:30   danig
+   include flbase.h
+   
+      Rev 1.3   07 Jul 1997 15:23:28   amirban
+   Ver 2.0
+   
+      Rev 1.2   18 Aug 1996 13:48:02   amirban
+   Comments
+   
+      Rev 1.1   01 Jul 1996 15:41:58   amirban
+   Doesn't define buffer
+   
+      Rev 1.0   20 Mar 1996 13:33:20   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+#ifndef FLBUFFER_H
+#define FLBUFFER_H
+
+#include "flbase.h"
+
+typedef struct {
+  unsigned char data[SECTOR_SIZE];	/* sector buffer */
+  SectorNo	sectorNo;		/* current sector in buffer */
+  void		*owner;			/* owner of buffer */
+  FLBoolean	dirty;			/* sector in buffer was changed */
+  FLBoolean	checkPoint;		/* sector in buffer must be flushed */
+} FLBuffer;
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/flcustom.h apps_1.2/art/modules/include/flcustom.h
--- apps/art/modules/include/flcustom.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/flcustom.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,317 @@
+/*
+ * $Log:   P:/user/amir/lite/vcs/flcustom.h_v  $
+
+      Rev 1.10   14 Aug 1997 16:05:12   danig
+   MIN_CLUSTER_SIZE
+
+      Rev 1.9   04 Aug 1997 13:13:48   danig
+   Low level API
+
+      Rev 1.8   24 Jul 1997 18:11:14   amirban
+   Moved stuff to flsystem.h
+
+      Rev 1.7   07 Jul 1997 15:23:42   amirban
+   Ver 2.0
+
+      Rev 1.6   21 Oct 1996 18:12:58   amirban
+   Split/join option
+
+      Rev 1.5   14 Aug 1996 14:16:26   amirban
+   BACKGROUND
+
+      Rev 1.4   14 Jul 1996 16:48:56   amirban
+   No more formatting parameters
+
+      Rev 1.3   09 Jul 1996 14:36:38   amirban
+   CPU_i386 define
+
+      Rev 1.2   08 Jul 1996 17:21:00   amirban
+   Added ABS_READ_WRITE
+
+      Rev 1.1   19 Jun 1996 15:23:10   amirban
+   Added EXIT option
+
+      Rev 1.0   19 May 1996 19:44:42   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+
+#ifndef FLCUSTOM_H
+#define FLCUSTOM_H
+
+/*
+ *
+ *		Section 2: File System Customization
+ *		------------------------------------
+ */
+
+/* ISSUE #2.1: Number of drives
+ *
+ * Defines the maximum number of drives (and sockets) supported.
+ *
+ * The actual number of drives depends on which socket controllers are
+ * actually registered.
+ */
+
+#define DRIVES	5
+
+
+/* ISSUE #2.1: Number of open files
+ *
+ * Defines the maximum number of files that may be open at a time.
+ */
+
+#define FILES	  0
+
+
+/* ISSUE #2.2: Sector size
+ *
+ * Define the log2 of sector size for the FAT & FTL layer. Note that the
+ * default 512 bytes is the de-facto standard and practically the only one
+ * that provides real PC interoperability.
+ */
+
+#define SECTOR_SIZE_BITS	9
+
+
+/* ISSUE #2.3: Formatting
+ *
+ * Uncomment the following line if you need to format with fsFormatVolume.
+ */
+
+#define FORMAT_VOLUME
+
+
+/* ISSUE #2.4: Defragmentation
+ *
+ * Uncomment the following line if you need to defragment with
+ * fsDefragmentVolume.
+ */
+
+/* #define DEFRAGMENT_VOLUME */
+
+
+/* ISSUE #2.5: Sub-directories
+ *
+ * Uncomment the following line if you need support for sub-directories
+ */
+
+/* #define SUB_DIRECTORY */
+
+
+/* ISSUE #2.6: Rename file
+ *
+ * Uncomment the following line if you need to rename files with fsRenameFile.
+ */
+
+/* #define RENAME_FILE */
+
+
+/* ISSUE #2.7: Split / join file
+ *
+ * Uncomment the following line if you need to split or join files with
+ * fsSplitFile and fsJoinFile
+ */
+
+/* #define SPLIT_JOIN_FILE */
+
+
+/* ISSUE #2.8: 12-bit FAT support
+ *
+ * Comment the following line if you do not need support for DOS media with
+ * 12-bit FAT (typically media of 2 MBytes or less).
+ */
+
+#define FAT_12BIT
+
+
+/* ISSUE #2.9: Parse path function
+ *
+ * Uncomment the following line if you need to parse DOS-like path names
+ * with fsParsePath.
+ */
+
+/* #define PARSE_PATH */
+
+
+/* ISSUE #2.10: Maximum supported medium size
+ *
+ * Define here the largest Flash medium size (in MBytes) you want supported.
+ */
+
+#define MAX_VOLUME_MBYTES	40
+
+
+/* ISSUE #2.11: Assumed card parameters
+ *
+ * This issue is relevant only if you are not defining any allocation
+ * routines in #5.2.
+ *
+ * The following are assumptions about FTL parameters of the Flash media.
+ * They affect the size of the heap buffer allocated in FTLLITE.C.
+ */
+
+#define ASSUMED_FTL_UNIT_SIZE	0x20000l	/* Intel interleave-2 */
+#define	ASSUMED_VM_LIMIT	0x10000l	/* limit at 64 KB */
+#define ASSUMED_NFTL_UNIT_SIZE	0x4000l
+
+
+/* ISSUE #2.12: Number of buffers
+ *
+ * Normally two sector buffers are needed, one for the FAT layer, another
+ * for the FTL layer. You may save about 512 bytes of RAM requirements by
+ * uncommenting the following definition.
+ * This will come at the cost of both read and write performance.
+ */
+
+/*#define SINGLE_BUFFER */
+
+
+/* ISSUE #2.13: Absolute read & write
+ *
+ * Uncomment the following line if you want to be able to read & write
+ * sectors by absolute sector number (i.e. without regard to files and
+ * directories).
+ */
+
+#define ABS_READ_WRITE
+
+
+/* ISSUE #2.14: Low level operations
+ *
+ * Uncomment the following line if you want to do low level operations.
+ * Low level operations include: read from a physical address, write to
+ * a physical address, erase a unit according to its physical unit number.
+ */
+
+#define LOW_LEVEL
+
+
+/* ISSUE #2.15: Application exit
+ *
+ * If the FLite application ever exits, it needs to call fsEXit before
+ * exitting. Uncomment the following line to enable this.
+ */
+
+/* #define EXIT */
+
+
+/* ISSUE #2.16: Number of sectors per cluster
+ *
+ * Define the minimum cluster size in sectors.
+ */
+
+#define MIN_CLUSTER_SIZE   4
+
+
+/*
+ *
+ *		Section 3: Socket Hardware Customization
+ *		----------------------------------------
+ */
+
+/* ISSUE #3.1: Vpp voltage
+ *
+ * If your socket does not supply 12 volts, comment the following line. In
+ * this case, you will be able to work only with Flash cards that do not
+ * require external 12 Volt Vpp.
+ *
+ */
+
+#define SOCKET_12_VOLTS
+
+
+/* ISSUE #3.2: Fixed or removable media
+ *
+ * If your Flash media is fixed, uncomment the following line, and ignore
+ * issue #3.3.
+ */
+
+/* #define FIXED_MEDIA */
+
+
+/* ISSUE #3.3: Hardware card change detection
+ *
+ * This issue is now obsolete
+ *
+ */
+
+
+/* ISSUE #3.4: Interval timer
+ *
+ * The following defines a timer polling interval in milliseconds. If the
+ * value is 0, an interval timer is not installed.
+ *
+ * If you select an interval timer, you should provide an implementation
+ * for 'installTimer' defined in timer.h.
+ *
+ * An interval timer is not a must, but it is recommended. The following
+ * will occur if an interval timer is absent:
+ *
+ * - Card changes can be recognized only if socket hardware detects them
+ *   (see issue #3.2).
+ * - The Vpp delayed turn-off procedure is not applied. This may downgrade
+ *   write performance significantly if the Vpp switching time is slow.
+ * - The watchdog timer that guards against certain operations being stuck
+ *   indefinitely will not be active.
+ */
+
+#define	POLLING_INTERVAL 100		/* Polling interval in millisec.
+					   if 0, no polling is done */
+
+
+/*
+ *
+ *		       Section 4: MTD Customization
+ *		       ----------------------------
+ */
+
+/* ISSUE #4.1: MTD Installation
+ *
+ * This issue is now obsolete
+ *
+ */
+
+
+/* ISSUE #4.2: Background erasing
+ *
+ * If you include support for Flash technology that has suspend-for-write
+ * capability, you can gain considerable write performance and improve
+ * real-time response for your write operations by including background erase
+ * capability. In some cases, you can gain performance by including this
+ * feature even if no suspend-for-write capability is supported. See the
+ * FLite manual for complete details.
+ *
+ * On the other hand, this feature adds to required code & RAM, makes
+ * necessary some additional customization on your part, and depends on
+ * compiler features that, while defined as ANSI-C standard, may have
+ * a problematic implementation in your particular environment. See the
+ * FLite manual for complete details.
+ *
+ * Uncomment the following line to support background erasing.
+ */
+
+/* #define	BACKGROUND */
+
+
+/* ISSUE #4.3: Maximum MTD's and Translation Layers
+ *
+ * Define here the maximum number of Memory Technology Drivers and
+ * Translation Layers that may be installed. Note that the actual
+ * number installed is determined by which components are installed in
+ * 'registerComponents' (custom.c)
+ */
+
+#define MTDS	10	/* Up to 5 MTD's */
+
+#define	TLS	5	/* Up to 3 Translation Layers */
+
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/flflash.h apps_1.2/art/modules/include/flflash.h
--- apps/art/modules/include/flflash.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/flflash.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,230 @@
+
+/*
+ * $Log:   P:/user/amir/lite/vcs/flflash.h_v  $
+   
+      Rev 1.10   03 Nov 1997 16:12:52   danig
+   amdCmdRoutine receives FlashPTR
+   
+      Rev 1.9   28 Jul 1997 14:46:20   danig
+   setPowerOnCallback
+   
+      Rev 1.8   24 Jul 1997 17:55:08   amirban
+   FAR to FAR0
+   
+      Rev 1.7   21 Jul 1997 14:45:26   danig
+   No parallelLimit
+   
+      Rev 1.6   07 Jul 1997 15:23:44   amirban
+   Ver 2.0
+   
+      Rev 1.5   08 Jun 1997 19:19:10   danig
+   BIG_PAGE & FULL_PAGE
+   
+      Rev 1.4   18 May 1997 17:34:14   amirban
+   Defined write mode flags
+   
+      Rev 1.3   18 Aug 1996 13:47:46   amirban
+   Comments
+   
+      Rev 1.2   31 Jul 1996 14:29:34   amirban
+   New flash.erase definition
+   
+      Rev 1.1   04 Jul 1996 18:19:52   amirban
+   New flag field
+   
+      Rev 1.0   20 Mar 1996 13:33:20   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+
+#ifndef FLFLASH_H
+#define FLFLASH_H
+
+#include "flsocket.h"
+
+/* Some useful types for mapped Flash locations */
+
+typedef volatile unsigned char FAR0 * FlashPTR;
+typedef volatile unsigned short int FAR0 * FlashWPTR;
+typedef volatile unsigned long FAR0 * FlashDPTR;
+
+typedef unsigned short FlashType;	/* JEDEC id */
+
+#define	NOT_FLASH	0
+
+/* page characteristics flags */
+#define  BIG_PAGE    0x0100             /* page size > 100H*/
+#define  FULL_PAGE  0x0200          	/* no partial page programming*/
+
+/* MTD write routine mode flags */
+#define OVERWRITE	1	/* Overwriting non-erased area  */
+#define EDC		2	/* Activate ECC/EDC		*/
+#define EXTRA		4	/* Read/write spare area	*/
+
+
+/*----------------------------------------------------------------------*/
+/*	         Flash array identification structure			*/
+/*									*/
+/* This structure contains a description of the Flash array and		*/
+/* routine pointers for the map, read, write & erase functions.		*/
+/* 									*/
+/* The structure is initialized by the MTD that identifies the Flash	*/
+/* array.                                                               */
+/* On entry to an MTD, the Flash structure contains default routines	*/
+/* for all operations. This routines are sufficient forread-only access	*/
+/* to NOR Flash on a memory-mapped socket. The MTD should override the	*/
+/* default routines with MTD specific ones when appropriate.		*/
+/*----------------------------------------------------------------------*/
+
+/* Flash array identification structure */
+
+typedef struct tFlash FLFlash;		/* Forward definition */
+
+struct tFlash {
+  FlashType	type;			/* Flash device type (JEDEC id) */
+  long int	erasableBlockSize;	/* Smallest physically erasable size
+					   (with interleaving taken in account) */
+  long int	chipSize;		/* chip size */
+  int		noOfChips;		/* no of chips in array */
+  int		interleaving;		/* chip interleaving
+					   (The interleaving is defined as
+					   the address difference between
+					   two consecutive bytes on a chip) */
+  unsigned	flags;			/* Special capabilities & options
+					   Bits 0-7 may be used by FLite.
+					   Bits 8-15 are not used bt FLite
+					   and may be used by MTD's for MTD-
+					   specific purposes. */
+  void *	mtdVars;		/* Points to MTD private area for
+					   this socket.
+					   This field, if used by the MTD, is
+					   initialized by the MTD identification
+					   routine */
+  FLSocket *	socket;			/* Socket of this drive */
+
+
+/* Flag bit values */
+
+#define SUSPEND_FOR_WRITE	1	/* MTD provides suspend for write */
+#define	NFTL_ENABLED		2	/* Flash can run NFTL */
+
+
+/*----------------------------------------------------------------------*/
+/*      	          f l a s h . m a p				*/
+/*									*/
+/* MTD specific map routine						*/
+/*                                                                      */
+/* The default routine maps by socket mapping, and is suitable for all  */
+/* NOR Flash.                                                           */
+/* NAND or other type Flash should use map-through-copy emulation: Read */
+/* a block of Flash to an internal buffer and return a pointer to that	*/
+/* buffer.								*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*      address		: Card address to map				*/
+/*	length		: Length to map					*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	Pointer to required card address				*/
+/*----------------------------------------------------------------------*/
+  void FAR0 *	(*map)(FLFlash *, CardAddress, int);
+
+/*----------------------------------------------------------------------*/
+/*      	          f l a s h . r e a d				*/
+/*									*/
+/* MTD specific Flash read routine					*/
+/*									*/
+/* The default routine reads by copying from a mapped window, and is	*/
+/* suitable for all NOR Flash.						*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*      address		: Card address to read				*/
+/*	buffer		: Area to read into				*/
+/*	length		: Length to read				*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  FLStatus	(*read)(FLFlash *, CardAddress, void FAR1 *, int, int);
+
+/*----------------------------------------------------------------------*/
+/*                       f l a s h . w r i t e				*/
+/*									*/
+/* MTD specific Flash write routine					*/
+/*									*/
+/* The default routine returns a write-protect error.			*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*      address		: Card address to write to			*/
+/*      buffer		: Address of data to write			*/
+/*	length		: Number of bytes to write			*/
+/*	modes		: See write mode flags definition above		*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	FLStatus	: 0 on success, failed otherwise		*/
+/*----------------------------------------------------------------------*/
+  FLStatus 	(*write)(FLFlash *, CardAddress, const void FAR1 *, int, int);
+
+/*----------------------------------------------------------------------*/
+/*                       f l a s h . e r a s e				*/
+/*									*/
+/* Erase one or more contiguous Flash erasable blocks			*/
+/*									*/
+/* The default routine returns a write-protect error.			*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*      firstErasableBlock : Number of first block to erase		*/
+/*	numOfErasableBlocks: Number of blocks to erase			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	FLStatus	: 0 on success, failed otherwise		*/
+/*----------------------------------------------------------------------*/
+  FLStatus 	(*erase)(FLFlash *, int, int);
+
+/*----------------------------------------------------------------------*/
+/*      	 f l a s h . s e t P o w e r O n C a l l b a c k	*/
+/*									*/
+/* Register power on callback routine. Default: no routine is 		*/
+/* registered.								*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void 	(*setPowerOnCallback)(FLFlash *);
+};
+
+
+
+/* MTD registration information */
+
+extern int noOfMTDs;	/* No. of MTDs actually registered */
+
+typedef FLStatus (*MTDidentifyRoutine) (FLFlash vol);
+
+extern MTDidentifyRoutine mtdTable[];
+
+
+/* See interface documentation of functions in flash.c	*/
+
+extern void flIntelIdentify(FLFlash *, 
+                            void (*)(FLFlash *, CardAddress, unsigned char, FlashPTR), 
+                            CardAddress);
+
+extern FLStatus	flIntelSize(FLFlash *, 
+                            void (*)(FLFlash *, CardAddress, unsigned char, FlashPTR), 
+                            CardAddress);
+
+extern FLStatus	flIdentifyFlash(FLSocket *socket, FLFlash *flash);
+
+#endif
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/flsocket.h apps_1.2/art/modules/include/flsocket.h
--- apps/art/modules/include/flsocket.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/flsocket.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,296 @@
+
+/*
+ * $Log:   P:/user/amir/lite/vcs/flsocket.h_v  $
+   
+      Rev 1.11   28 Sep 1997 18:23:28   danig
+   flExitSocket 
+   
+      Rev 1.10   10 Sep 1997 16:16:20   danig
+   Got rid of generic names
+   
+      Rev 1.9   28 Aug 1997 17:48:04   danig
+   Buffer & remapped per socket
+   
+      Rev 1.8   24 Jul 1997 18:05:24   amirban
+   FAR to FAR0
+   
+      Rev 1.7   20 Jul 1997 17:16:28   amirban
+   No watchDogTimer
+   
+      Rev 1.6   07 Jul 1997 15:23:46   amirban
+   Ver 2.0
+   
+      Rev 1.5   08 Jun 1997 17:03:16   amirban
+   power on callback
+   
+      Rev 1.4   08 Oct 1996 12:17:34   amirban
+   Defined remapped
+   
+      Rev 1.3   18 Aug 1996 13:47:44   amirban
+   Comments
+   
+      Rev 1.2   12 Aug 1996 15:47:42   amirban
+   Changed value of UNDEF_MAPPING
+   
+      Rev 1.1   31 Jul 1996 14:29:08   amirban
+   Defined set/getMappingContext
+
+      Rev 1.0   20 Mar 1996 13:33:20   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+
+#ifndef FLSOCKET_H
+#define FLSOCKET_H
+
+#include "flbase.h"
+#include "flbuffer.h"
+
+#define ATTRIBUTE_SPACE_MAPPED	0x8000
+
+typedef enum {PowerOff, PowerGoingOff, PowerOn} PowerState;
+
+
+/* Socket state variables */
+typedef struct tSocket FLSocket;	/* Forward definition */
+
+struct tSocket {
+  unsigned	volNo;		/* Volume no. of socket */
+  unsigned 	serialNo; 	/* Serial no. of socket on controller */
+
+  FLBoolean	cardChanged;	/* need media change notification */
+
+  int 		VccUsers;	/* No. of current VCC users */
+  int 		VppUsers;	/* No. of current VPP users */
+
+  PowerState	VccState;	/* Actual VCC state */
+  PowerState	VppState;	/* Actual VPP state */
+
+  FLBoolean	remapped;       /* set to TRUE whenever the socket window is moved */
+
+  void		(*powerOnCallback)(void *flash); /* Notification routine for Vcc on */
+  void *	flash;		/* Flash object for callback */
+
+  struct {                      /* Window state */
+    unsigned int baseAddress;	/* Physical base as a 4K page */
+    unsigned int currentPage;	/* Our current window page mapping */
+    void FAR0 *	base;		/* Pointer to window base */
+    long int	size;           /* Window size (must by power of 2) */
+    unsigned	speed;		/* in nsec. */
+    unsigned 	busWidth;	/* 8 or 16 bits */
+  } window;
+
+/*----------------------------------------------------------------------*/
+/*      	          c a r d D e t e c t e d			*/
+/*									*/
+/* Detect if a card is present (inserted)				*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	0 = card not present, other = card present			*/
+/*----------------------------------------------------------------------*/
+  FLBoolean (*cardDetected)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	               V c c O n				*/
+/*									*/
+/* Turns on Vcc (3.3/5 Volts). Vcc must be known to be good on exit.	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*VccOn)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	             V c c O f f				*/
+/*									*/
+/* Turns off Vcc.							*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*VccOff)(FLSocket vol);
+
+#ifdef SOCKET_12_VOLTS
+
+/*----------------------------------------------------------------------*/
+/*      	               V p p O n				*/
+/*									*/
+/* Turns on Vpp (12 Volts. Vpp must be known to be good on exit.	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	FLStatus	: 0 on success, failed otherwise		*/
+/*----------------------------------------------------------------------*/
+  FLStatus (*VppOn)(FLSocket vol);
+
+
+/*----------------------------------------------------------------------*/
+/*      	             V p p O f f				*/
+/*									*/
+/* Turns off Vpp.							*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*VppOff)(FLSocket vol);
+
+#endif	/* SOCKET_12_VOLTS */
+
+/*----------------------------------------------------------------------*/
+/*      	          i n i t S o c k e t			        */
+/*									*/
+/* Perform all necessary initializations of the socket or controller	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	FLStatus	: 0 on success, failed otherwise		*/
+/*----------------------------------------------------------------------*/
+  FLStatus (*initSocket)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	            s e t W i n d o w				*/
+/*									*/
+/* Sets in hardware all current window parameters: Base address, size,  */
+/* speed and bus width.							*/
+/* The requested settings are given in the 'vol.window' structure.	*/
+/*									*/
+/* If it is not possible to set the window size requested in		*/
+/* 'vol.window.size', the window size should be set to a larger value,	*/
+/* if possible. In any case, 'vol.window.size' should contain the	*/
+/* actual window size (in 4 KB units) on exit.				*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*setWindow)(FLSocket vol);
+
+
+/*----------------------------------------------------------------------*/
+/*      	   s e t M a p p i n g C o n t e x t			*/
+/*									*/
+/* Sets the window mapping register to a card address.			*/
+/*									*/
+/* The window should be set to the value of 'vol.window.currentPage',	*/
+/* which is the card address divided by 4 KB. An address over 128KB,	*/
+/* (page over 32K) specifies an attribute-space address.		*/
+/*									*/
+/* The page to map is guaranteed to be on a full window-size boundary.	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*setMappingContext)(FLSocket vol, unsigned page);
+
+/*----------------------------------------------------------------------*/
+/*     	 g e t A n d C l e a r C a r d C h a n g e I n d i c a t o r    */
+/*									*/
+/* Returns the hardware card-change indicator and clears it if set.	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	0 = Card not changed, other = card changed			*/
+/*----------------------------------------------------------------------*/
+  FLBoolean (*getAndClearCardChangeIndicator)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	          w r i t e P r o t e c t e d			*/
+/*									*/
+/* Returns the write-protect state of the media				*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	0 = not write-protected, other = write-protected		*/
+/*----------------------------------------------------------------------*/
+  FLBoolean (*writeProtected)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	          f r e e S o c k e t				*/
+/*									*/
+/* Free resources that were allocated for this socket.			*/
+/* This function is called when FLite exits.				*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+#ifdef EXIT
+  void (*freeSocket)(FLSocket vol);
+#endif
+};
+
+
+#define	UNDEFINED_MAPPING	0x7fff
+
+typedef unsigned long CardAddress;	/* Physical offset on card */
+
+/* See interface documentation of functions in socket.c */
+
+extern FLStatus	flInitSockets(void);
+
+#ifdef EXIT
+extern void	flExitSocket(FLSocket *);
+#endif
+
+extern unsigned	flSocketNoOf(const FLSocket *);
+extern FLSocket * flSocketOf(unsigned volNo);
+extern FLBuffer *flBufferOf(unsigned volNo);
+
+extern void	flNeedVcc(FLSocket *);
+extern void	flDontNeedVcc(FLSocket *);
+#ifdef SOCKET_12_VOLTS
+extern FLStatus	flNeedVpp(FLSocket *);
+extern void	flDontNeedVpp(FLSocket *);
+#endif
+extern void	flSocketSetBusy(FLSocket *, FLBoolean);	/* entry/exit operations */
+extern FLBoolean  flWriteProtected(FLSocket *); /* write-protection status */
+#ifndef FIXED_MEDIA
+extern FLStatus	flMediaCheck(FLSocket *);	/* check for media status change */
+extern void	flResetCardChanged(FLSocket *);
+#endif
+extern unsigned flGetMappingContext(FLSocket *);  /* Currently mapped 4KB page */
+extern void FAR0 *flMap(FLSocket *, CardAddress);	/* map and point at card address */
+extern void	flSetWindowBusWidth(FLSocket *, unsigned); /* set window data-path */
+extern void	flSetWindowSpeed(FLSocket *, unsigned);	/* set window speed (nsec.) */
+extern void	flSetWindowSize(FLSocket *, unsigned);	/* in 4KB units */
+
+extern void	flSetPowerOnCallback(FLSocket *, void (*)(void *), void *);
+			/* Set MTD notification for socket power on */
+extern	void 	flIntervalRoutine(FLSocket *);	/* socket interval routine */
+
+
+extern unsigned	noOfDrives;	/* No. of drives actually registered */
+
+/* The milliseconds counter is active when socket polling is enabled. When
+   the socket interval routine is called, the counter is incremented by
+   the interval in milliseconds.
+   The counter can be used to avoid getting in a loop that is not guaranteed
+   to terminate (such as waiting for a flash status register). Save the counter
+   at entry to the loop, and check in the loop the amount of time that
+   was spent in the loop. */
+
+extern unsigned long 	flMsecCounter;
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/include/flsystem.h apps_1.2/art/modules/include/flsystem.h
--- apps/art/modules/include/flsystem.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/include/flsystem.h	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,284 @@
+/*
+ * $Log:   V:/flsystem.h_v  $
+
+      Rev 1.0   13 Jan 1999 22:18:07   Yogu
+   added vxLib.h and macro for fault safe write in isRAM.
+
+      Rev 1.0   08 Jan 1998 17:20:00   Hdei
+   changed MALLOC FREE to MALLOC_TFFS FREE_TFFS.
+
+      Rev 1.0   24 Jul 1997 18:13:06   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+
+#ifndef FLSYSTEM_H
+#define FLSYSTEM_H
+
+#include <vxWorks.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <ctype.h>
+#include <tickLib.h>
+#include <wdLib.h>
+#include <sysLib.h>
+#include <excLib.h>
+#include <semLib.h>
+#include <ioLib.h>
+#include <iosLib.h>
+#include <memLib.h>
+#include <errnoLib.h>
+#include <vxLib.h>
+
+
+/*
+ * 			signed/unsigned char
+ *
+ * It is assumed that 'char' is signed. If this is not your compiler
+ * default, use compiler switches, or insert a #pragma here to define this.
+ *
+ */
+
+/* char is signed by default in GNU C */
+
+
+/* 			CPU target
+ *
+ * Use compiler switches or insert a #pragma here to select the CPU type
+ * you are targeting.
+ *
+ * If the target is an Intel 80386 or above, also uncomment the CPU_i386
+ * definition.
+ */
+
+/* defined in VxWorks makefile */
+
+/* 			NULL constant
+ *
+ * Some compilers require a different definition for the NULL pointer
+ */
+
+/* #include <_null.h> */
+
+
+/* 			Little-endian/big-endian
+ *
+ * FAT and FTL structures use the little-endian (Intel) format for integers.
+ * If your machine uses the big-endian (Motorola) format, uncomment the
+ * following line.
+ * This option needs a C++ compiler.
+ * Note that even on big-endian machines you may omit the BIG_ENDIAN
+ * definition for smaller code size and better performance, but your media
+ * will not be compatible with standard FAT and FTL.
+ */
+
+/* we are using VxWorks #define _BYTE_ORDER here */
+#ifndef _BYTE_ORDER
+#error "byte order is not defined"
+#else  /* _BYTE_ORDER */
+#if (_BYTE_ORDER == _BIG_ENDIAN)
+#define BIG_ENDIAN
+#else  /* (_BYTE_ORDER == _BIG_ENDIAN) */
+#undef BIG_ENDIAN
+#endif /* (_BYTE_ORDER == _BIG_ENDIAN) */
+#endif /* _BYTE_ORDER */
+
+
+/* 			Far pointers
+ *
+ * Specify here which pointers may be far, if any.
+ * Far pointers are usually relevant only to 80x86 architectures.
+ *
+ * Specify FAR_LEVEL:
+ *   0 -	if using a flat memory model or having no far pointers.
+ *   1 -        if only the socket window may be far
+ *   2 -	if only the socket window and caller's read/write buffers
+ *		may be far.
+ *   3 -	if socket window, caller's read/write buffers and the
+ *		caller's I/O request packet may be far
+ */
+
+#define FAR_LEVEL       0
+
+
+/* 			Memory routines
+ *
+ * You need to supply library routines to copy, set and compare blocks of
+ * memory, internally and to/from callers. The code uses the names 'tffscpy',
+ * 'tffsset' and 'tffscmp' with parameters as in the standard 'memcpy',
+ * 'memset' and 'memcmp' C library routines.
+ */
+
+#if FAR_LEVEL > 0
+#define tffscpy _fmemcpy
+#define tffsset  _fmemset
+#define tffscmp  _fmemcmp
+#else
+/* XXX
+#define tffscpy  sysTffsCpy
+#define tffsset  sysTffsSet
+*/
+#define tffscpy  memcpy
+#define tffsset  memset
+#define tffscmp  memcmp
+#endif
+
+#define tffscpyWords(dest,src,nbytes)     bcopyWords((char *)(src), \
+                                                  (char *)(dest), (nbytes)/2)
+extern int tffscmpWords(void *buf1, void *buf2, int nbytes);
+
+
+/* 			Pointer arithmetic
+ *
+ * The following macros define machine- and compiler-dependent macros for
+ * handling pointers to physical window addresses. The definitions below are
+ * for PC real-mode Borland-C.
+ *
+ * 'physicalToPointer' translates a physical flat address to a (far) pointer.
+ * Note that if when your processor uses virtual memory, the code should
+ * map the physical address to virtual memory, and return a pointer to that
+ * memory (the size parameter tells how much memory should be mapped).
+ *
+ * 'addToFarPointer' adds an increment to a pointer and returns a new
+ * pointer. The increment may be as large as your window size. The code
+ * below assumes that the increment may be larger than 64 KB and so performs
+ * huge pointer arithmetic.
+ */
+
+#if FAR_LEVEL > 0
+#include <dos.h>
+
+#define physicalToPointer(physical,size,drive)		\
+	MK_FP((int) ((physical) >> 4),(int) (physical) & 0xF)
+
+#define addToFarPointer(base,increment)		\
+	MK_FP(FP_SEG(base) +			\
+		((unsigned short) ((FP_OFF(base) + (increment)) >> 16) << 12), \
+	      FP_OFF(base) + (int) (increment))
+#else
+#define physicalToPointer(physical,size,drive)          \
+	((void *) (physical))
+
+#define addToFarPointer(base,increment)		\
+	((void *) ((unsigned char *) (base) + (increment)))
+#endif
+
+
+/* 			Default calling convention
+ *
+ * C compilers usually use the C calling convention to routines (cdecl), but
+ * often can also use the pascal calling convention, which is somewhat more
+ * economical in code size. Some compilers also have specialized calling
+ * conventions which may be suitable. Use compiler switches or insert a
+ * #pragma here to select your favorite calling convention.
+ */
+
+/* use GNU C default calling convention */
+
+
+
+/* 			Mutex type
+ *
+ * If you intend to access the FLite API in a multi-tasking environment,
+ * you may need to implement some resource management and mutual-exclusion
+ * of FLite with mutex & semaphore services that are available to you. In
+ * this case, define here the Mutex type you will use, and provide your own
+ * implementation of the Mutex functions incustom.c
+ *
+ * By default, a Mutex is defined as a simple counter, and the Mutex
+ * functions in custom.c implement locking and unlocking by incrementing
+ * and decrementing the counter. This will work well on all single-tasking
+ * environment, as well as on many multi-tasking environments.
+ */
+
+typedef SEM_ID FLMutex;
+
+#define flStartCriticalSection(mutexPtr)  flTakeMutex(mutexPtr,1)
+#define flEndCriticalSection(mutexPtr)    flFreeMutex(mutexPtr)
+
+
+
+/* 			Memory allocation
+ *
+ * The translation layers (e.g. FTL) need to allocate memory to handle
+ * Flash media. The size needed depends on the media being handled.
+ *
+ * You may choose to use the standard 'malloc' and 'free' to handle such
+ * memory allocations, provide your own equivalent routines, or you may
+ * choose not to define any memory allocation routine. In this case, the
+ * memory will be allocated statically at compile-time on the assumption of
+ * the largest media configuration you need to support. This is the simplest
+ * choice, but may cause your RAM requirements to be larger than you
+ * actually need.
+ *
+ * If you define routines other than malloc & free, they should have the
+ * same parameters and return types as malloc & free. You should either code
+ * these routines in custom.c or include them when you link your application.
+ */
+
+#define MALLOC_TFFS malloc
+#define FREE_TFFS free
+
+/*			isRAM fault safe write
+ * The function isRAM() does a direct write to verify if the location 
+ * specified is RAM. It is possible that hardware is tailered to fault 
+ * in such situations. 
+ */
+
+#ifdef ORIG
+#define ISRAM_WRITE(src,dst) dst = src
+#else /* !ORG */
+#define ISRAM_WRITE(src,dst) \
+	vxMemProbe ((char *)dst, VX_WRITE, 4, (char *)&src)
+#endif /* ORIG */
+
+/*                      Pointer arithmetic
+ *
+ * The following macros define machine- and compiler-dependent macros for
+ * handling pointers to physical window addresses. The definitions below are
+ * for PC real-mode Borland-C.
+ *
+ * 'physicalToPointer' translates a physical flat address to a (far) pointer.
+ * Note that if when your processor uses virtual memory, the code should
+ * map the physical address to virtual memory, and return a pointer to that
+ * memory (the size parameter tells how much memory should be mapped).
+ *
+ * 'addToFarPointer' adds an increment to a pointer and returns a new
+ * pointer. The increment may be as large as your window size. The code
+ * below assumes that the increment may be larger than 64 KB and so performs
+ * huge pointer arithmetic.
+ */
+
+#if FAR_LEVEL > 0
+#include <dos.h>
+
+#define physicalToPointer(physical,size,drive)          \
+        MK_FP((int) ((physical) >> 4),(int) (physical) & 0xF)
+
+/*NEW*/ #define pointerToPhysical(ptr)                  \
+        (((unsigned long) FP_SEG(ptr) << 4) + FP_OFF(ptr))
+
+#define addToFarPointer(base,increment)         \
+        MK_FP(FP_SEG(base) +                    \
+                ((unsigned short) ((FP_OFF(base) + (increment)) >> 16) << 12), \
+        FP_OFF(base) + (int) (increment))
+#else
+#define physicalToPointer(physical,size,drive)          \
+        ((void *) (physical))
+
+/*NEW*/ #define pointerToPhysical(ptr)  ((unsigned long)(ptr))
+
+#define addToFarPointer(base,increment)         \
+        ((void *) ((unsigned char *) (base) + (increment)))
+#endif
+
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/main.c apps_1.2/art/modules/main.c
--- apps/art/modules/main.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/main.c	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,278 @@
+/* main.c main 'C' file for the linux dk driver */
+/*
+                Copyright (c) 2014 Qualcomm Atheros, Inc. All rights reserved.
+                Qualcomm is a trademark of Qualcomm Technologies Incorporated, registered in the United States and other countries.
+                All Qualcomm Technologies Incorporated trademarks are used with permission.
+                Atheros is a trademark of Qualcomm Atheros, Inc., registered in the United States and other countries.
+                Other products and brand names may be trademarks or registered trademarks of their respective owners.
+*/
+
+/* Copyright (c) 2001 Atheros Communications, Inc., All Rights Reserved */
+/*
+                Copyright (c) 2014 Qualcomm Atheros, Inc. All rights reserved.
+                Qualcomm is a trademark of Qualcomm Technologies Incorporated, registered in the United States and other countries.
+                All Qualcomm Technologies Incorporated trademarks are used with permission.
+                Atheros is a trademark of Qualcomm Atheros, Inc., registered in the United States and other countries.
+                Other products and brand names may be trademarks or registered trademarks of their respective owners.
+*/
+
+// Include files
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#include <linux/pci.h>
+#endif
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/page-flags.h>
+#include <asm/io.h>
+#include "dk.h"
+#include "client.h"
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+//#ifdef PCI_BUS
+#include "dk_pci_bus.h"
+//#endif
+#endif
+#define CHIP_ID_LOCATION 0xb8060090
+#define HOWL_WMAC_BASE_PHY_ADDRESS 0x180c0000
+#define MERLIN_PCI_COMMAND_REG_ADDRESS 0xb4000004
+#define SCORPION_PCI_COMMAND_REG_ADDRESS 0xb6000004
+#define VIRIAN_BASE_ADDRESS 0xb80f0000
+#define SCORPION_BASE_ADDRESS 0xb8280000
+#define WASP_WMAC_BASE_PHY_ADDRESS 0x18100000
+#define HORNET_WMAC_BASE_PHY_ADDRESS 0x18100000
+#define PCIE_1_LINK_ADDRESS 0xb80f0018
+#define PCIE_2_LINK_ADDRESS 0xb8280018
+#define CHIP_REV_ID_SCORPION_A 0x013 // last nibble is for Chip revision which is ignored
+#define CHIP_REV_ID_SCORPION_B 0x113 // last nibble is for Chip revision which is ignored
+#define CHIP_REV_ID_DRANGONFLY 0x15  
+extern INT32  dk_dev_init(void);
+#if  defined(P1020)
+extern A_UINT_PTR get_pci_reg_addr();
+#endif
+extern void dk_dev_exit(void);
+extern INT32 get_chip_id(INT32 cli_id,INT32 offset,INT32 size,INT32 *ret_val);
+int init_wmac_device(void);
+static INT32 __init dk_module_init(void)
+{
+		INT32 error;
+#if  defined(P1020)
+
+	A_UINT_PTR baseaddr[1];
+
+	UINT32 len[1];
+	UINT32 irq;
+#ifndef PYTHON_EMU
+	UINT8  csz;
+	UINT32 val;
+#endif
+	UINT32 iIndex, numBars;
+#ifdef DK_DEBUG
+    UINT32 device_id, vendor_id;
+#endif
+	INT8 ret_val;
+	UINT32 sIndex = WMAC_FN_DEV_START_NUM;
+ 	VOID *dev;
+#endif
+#if  !defined(P1020)
+#if  defined(PYTHON_EMU)
+        	UINT32 *addr;
+		INT32 ret_val;
+#endif
+#ifndef OCTEON
+        INT32 chip_rev_id=0;
+#endif
+#ifdef DK_DEBUG
+		printk("DK::Module init \n");
+#endif // DK_DEBUG
+#ifndef OWL_PB42
+        get_chip_id(0,CHIP_ID_LOCATION,4,&chip_rev_id); // for getting the chip rev_id; to differentiate between PB and AP
+        printk("CHIP REV ID: %x\n",chip_rev_id);
+#endif
+#if  defined(PYTHON_EMU)
+	// Scorpion packages A and B (PCIE_2_LINK_ADDRESS is only valid for Scorpion)
+    // Dragonfly has one pcie at PCIE_2_LINK_ADDRESS.
+	if ((((chip_rev_id& 0xfff0)>>4) == CHIP_REV_ID_SCORPION_A)||
+		(((chip_rev_id& 0xfff0)>>4) == CHIP_REV_ID_SCORPION_B)||
+		(((chip_rev_id& 0x0ff0)>>4) == CHIP_REV_ID_DRANGONFLY)){ 
+	          addr = (UINT32 *)(PCIE_2_LINK_ADDRESS);
+	          ret_val = readl(addr);
+		if(ret_val==7){
+	         	printk("Writing value 0x6 to  PCI_2 command register\n");
+	         	addr = (UINT32 *)(SCORPION_PCI_COMMAND_REG_ADDRESS);
+	        	writel(0x6,addr); // enabling ddr and dma of Merlin
+		}else{
+	         	printk("No link on PCIe_2\n");
+		}
+	}
+	if (((chip_rev_id& 0x0ff0)>>4) != CHIP_REV_ID_DRANGONFLY) {
+		addr = (UINT32 *)(PCIE_1_LINK_ADDRESS);
+		ret_val = readl(addr);
+		if(ret_val==7){
+			printk("Writing value 0x6 to PCI_1 command register\n");
+			addr = (UINT32 *)(MERLIN_PCI_COMMAND_REG_ADDRESS);
+			writel(0x6,addr); // enabling ddr and dma of Merlin
+		}else{
+			printk("No link on PCIe_1\n");
+		}
+	}
+	if((chip_rev_id==0x100)||(chip_rev_id==0x1100)||(chip_rev_id==0x101)||(chip_rev_id==0x1101)
+	||(chip_rev_id==0x2120)||(chip_rev_id==0x1120)||(chip_rev_id==0x0120) // Wasp 1.0 package C, B and A
+	||(chip_rev_id==0x2121)||(chip_rev_id==0x1121)||(chip_rev_id==0x0121) // Wasp 1.1 package C, B and A
+	||(chip_rev_id==0x2122)||(chip_rev_id==0x1122)||(chip_rev_id==0x0122) // Wasp 1.2 package C, B and A
+	||(chip_rev_id==0x2123)||(chip_rev_id==0x1123)||(chip_rev_id==0x0123) // Wasp 1.3 package C, B and A
+	||(chip_rev_id==0x12123)||(chip_rev_id==0x11123)||(chip_rev_id==0x10123)) {// Wasp 1.3.0.1 package C, B and A
+	        addr = (UINT32 *)(VIRIAN_BASE_ADDRESS);
+        	writel(readl(addr)& 0xfffeffff,addr);
+	        printk("Resetting bit 16 of VIRIAN register 0xb80f0000\n");
+	} else if (((chip_rev_id& 0xfff0)>>4 == CHIP_REV_ID_SCORPION_A)||((chip_rev_id& 0xfff0)>>4 == CHIP_REV_ID_SCORPION_B)){ // Scorpion packages A and B
+          	addr = (UINT32 *)(PCIE_2_LINK_ADDRESS);
+          	ret_val = readl(addr);
+		if(ret_val==7){
+	        	printk("Bit 16 of 0xb8280000 need not be reset\n");
+		}
+          	addr = (UINT32 *)(PCIE_1_LINK_ADDRESS);
+          	ret_val = readl(addr);
+		if(ret_val==7){
+	        	printk("Resetting bit 16 of VIRIAN register 0xb80f0000\n");
+	        	addr = (UINT32 *)(VIRIAN_BASE_ADDRESS);
+        		writel(readl(addr)& 0xfffeffff,addr);
+		}
+	} else if (((chip_rev_id& 0x0ff0)>>4) == CHIP_REV_ID_DRANGONFLY) {
+			addr = (UINT32 *)(PCIE_2_LINK_ADDRESS);
+			ret_val = readl(addr);
+			if(ret_val==7){
+				printk("Bit 16 of 0xb8280000 need not be reset\n");
+			}
+   	} else {
+                addr = (UINT32 *)(0xb80f001c );
+                writel(readl(addr)& 0xfffeffff,addr);
+                printk("Resetting bit 16 of Python  register 0xb80f001c \n");
+	}
+#endif
+#endif // #if  !defined(P1020)
+
+		error = dk_dev_init();
+		if (error < 0) {
+			printk("DK::Cannot register device \n");
+			return error;
+		}
+		init_client();
+#if  !defined(P1020)
+#ifdef AP83
+                if (init_wmac_device()){ // enabling the wmac ; setting the handle for applications
+                         printk("Error in initializing wmac \n");
+                         return error;
+                }
+#ifndef WASP_OSPREY
+		return 0;
+#endif
+#endif
+#endif
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#if  !defined(P1020)
+		     error = bus_module_init();
+#endif
+#if  defined(P1020)
+	iIndex=0;
+
+	baseaddr[iIndex] = (A_UINT_PTR)get_pci_reg_addr();
+	printk(KERN_ERR" Base Phsycal address :0x%08lx\n", baseaddr[iIndex]);
+
+	len[iIndex] = 0x20000;
+    numBars = 1;
+	irq = 17;
+	sIndex = 0;
+	if (add_client(dev,baseaddr,len,irq, numBars, sIndex,0) < 0) {
+		printk(KERN_ERR "DK:: unable to add client \n");
+#if LINUX_VERSION_CODE > 132098
+//		pci_disable_device(dev);
+#endif
+		return -ENODEV;
+	}
+#endif
+#endif
+#if !defined(OWL_PB42) && !defined(PYTHON_EMU)
+		if (error < 0) {
+			cleanup_client();
+			dk_dev_exit();
+			printk("DK::Cannot locate device. Reset the machine \n");
+			return error;
+		}
+#endif
+		return 0;
+}
+#ifdef AP83
+int init_wmac_device()
+{
+        VOID *dev;
+	UINT32 baseaddr[MAX_BARS];
+	UINT32 len[MAX_BARS];
+	UINT32 irq;
+	UINT32 iIndex, numBars;
+#ifdef DK_DEBUG
+    UINT16 device_id, vendor_id;
+#endif
+	UINT32 sIndex = WMAC_FN_DEV_START_NUM;
+	dev=0;
+for (iIndex=0; iIndex<1; iIndex++) { // assume that only one wmac
+#ifdef WASP
+	  baseaddr[iIndex] =WASP_WMAC_BASE_PHY_ADDRESS;
+#elif HORNET
+	  baseaddr[iIndex] =HORNET_WMAC_BASE_PHY_ADDRESS;
+#else
+	  baseaddr[iIndex] =HOWL_WMAC_BASE_PHY_ADDRESS;
+#endif
+	printk(KERN_ERR" Base Phsycal address :0x%x\n", baseaddr[iIndex]);
+	  len[iIndex] = 0x00ffffff;
+      if (len[iIndex] == 0) break;
+    }
+    numBars = iIndex;
+    irq=2;
+
+if (add_client(dev,(A_UINT_PTR *)baseaddr,len,irq, numBars, sIndex,0) < 0) {
+
+		printk(KERN_ERR "DK:: unable to add client \n");
+#if LINUX_VERSION_CODE > 132098
+		//pci_disable_device(dev);
+                //MKDEV
+                //processEepromWriteByteBasedBlockCmd
+                //pci_enable_device
+#endif
+		return -1;
+	}
+	return 0;
+
+}
+#endif
+
+static void __exit  dk_module_exit(void)
+{
+#ifdef DK_DEBUG
+		printk("DK::Module exit \n");
+#endif // DK_DEBUG
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+
+		bus_module_exit();
+
+#endif
+		cleanup_client();
+		dk_dev_exit();
+		return;
+}
+#ifdef MODULE
+#if LINUX_VERSION_CODE > 132098
+	MODULE_LICENSE(MOD_LICENCE);
+#endif
+MODULE_AUTHOR(MOD_AUTHOR);
+MODULE_DESCRIPTION(MOD_DESCRIPTION);
+module_init(dk_module_init);
+module_exit(dk_module_exit);
+#endif // MODULE
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art/modules/Makefile apps_1.2/art/modules/Makefile
--- apps/art/modules/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art/modules/Makefile	2014-05-30 03:43:44.028942911 -0700
@@ -0,0 +1,55 @@
+EXTRA_CFLAGS += -I$(PWD)/modules/include  -DPCI_BUS -D__KERNEL__ -DMODULE 
+IX_CFLAGS += -I$(ROOTDIR)
+
+ifeq ($(PB42),1)
+EXTRA_CFLAGS += -DOWL_PB42
+endif
+
+
+
+ifeq ($(PYTHON_EMU),1)
+EXTRA_CFLAGS += -DPYTHON_EMU
+endif
+
+ifeq ($(DEBUG),1)
+EXTRA_CFLAGS += -DDK_DEBUG
+endif
+
+ifeq ($(AP83),1)
+EXTRA_CFLAGS += -DAP83
+endif
+
+
+ifeq ($(P1020),1)
+EXTRA_CFLAGS += -DP1020
+endif
+
+ifeq ($(WASP),1)
+EXTRA_CFLAGS += -DAP83
+EXTRA_CFLAGS += -DWASP
+endif
+
+ifeq ($(WASP_OSPREY),1)
+EXTRA_CFLAGS += -DWASP_OSPREY
+endif
+
+ifeq ($(PCI_2),1)
+EXTRA_CFLAGS += -DPCI_2
+endif
+
+ifeq ($(HORNET),1)
+EXTRA_CFLAGS += -DAP83
+EXTRA_CFLAGS += -DHORNET
+endif
+
+ifeq ($(OCTEON),1)
+EXTRA_CFLAGS += -DOCTEON
+endif
+
+obj-m := art.o
+art-objs := dk_func.o client.o main.o dk_pci_bus.o dk_isr.o dk_event.o
+
+clean:
+	rm -rf *.o *.ko .*.cmd *mod.c .tmp_versions
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/makefile.artmod apps_1.2/art_1.2/art/makefile.artmod
--- apps/art_1.2/art/makefile.artmod	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/makefile.artmod	2014-05-30 03:41:19.051257603 -0700
@@ -0,0 +1,116 @@
+KDIR	:= $(KERNELPATH)
+
+PWD	:= $(shell pwd)
+
+ROOTDIR := $(PWD)/modules
+
+
+# Default architecture is MIPS
+ifndef $(KERNELARCH)
+KERNELARCH=mips
+endif
+
+
+ARC = $(KERNELARCH)
+CROSS_CC=$(ARC)-linux-uclibc-
+
+ifeq ($(POWERPC),1)
+ARC     :=powerpc
+CROSS_CC :=powerpc-none-linux-gnuspe-
+endif
+
+
+export KDIR
+
+export ROOTDIR
+
+export CROSS_CC
+
+
+all: default
+
+
+default:
+
+	@echo Making generic AP art module build. This build target is used for 3rd party AP processor. 
+
+	make ARCH=$(ARC) PB42=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+hydra:
+
+	@echo Making art module for Atheros hydra based design.
+
+	make ARCH=$(ARC) PB42=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+howl:
+
+	@echo Making art module for Atheros howl based design.
+
+	make ARCH=$(ARC) AP83=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+python:
+
+	@echo Making art module for Atheros python based design.
+
+	make ARCH=$(ARC) PYTHON_EMU=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+wasp:
+
+	@echo Making art module for Atheros wasp based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+	
+
+honeybee:
+
+	@echo Making art module for Atheros wasp based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules	
+
+
+wasp_osprey:
+
+	@echo Making art module for Atheros wasp-osprey DBSC based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 PYTHON_EMU=1 WASP_OSPREY=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+scorpion:
+
+	@echo Making art module for Atheros wasp based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+scorpion_pci:
+
+	@echo Making art module for Atheros Scorpion-peacock_pci slot 1 or 2 DBSC based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 PYTHON_EMU=1 WASP_OSPREY=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+dragonfly:
+
+	@echo Making art module for Atheros wasp based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+dragonfly_pci:
+
+	@echo Making art module for Atheros dragonfly_pci slot 1 based design.
+
+	make ARCH=$(ARC) AP83=1 WASP=1 PYTHON_EMU=1 WASP_OSPREY=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+p1020:
+	@echo Making art module for Freescale powepc ref resigns
+	make ARCH=$(ARC) PB42=1 P1020=1 DEBUG=$(DEBUG) CROSS_COMPILE=$(CROSS_CC) -C $(KDIR) M=$(PWD)/modules modules
+
+
+clean:
+
+	cd modules && make clean
\ No newline at end of file
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/client.c apps_1.2/art_1.2/art/modules/client.c
--- apps/art_1.2/art/modules/client.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/client.c	2014-05-30 03:41:19.051257603 -0700
@@ -0,0 +1,866 @@
+/* client.c */
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#include <linux/pci.h>
+#endif
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/page-flags.h>
+#include <linux/version.h>
+#include <asm/io.h>
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#ifdef PCI_BUS
+#include "dk_pci_bus.h"
+#endif
+#endif
+
+#include "dk.h"
+#include "dk_ioctl.h"
+#include "dk_event.h"
+#include "client.h"
+
+#define ORDER 9
+#define ORDER_COMM_CLASS 8
+#define ATHEROS_VENDOR_ID 0x168c
+#define HOWL_RTC_BASE_ADDRESS 0xb80e0000
+#define HOWL_WMAC_BASE_VIR_ADDRESS 0xb80c0000
+#define HORNET_RTC_BASE_ADDRESS 0xb8100000
+#define HORNET_WMAC_BASE_VIR_ADDRESS 0xb8100000
+/* global variables */
+#if defined(P1020)
+extern A_UINT_PTR get_pci_virt_addr();
+
+#endif
+static atheros_dev dev_table[MAX_CLIENTS_SUPPORTED];
+static long unsigned int mem_table[MAX_CLIENTS_SUPPORTED];
+static UINT32 mem_page_order[MAX_CLIENTS_SUPPORTED];
+
+/* extern declarations */
+extern irqreturn_t dk_intr_handler(INT32,VOID *,struct pt_regs *);
+
+/* forward declarations */
+static VOID reset_device(INT32 cli_id);
+
+VOID init_client
+(
+ 	VOID
+)
+{
+	UINT32 i;
+
+#ifdef DK_DEBUG
+	printk("DK::Init dev table \n");
+#endif
+
+	for (i=0;i<MAX_CLIENTS_SUPPORTED;i++) {
+			dev_table[i].cli_id = INVALID_CLIENT;
+			mem_table[i] = 0;
+	}
+		
+}
+
+static VOID init_atheros_dev
+(
+ 	p_atheros_dev dev
+)
+{
+        int iIndex;
+
+		dev->bus_dev = NULL;
+		dev->reg_phy_addr = 0;
+		dev->reg_ker_vir_addr = 0;
+		dev->reg_range = 0;
+		dev->mem_phy_addr = 0;
+		dev->mem_ker_vir_addr = 0;
+		dev->mem_size = 0;
+		dev->irq = 0;
+		dev->dev_busy = 0;
+		dev->cli_id = INVALID_CLIENT;
+		memset(&dev->isr_event_q,0,sizeof(event_queue));
+		memset(&dev->trigered_event_q,0,sizeof(event_queue));
+        for(iIndex=0; iIndex<MAX_BARS; iIndex++) {
+		     dev->areg_phy_addr[iIndex] = 0;
+		     dev->areg_ker_vir_addr[iIndex] = 0;
+		     dev->areg_range[iIndex] = 0;
+        }
+}
+
+/*
+ * Get the client for this device
+ * The table give the mapping between the device and the client 
+ * in the dev_table. The minor number is used to idenitfy the client
+ * for the device.
+ *  Device    client       minor 
+ * /dev/dk0 - dev_table[0]   0
+ * /dev/dk1 - dev_table[1]   1
+ * /dev/dk2 - dev_table[2]   2
+ * /dev/dk3 - dev_table[3]   3
+ */
+static INT32 get_client_id
+(
+ 	INT32 major,
+ 	INT32 minor
+)
+{
+#ifdef DK_DEBUG
+	printk("DK::get_client_id:major=%d:minor=%d\n", major, minor);
+#endif
+	if (major == DK_UART_MAJOR_NUMBER) {
+		return dev_table[minor + UART_FN_DEV_START_NUM].cli_id;
+	}
+	else
+		return dev_table[minor].cli_id;
+}
+
+p_atheros_dev get_client
+(
+ 	INT32 cli_id
+)
+{
+	p_atheros_dev dev;
+
+	dev = &dev_table[cli_id];
+	if (!VALID_CLIENT(dev))  {
+		return NULL;
+	}
+
+	return dev;
+}
+
+INT32 add_client
+(
+ 	VOID *bus_dev,
+	A_UINT_PTR baseaddr[MAX_BARS],
+	UINT32 len[MAX_BARS],
+	UINT32 irq,
+    UINT32 numBars,
+    UINT32 sIndex,
+    int pci
+)
+{
+		UINT32 i;
+		INT32 cli_id;
+		p_atheros_dev dev;
+		A_UINT_PTR reg_vir_addr[MAX_BARS];
+		A_UINT_PTR mem_phy_addr;
+		long unsigned int *mem;
+		struct page *page;
+		UINT32 no_pages, iIndex;
+
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+        INT8 ret_val;
+#endif
+        UINT32 page_order=ORDER;
+#if defined(OCTEON)
+        dma_addr_t dma_handle;
+#endif
+
+
+		dev = NULL;
+		mem = NULL;
+		cli_id = INVALID_CLIENT;
+		mem_phy_addr = 0;
+
+		for (i=sIndex;i<MAX_CLIENTS_SUPPORTED;i++) {
+				if (dev_table[i].cli_id == INVALID_CLIENT) {
+						cli_id = i;
+						dev = &dev_table[i];
+						mem = &mem_table[i];
+						break;
+				}
+		}
+
+		if (cli_id == INVALID_CLIENT) {
+			printk("DK:: Only %d clients supported \n",MAX_CLIENTS_SUPPORTED);
+			return -1;
+		}
+		
+		printk("DK::Add client %d \n",cli_id);
+
+		init_atheros_dev(dev);		
+
+        for(iIndex=0; iIndex<numBars; iIndex++) {
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#if defined(P1020)
+
+                      reg_vir_addr[iIndex] = (A_UINT_PTR)get_pci_virt_addr();
+
+			printk(KERN_ERR" Reg Virtual address :0x%08lx\n", reg_vir_addr[iIndex]);
+#endif
+if(pci){
+            (void)pci_read_config_byte(bus_dev, PCI_BASE_ADDRESS_0 + (iIndex *4), &ret_val);
+            if (ret_val&0x1) {
+               // IO region mapping
+               /*
+		       printk("DK:: Requesting IO region=%x:range=%d\n", baseaddr[iIndex], len[iIndex]);
+		       if (request_region(baseaddr[iIndex],len[iIndex],DRV_NAME) == NULL) {
+		          printk(KERN_ERR "DK:: unable to request io region for Bar %d: len = %d\n", iIndex, len[iIndex]);
+				  return -1;
+	           }
+               */
+            }
+            else {
+
+		      printk("DK:: Requesting MEM region=%lx:range=%d\n", baseaddr[iIndex], len[iIndex]);
+
+		      if (request_mem_region(baseaddr[iIndex],len[iIndex],DRV_NAME) == NULL) {
+		          printk(KERN_ERR "DK:: unable to request mem region for Bar %d: len = %d\n", iIndex, len[iIndex]);
+				  return -1;
+	          }
+
+                      reg_vir_addr[iIndex] = (A_UINT_PTR)ioremap_nocache(baseaddr[iIndex],len[iIndex]);
+                      if ((VOID *)reg_vir_addr[iIndex] == NULL) {
+                                free_irq(irq,(void *)dev);
+                                for(iIndex=0; iIndex<numBars; iIndex++) {
+                                          iounmap((VOID *)reg_vir_addr[iIndex]);
+                                          //release_mem_region(baseaddr[iIndex],len[iIndex]);
+                                }
+                                printk(KERN_ERR "DK:: unable to remap registers \n");
+                                return -1;
+                      }
+            }
+}
+#endif
+#ifdef AP83
+if(!pci){
+		      reg_vir_addr[iIndex] = (UINT32)ioremap_nocache(baseaddr[iIndex],len[iIndex]);
+		      if ((VOID *)reg_vir_addr[iIndex] == NULL) {
+				free_irq(irq,(void *)dev);
+                                for(iIndex=0; iIndex<numBars; iIndex++) {
+			        	  iounmap((VOID *)reg_vir_addr[iIndex]);
+		        	  	  //release_mem_region(baseaddr[iIndex],len[iIndex]);
+                                }   
+				printk(KERN_ERR "DK:: unable to remap registers \n");
+				return -1;
+		      }
+}
+#endif
+        } // end of for
+
+		   /* Pass the pointer to the client id */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+		   if (request_irq(irq,(void *)dk_intr_handler,SA_SHIRQ,DRV_NAME,(void *)dev) != 0) {
+#else
+		   if (request_irq(irq,(void *)dk_intr_handler,IRQF_SHARED,DRV_NAME,(void *)dev) != 0) {
+#endif
+              for(iIndex=0; iIndex<numBars; iIndex++) {
+				iounmap((VOID *)reg_vir_addr[iIndex]);
+				release_mem_region(baseaddr[iIndex],len[iIndex]);
+              }
+		        printk(KERN_ERR "DK:: unable to request irq \n");
+				return -1;
+		   }
+
+
+        for(iIndex=0; iIndex<numBars; iIndex++) {
+   
+		printk("DK::Reg phy addr = %lx vir Addr = %lx \n",baseaddr[iIndex],reg_vir_addr[iIndex]);
+
+        }
+		printk("DK::Irq = %x \n",irq);
+
+
+		if (*mem == 0) {
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#if defined (P1020)
+
+		    *mem = __get_free_pages(GFP_KERNEL|GFP_DMA,ORDER);
+                    page_order = ORDER;
+#endif
+if(pci){
+                (void)pci_read_config_byte(bus_dev, 0xb, &ret_val);
+                if (ret_val == SIMPLE_COMM_CLASS) {
+				    *mem = __get_free_pages(GFP_KERNEL,ORDER_COMM_CLASS);
+                    page_order = ORDER_COMM_CLASS;
+                }
+                else {
+				    *mem = __get_free_pages(GFP_KERNEL|GFP_DMA,ORDER);
+				      //*mem = ioremap_nocache(0xf00000, 0x100000);
+                    page_order = ORDER;
+                }
+}
+#endif
+#ifdef AP83
+if(!pci){
+                    *mem = __get_free_pages(GFP_KERNEL|GFP_DMA,ORDER);
+                    page_order = ORDER;
+
+}
+#endif
+		if (*mem == 0) {
+                    for(iIndex=0; iIndex<numBars; iIndex++) {
+					   iounmap((VOID *)reg_vir_addr[iIndex]);
+					   free_irq(irq,(void *)dev);
+					   release_mem_region(baseaddr[iIndex],len[iIndex]);
+                    }
+					   printk(KERN_ERR "DK:: unable to allocate contigous memory \n");
+					   return -1;
+		}
+				// map the pages as reserved,
+				// otherwise remap_page_range wont 
+				// do what we expect
+
+				page =  virt_to_page((void *)(*mem));
+				no_pages = 1 << page_order;
+                		mem_page_order[cli_id] = page_order;
+				for (i=0;i<no_pages;i++) {
+					SetPageReserved(page);
+					page++;
+				}
+				
+				printk("DK::Allocated 0x%x bytes memory \n", (UINT32) (PAGE_SIZE * (1<<page_order)));
+		} else {
+				printk("DK::Using memory already allocated at %lx \n",*mem);
+		}
+#if defined(OCTEON)
+                mem_phy_addr = virt_to_phys(pci_alloc_consistent(bus_dev, PAGE_SIZE * (1<<page_order), &dma_handle));
+		printk("DK::DMA addr 0x%lx, mem phy addr %lx\n", dma_handle, mem_phy_addr);
+#else
+                mem_phy_addr = __pa(*mem);
+#endif
+		printk("DK::memory vir Addr = %lx phy Addr = %lx \n",*mem,mem_phy_addr);
+
+		/* 
+		 * TO DO: (if necessary)
+		 * Kernel already has a mapping for this physical pages. 
+		 * They are part of the identity mapping, so they may be 
+		 * cached. Remap it to another virtual address space 
+		 * if the memory will be accessed from the kernel
+		 */
+		
+		dev->bus_dev = bus_dev;
+        for(iIndex=0; iIndex<numBars; iIndex++) {
+		   dev->areg_phy_addr[iIndex] = baseaddr[iIndex];
+		   dev->areg_ker_vir_addr[iIndex] = reg_vir_addr[iIndex];
+		   dev->areg_range[iIndex] = len[iIndex];
+        }
+		dev->reg_phy_addr = baseaddr[0];
+		dev->reg_ker_vir_addr = reg_vir_addr[0];
+		dev->reg_range = len[0];
+        	dev->numBars = numBars;
+		dev->mem_ker_vir_addr = *mem;
+		dev->mem_phy_addr = mem_phy_addr;
+		dev->mem_size = (1 << page_order) * PAGE_SIZE;
+		dev->irq = irq;
+		dev->cli_id = cli_id;
+#if defined(OCTEON)
+        dev->dma_mem_addr = dma_handle;
+#endif 
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+if(pci){
+		cli_cfg_read(cli_id,8,4,&dev->device_class);
+}
+#endif 
+        	dev->device_class >>= 24;
+
+		reset_device(cli_id);
+		return 0;
+}
+
+
+VOID remove_client
+(
+ 	VOID *bus_dev
+)
+{
+		UINT32 i, iIndex;
+		p_atheros_dev dev;
+
+		printk("DK::Remove client \n");
+
+		dev = NULL;
+		for (i=0;i<MAX_CLIENTS_SUPPORTED;i++) {
+				if (dev_table[i].cli_id == INVALID_CLIENT) continue;
+			   	if (dev_table[i].bus_dev == bus_dev) {
+						dev = &dev_table[i];
+						break;
+				}
+		}
+		
+		if (dev == NULL) {
+			printk("DK:: Invalid client in remove_client \n");
+			return;
+		}
+		
+		reset_device(dev->cli_id);
+
+        for(iIndex=0; iIndex<dev->numBars; iIndex++) {
+		    iounmap((VOID *)dev->areg_ker_vir_addr[iIndex]);
+		    release_mem_region(dev->areg_phy_addr[iIndex], dev->areg_range[iIndex]);
+		    printk("DK::Free reg space phy=%lx vir=%lx \n",dev->areg_phy_addr[iIndex],dev->areg_ker_vir_addr[iIndex]);
+        }
+		
+		free_irq(dev->irq,(void *)dev);
+		printk("DK::Free irq = %x \n",dev->irq);
+
+		init_atheros_dev(dev);		
+
+		return;
+}
+
+
+VOID cleanup_client
+(
+ 	VOID
+)
+{
+		UINT32 i;
+		UINT32 j;
+		struct page *page;
+		UINT32 no_pages;
+
+#ifdef DK_DEBUG
+		printk("DK::Cleanup dev table \n");
+#endif // DK_DEBUG
+		for (i=0;i<MAX_CLIENTS_SUPPORTED;i++) {
+				if (dev_table[i].cli_id != INVALID_CLIENT) {
+						remove_client(dev_table[i].bus_dev);
+						dev_table[i].cli_id = INVALID_CLIENT;
+				}
+				if (mem_table[i] != 0) {
+						printk("DK::Freeing memory at %lx \n",mem_table[i]);
+						// remove the reserved flag
+						
+						page = virt_to_page((void *)mem_table[i]);
+						no_pages = 1 << mem_page_order[i];
+                        printk("page order=%d\n", mem_page_order[i]);
+						for (j=0;j<no_pages;j++) {
+							 ClearPageReserved(page);
+							page++;
+						}
+						
+						free_pages(mem_table[i],8);
+						mem_table[i] = 0;
+				}
+		}
+		return;
+}
+
+INT32 register_client
+(
+ 	INT32 major,
+ 	INT32 minor
+)
+{
+	INT32 cli_id;
+	p_atheros_dev dev;
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+	UINT32 vendor_id;
+#endif
+	/* get the client for this device */
+	cli_id = get_client_id(major, minor);
+
+	if (cli_id == INVALID_CLIENT) {
+		printk("DK::register_client:Device not found \n");
+	 	return -ENODEV;
+	}
+
+	printk("DK::Regsitering client %d \n",cli_id);
+	dev = &dev_table[cli_id];
+
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::register_client:Invalid client \n");
+	 	return -ENODEV;
+    }
+
+	if (BUSY_CLIENT(dev)) {
+		printk("DK::register_client:Client alreay in use \n");
+		return -EACCES;
+	}
+#if !defined (P1020)	
+
+	// check whether the device is present
+	// by reading the vendor id
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#ifdef WASP_OSPREY
+   if(cli_id!=0){ // For DBDC operation, Wasp radio's client ID is zero; 
+#endif
+	cli_cfg_read(cli_id,0,4,&vendor_id);
+	if ((vendor_id & 0xffff) != ATHEROS_VENDOR_ID) {
+		printk("DK::Device not present \n");
+	 	return -ENODEV;
+	}
+
+#ifdef WASP_OSPREY
+   }
+#endif
+#ifndef PYTHON_EMU
+	if (bus_dev_init(dev->bus_dev) < 0) {
+		printk("DK::register_client:Cannot initialize client \n");
+		return -EACCES;
+	}
+#endif
+#endif
+#endif
+	initEventQueue(&dev->isr_event_q);
+	initEventQueue(&dev->trigered_event_q);
+	
+	reset_device(cli_id);
+					
+	dev->dev_busy = 1;
+				  
+	return dev->cli_id;
+}
+
+VOID unregister_client
+(
+ 	INT32 cli_id
+)
+{
+	p_atheros_dev dev;
+
+	printk("DK::Unregsitering client %d \n",cli_id);
+	
+	dev = &dev_table[cli_id];
+
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::unregister_client:Invalid client \n");
+	 	return;
+    }
+	if (!BUSY_CLIENT(dev)) {
+		printk("DK::unregister_client:Client not registered \n");
+		return;
+	}
+	
+	reset_device(dev->cli_id);
+	
+	deleteEventQueue(&dev->isr_event_q);
+	deleteEventQueue(&dev->trigered_event_q);
+#if defined(OWL_PB42) || defined(PYTHON_EMU)	
+	bus_dev_exit(dev->bus_dev);
+#endif
+	dev->dev_busy = 0;
+	
+	return;
+}
+
+INT32 cli_reg_read
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	UINT32 *data
+)
+{
+	p_atheros_dev dev;
+	UINT32 *addr;
+	
+	dev = &dev_table[cli_id];
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::reg_read:Invalid client \n");
+	 	return -1;
+    }
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+	addr = (UINT32 *)(dev->areg_ker_vir_addr[0] + offset);
+#endif
+#ifdef AP83
+#ifndef WASP_OSPREY
+	#ifdef HORNET
+        addr = (UINT32 *)(HORNET_WMAC_BASE_VIR_ADDRESS + offset);
+	#else
+        addr = (UINT32 *)(HOWL_WMAC_BASE_VIR_ADDRESS + offset);
+	#endif        
+#endif
+#endif
+	*data = readl(addr);
+#ifdef DK_DEBUG
+	printk("DK::Reg read @ 0x%08lx : 0x%04x \n",(A_UINT_PTR)addr,*data);
+#endif
+
+	return 0;
+}
+
+INT32 cli_reg_write
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	UINT32 data
+)
+{
+	p_atheros_dev dev;
+	UINT32 *addr;
+
+	dev = &dev_table[cli_id];
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::reg_write:Invalid client \n");
+	 	return -1;
+    }
+#if defined(OWL_PB42) || defined(PYTHON_EMU)	
+	addr = (UINT32 *)(dev->areg_ker_vir_addr[0] + offset);
+#endif
+#ifdef AP83
+#ifndef WASP_OSPREY
+	#ifdef HORNET
+        addr = (UINT32 *)(HORNET_WMAC_BASE_VIR_ADDRESS + offset);
+	#else
+        addr = (UINT32 *)(HOWL_WMAC_BASE_VIR_ADDRESS + offset);
+	#endif        
+#endif
+#endif
+	writel(data,addr);
+#ifdef DK_DEBUG
+	printk("DK::Reg write @ 0x%08lx : 0x%04x \n",(A_UINT_PTR)addr,data);
+#endif
+
+	return 0;
+}
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+INT32 cli_cfg_read
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	INT32 size,
+	INT32 *ret_val
+)
+{
+	p_atheros_dev dev;
+
+	dev = &dev_table[cli_id];
+	
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::cfg_read:Invalid client \n");
+	 	return -1;
+    }
+	
+	return bus_cfg_read(dev->bus_dev,offset,size,ret_val);
+}
+#endif
+
+#if defined(AP83) || defined(PYTHON_EMU)
+INT32 full_addr_read
+(
+        INT32 cli_id,           
+        INT32 offset,                   
+        INT32 *ret_val                  
+)                               
+{
+        p_atheros_dev dev;      
+        UINT32 *addr;           
+
+        dev = &dev_table[cli_id];
+        if (!VALID_CLIENT(dev)) {
+                printk("DK::rtc_reg_read:Invalid client \n");
+                return -1;      
+    }                                           
+          addr = (UINT32 *)(0x00000000+offset);
+          *ret_val = readl(addr);
+          return 0;
+                                
+} 
+INT32 full_addr_write
+(
+        INT32 cli_id,
+        INT32 offset,
+        UINT32 data
+)
+{
+        p_atheros_dev dev;
+        UINT32 *addr;
+
+        dev = &dev_table[cli_id];
+        if (!VALID_CLIENT(dev)) {
+                printk("DK::reg_write:Invalid client \n");
+                return -1;
+        }
+
+        addr = (UINT32 *)(0x000000 + offset);
+        writel(data,addr);
+
+
+        return 0;
+}
+#endif
+
+#if !defined(OCTEON) 
+INT32 rtc_reg_read
+(
+        INT32 cli_id,           
+        INT32 offset,                   
+        INT32 *ret_val                  
+)                               
+{
+        p_atheros_dev dev;      
+        UINT32 *addr;           
+
+        dev = &dev_table[cli_id];
+        if (!VALID_CLIENT(dev)) {
+                printk("DK::rtc_reg_read:Invalid client \n");
+                return -1;      
+    }                                           
+			#ifdef HORNET
+          addr = (UINT32 *)(HORNET_RTC_BASE_ADDRESS+offset);
+			#else
+          addr = (UINT32 *)(HOWL_RTC_BASE_ADDRESS+offset);
+			#endif          
+          *ret_val = readl(addr);
+          return 0;
+                                
+} 
+
+INT32 get_chip_id                     
+(                               
+        INT32 cli_id,                   
+        INT32 offset,           
+        INT32 size,             
+        INT32 *ret_val          
+)                       
+{                               
+        p_atheros_dev dev;                      
+        UINT32 *addr;           
+        dev = &dev_table[cli_id];
+                                        
+        if (!VALID_CLIENT(dev)) { 
+                printk("DK::cfg_read:Invalid client \n");
+                return -1;      
+    }                           
+          addr = (UINT32 *)(0x00000000+offset);
+          *ret_val = readl(addr);               
+          return 0;             
+                                
+}
+
+INT32 rtc_reg_write
+(
+        INT32 cli_id,
+        INT32 offset,
+        UINT32 data
+)
+{
+        p_atheros_dev dev;
+        UINT32 *addr;
+
+        dev = &dev_table[cli_id];
+        if (!VALID_CLIENT(dev)) {
+                printk("DK::reg_write:Invalid client \n");
+                return -1;
+        }
+
+			#ifdef HORNET
+        addr = (UINT32 *)(HORNET_RTC_BASE_ADDRESS + offset);
+			#else
+        addr = (UINT32 *)(HOWL_RTC_BASE_ADDRESS + offset);
+			#endif        
+        writel(data,addr);
+
+
+        return 0;
+}
+#endif  //end OCTEON def
+
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)  
+INT32 cli_cfg_write
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	INT32 size,
+	INT32 ret_val
+)
+{
+	p_atheros_dev dev;
+	
+	dev = &dev_table[cli_id];
+	
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::cfg_write:Invalid client \n");
+	 	return -1;
+    }
+	
+	return bus_cfg_write(dev->bus_dev,offset,size,ret_val);
+}
+#endif
+
+
+INT32 get_cli_info
+(
+ 	INT32 cli_id,
+	struct client_info *ci
+)
+{
+	p_atheros_dev dev;
+    int iIndex;
+	
+	dev = &dev_table[cli_id];
+	
+	if (!VALID_CLIENT(dev)) {
+		printk("DK::get_client_info:Invalid client \n");
+	 	return -1;
+    }
+	
+	ci->reg_phy_addr = dev->areg_phy_addr[0];
+	ci->reg_range = dev->areg_range[0];
+    for (iIndex=0; iIndex<dev->numBars; iIndex++) {
+	   ci->areg_phy_addr[iIndex] = dev->areg_phy_addr[iIndex];
+	   ci->areg_range[iIndex] = dev->areg_range[iIndex];
+    }
+    ci->numBars = dev->numBars;
+	ci->mem_phy_addr = dev->mem_phy_addr;
+	ci->mem_size = dev->mem_size;
+	ci->irq = dev->irq;
+    ci->device_class = dev->device_class;
+    ci->dma_mem_addr = dev->dma_mem_addr;
+
+	return 0;
+}
+
+static VOID reset_device
+(
+ 	INT32 cli_id
+)
+{
+	UINT32 out;
+#ifdef DK_DEBUG
+	printk("DK::Disable the interrupts and reset the device \n");	
+#ifdef PYTHON_EMU
+	cli_reg_read(cli_id, 0x4020, &out);
+	printk("Device Mac Rev : 0x%x\n",out);			
+#endif 
+#endif
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+	if (dev_table[cli_id].device_class == NETWORK_CLASS) {
+	   // disable interrupts 	
+	   cli_reg_write(cli_id,0x0024,0x0);
+	   // put the device in reset state		
+	   cli_reg_write(cli_id,0x704c,0x1); 				
+	   cli_reg_write(cli_id,0x7040,0x0); 				
+	   cli_reg_write(cli_id,0x7040,0x1); 	
+
+	   cli_reg_read(cli_id, 0x7044, &out);
+	   printk("Device Status is : 0x%x\n",out);			
+	}
+	if (dev_table[cli_id].device_class == SIMPLE_COMM_CLASS) {
+	   cli_reg_write(cli_id,0x4,0x0); // IER
+	   cli_reg_write(cli_id,0x114,0x0); // Extended IER
+	   cli_reg_write(cli_id,0x104,0x1); // RC
+	}
+#endif
+#ifdef AP83
+#ifndef WASP
+        //if (dev_table[cli_id].device_class == NETWORK_CLASS) {
+           // disable interrupts
+           cli_reg_write(cli_id,0x0024,0x0);
+           // put the device in reset state
+           rtc_reg_write(cli_id,0x004c,0x1);
+           rtc_reg_write(cli_id,0x0040,0x0);
+           rtc_reg_write(cli_id,0x0040,0x1);
+
+           rtc_reg_read(cli_id, 0x0044, &out);
+           printk("Device Status is : 0x%x\n",out);
+
+//}
+        /*if (dev_table[cli_id].device_class == SIMPLE_COMM_CLASS) {
+           cli_reg_write(cli_id,0x4,0x0); // IER
+           cli_reg_write(cli_id,0x114,0x0); // Extended IER
+           cli_reg_write(cli_id,0x104,0x1); // RC
+        }*/
+
+
+#endif
+#endif
+
+
+	return;
+}	
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/dk_event.c apps_1.2/art_1.2/art/modules/dk_event.c
--- apps/art_1.2/art/modules/dk_event.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/dk_event.c	2014-05-30 03:43:07.296515324 -0700
@@ -0,0 +1,363 @@
+/* anwievent.c - functions for event handling */
+
+
+/*
+                Copyright (c) 2014 Qualcomm Atheros, Inc. All rights reserved.
+                Qualcomm is a trademark of Qualcomm Technologies Incorporated, registered in the United States and other countries.
+                All Qualcomm Technologies Incorporated trademarks are used with permission.
+                Atheros is a trademark of Qualcomm Atheros, Inc., registered in the United States and other countries.
+                Other products and brand names may be trademarks or registered trademarks of their respective owners.
+*/
+
+/*
+DESCRIPTION
+Contains low level functions for event handling.
+*/
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+
+
+#include "dk_event.h"
+
+//void acquireLock(p_event_queue);
+//void releaseLock(p_event_queue);
+
+
+
+spinlock_t driver_lock = SPIN_LOCK_UNLOCKED;
+
+
+// initEventQueue - initialize an event queue
+void initEventQueue(p_event_queue pQueue) 
+{
+	pQueue->pHead = pQueue->pTail = NULL;
+	pQueue->queueSize = 0;
+	return;
+}
+
+
+// deleteEventQueue - delete and cleanup a created event queue
+// This routine will remove and delete all the event structures in the 
+// queue. Performs any other cleanup  needed
+// RETURNS: N/A
+void deleteEventQueue(p_event_queue pQueue)
+{
+	p_event_struct pNextEvent;
+	if (!pQueue) {
+		return;
+	}
+
+	// acquireLock(pQueue);
+	spin_lock_irq(&driver_lock);
+    
+	// cleanup the events in the queue 
+	while (pQueue->pHead) {
+		pNextEvent = pQueue->pHead->pNext;
+		kfree(pQueue->pHead);
+#ifdef DK_DEBUG
+		printk("DK::Free event = %lx \n",(A_UINT_PTR)pQueue->pHead);
+#endif
+		pQueue->queueSize--;
+		pQueue->pHead = pNextEvent;
+	}
+
+//	releaseLock(pQueue);
+	spin_unlock_irq(&driver_lock);
+
+	return;
+}
+
+
+/**************************************************************************
+* createEvent - Create an event
+*
+* This routine will allocate memory for an event and perform any 
+* initialization.  Note that this does not add the event to any Q
+*
+* RETURNS: pointer to the event of NULL if error
+*/
+p_event_struct createEvent
+(
+	UINT32 type,          /* the event ID */
+	UINT32 persistent,    /* set if want a persistent event */
+	UINT32 param1,        /* optional args */
+	UINT32 param2,
+	UINT32 param3,
+	event_handle eventHandle  
+)
+{
+	p_event_struct pEvent;    
+	UINT32	i;
+
+	pEvent = (p_event_struct)kmalloc(sizeof(event_struct),GFP_KERNEL);
+#ifdef DK_DEBUG
+	printk("DK::Create Event:Event Ptr = %x \n",(UINT32)pEvent);
+#endif
+
+	if(!pEvent) {
+		printk("DK:: Unable to allocate memory in createEvent()!\n");
+		return(NULL);
+	}
+
+	// perform initialization of members 
+	pEvent->type = type;
+	pEvent->persistent = persistent;
+	pEvent->param1 = param1;
+	pEvent->param2 = param2;
+	pEvent->param3 = param3;
+	pEvent->pNext = NULL;
+	pEvent->pLast = NULL;
+	for (i=0;i<6;i++) {
+		pEvent->result[i]=0;
+	}
+
+	pEvent->eventHandle = eventHandle;
+
+	return(pEvent);
+}
+
+/* copyEvent - Copy an event struct
+*
+* This routine will allocate memory for a new event and copy member 
+* variables from existing event into new event
+*
+* RETURNS: pointer to the event of NULL if error
+*/
+p_event_struct copyEvent
+(
+	p_event_struct pExistingEvent     /* pointer to event to copy */
+)
+{
+	p_event_struct pNewEvent;    /* pointer to event struct created */
+	UINT32 i;
+
+	if(!pExistingEvent) {
+		printk("DK::Illegal pointer passed to copyEvent!\n");
+		return(NULL);
+	}
+    
+	//pNewEvent = (p_event_struct)kmalloc(sizeof(event_struct),GFP_KERNEL);
+	pNewEvent = (p_event_struct)kmalloc(sizeof(event_struct),GFP_ATOMIC);
+#ifdef DK_DEBUG
+	printk("DK::Copy Event:Event Ptr = %lx \n",(A_UINT_PTR)pNewEvent);
+#endif
+
+
+	if(!pNewEvent) {
+		printk("Error: Unable to allocate memory for new event!\n");
+		return(NULL);
+	}
+
+	pNewEvent->type = pExistingEvent->type;
+	pNewEvent->persistent = pExistingEvent->persistent;
+	pNewEvent->param1 = pExistingEvent->param1;
+	pNewEvent->param2 = pExistingEvent->param2;
+	pNewEvent->param3 = pExistingEvent->param3;
+	pNewEvent->pNext = NULL;
+	pNewEvent->pLast = NULL;
+
+	for (i=0;i<6;i++) {
+		pNewEvent->result[i]=pExistingEvent->result[i];
+	}
+
+	pNewEvent->eventHandle.eventID = pExistingEvent->eventHandle.eventID;
+	pNewEvent->eventHandle.f2Handle = pExistingEvent->eventHandle.f2Handle;
+
+	return(pNewEvent);
+}
+
+/**************************************************************************
+* pushEvent - Put event at tail of eventQueue
+*
+* This routine will put the supplied event at the end of the specified Q.
+* don't want any other threads accessing the Q while doing this, so need
+* to obtain the Q mutex to be able to perform this operation
+*
+* RETURNS: 1 if successful, 0 if not
+*/
+UINT16 pushEvent
+(
+	p_event_struct pEvent,   // pointer to event to add 
+	p_event_queue pQueue,    // pointer to queue to add 
+	BOOLEAN        protect      
+)
+{
+	if(!pQueue || !pEvent) {
+		printk("DK::illegal pointer passed to pushEvent()!\n");
+		return(0);
+	}
+
+	if (protect) {
+		// acquireLock(pQueue);
+		spin_lock_irq(&driver_lock);
+	}
+
+	// add the event to the tail 
+	if (NULL == pQueue->pHead) {
+		// queue is empty, this will be the first item 
+		pQueue->pHead = pEvent;
+		pQueue->pTail = pEvent;    
+	} else {
+		pQueue->pTail->pNext = pEvent;
+		pEvent->pLast = pQueue->pTail;
+		pQueue->pTail = pEvent;
+	}
+	pQueue->queueSize++;
+
+	if (protect) {
+		//releaseLock(pQueue);
+		spin_unlock_irq(&driver_lock);
+	}
+
+	return(1);
+}
+
+/**************************************************************************
+* popEvent - Pop an event from eventQueue head
+*
+* This routine will pop an event from the head of the specified Q.
+* Don't want any other threads accessing the Q while doing this, so need
+* to obtain the Q mutex to be able to perform this operation.
+*
+* RETURNS: pointer to event that was poped, null if fail
+*/
+p_event_struct popEvent
+(
+	p_event_queue pQueue,        // pointer to queue to add to 
+	BOOLEAN        protect      
+)
+{
+	p_event_struct pEvent;        // event that will be poped from queue 
+   
+	if (protect) { 
+		// acquireLock(pQueue);
+		spin_lock_irq(&driver_lock);
+	}
+
+    // get the event from head and update pointers 
+	pEvent = pQueue->pHead;
+	if (pEvent) {
+		pQueue->pHead = pEvent->pNext;    
+		pEvent->pNext = NULL;            
+
+		if(!pQueue->pHead) {
+			// queue is now empty to make tail also null 
+			pQueue->pTail = NULL;
+		} else {
+			pQueue->pHead->pLast = NULL;    // head has no previous link 
+		}
+		pQueue->queueSize--;
+	}
+
+	if (protect) {
+		//releaseLock(pQueue);
+		spin_unlock_irq(&driver_lock);
+	}
+
+    return(pEvent);
+}
+
+
+/**************************************************************************
+* removeEvent - remove an event from eventQueue (anywhere)
+*
+* This routine will remove an event from anywhere (ie middle) in Q.
+* The event to be removed is passed in.
+*
+* RETURNS: 1 if removed, 0 if not
+*/ 
+UINT16 removeEvent
+(
+	p_event_struct pEvent, // event that will be removed from queue 
+	p_event_queue pQueue, // pointer to queue to add to 
+	BOOLEAN        protect      
+)
+{
+	if(!pQueue || !pEvent) {
+		printk("DK::illegal pointer passed to removeEvent()\n");
+		return(0);
+        }
+
+	if(protect) {
+		// acquireLock(pQueue);
+		spin_lock_irq(&driver_lock);
+	}
+
+	// first take care of previous member's forward link
+	if ( pEvent->pLast ) {
+		// this is not the head
+		pEvent->pLast->pNext = pEvent->pNext;
+	} else {
+		// this is the head
+		pQueue->pHead = pEvent->pNext;
+	}
+
+	// next take care of next member's backward link
+	if ( pEvent->pNext ) {
+		// this is not the tail
+		pEvent->pNext->pLast = pEvent->pLast;
+	} else {
+		// this is the tail
+		pQueue->pTail = pEvent->pLast;
+	}	
+
+	// clear event to be no longer linked 
+	pEvent->pLast = NULL;
+	pEvent->pNext = NULL;
+	pQueue->queueSize--;
+
+	// release the mutex 
+	if(protect) {
+		//releaseLock(pQueue);
+		spin_unlock_irq(&driver_lock);
+	}
+
+	return(1);
+}
+
+/**************************************************************************
+* CheckForEvents - Check if queue has any events
+*
+* This routine will check to see if an event queue has any events in it.
+* Need this to be a mutually exclusive operation so need to get mutex
+*
+* RETURNS: Return 1 if events, 0 if not or there are errors
+*/
+UINT16 checkForEvents
+(
+	p_event_queue pQueue,    // Pointer to event queue to start scan 
+	BOOLEAN        protect      
+)
+{
+	UINT16    returnValue;
+
+	if (!pQueue) {
+		printk("DK::illegal pointer passed to checkForEvents()\n");
+		return(0);
+	}
+
+	if (protect) {
+//		acquireLock(pQueue);
+		spin_lock_irq(&driver_lock);
+		
+	}
+
+	if(!pQueue->pHead) {
+		returnValue = 0; // queue is empty, there are no events 
+	} else {
+		returnValue = 1; // queue contains events 
+	}
+
+	if (protect) {
+//		releaseLock(pQueue);
+		spin_unlock_irq(&driver_lock);
+	}
+
+	return(returnValue);
+}
+/*
+*/
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/dk_flash.c apps_1.2/art_1.2/art/modules/dk_flash.c
--- apps/art_1.2/art/modules/dk_flash.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/dk_flash.c	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,1247 @@
+/*
+ * This MTD supports CFI flash devices:
+ *	- BCS or SCS parts such as Intel.
+ *	- AMD/FJ parts such as Toshiba.
+ *
+ * For the AR531X flash design we split the flash into 3 sections:
+ *	0		bootrom
+ *	ROM_SIZE	tffs area
+ *	N-3 sectors	configuration area
+ *
+ * This is optimized for a top boot block part so small sectors can
+ * be used configuration - boot line, radio "eeprom" configuration,
+ * and board configuration.  It is anticipated that the board and
+ * radio sectors will be write protected after programming.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include "dk.h"
+#include "dk_pci_bus.h"
+#include "client.h"
+#include "dk_flash.h"
+#include  "flbase.h"
+#include  "flflash.h"
+
+
+#define NFLC            3 
+#define FLC_BOOTLINE    0 
+#define FLC_BOARDDATA   1 
+#define FLC_RADIOCFG    2
+#define INCLUDE_CFI_AMDFJ               /* AMD/FJ part for production */
+
+
+
+/* CFI commands */
+#define CFI_QUERY			0x98
+
+/* BCS/SCS commands */
+#define SCS_CONFIRM_SET_LOCKBIT		0x01
+#define SCS_SETUP_BLOCK_ERASE		0x20
+#define SCS_SETUP_QUEUE_ERASE		0x28
+#define SCS_SETUP_CHIP_ERASE		0x30
+#define SCS_CLEAR_STATUS		0x50
+#define SCS_SET_LOCKBIT			0x60
+#define SCS_CLEAR_LOCKBIT		0x60
+#define SCS_READ_STATUS			0x70
+#define SCS_READ_ID			0x90
+#define SCS_SUSPEND_WRITE		0xb0
+#define SCS_SUSPEND_ERASE		0xb0
+#define SCS_CONFIG			0xb8
+#define SCS_CONFIRM_WRITE		0xd0
+#define SCS_RESUME_WRITE		0xd0
+#define SCS_CONFIRM_ERASE		0xd0
+#define SCS_RESUME_ERASE		0xd0
+#define SCS_CONFIRM_CLEAR_LOCKBIT	0xd0
+#define SCS_WRITE_TO_BUFFER		0xe8
+#define SCS_READ_ARRAY			0xff
+
+#define SCS_WSM_ERROR		0x3a	/* BCS/SCS status register bits */
+#define SCS_SR_BLOCK_LOCK	0x02
+#define SCS_SR_WRITE_SUSPEND	0x04
+#define SCS_SR_VPP_ERROR	0x08
+#define SCS_SR_WRITE_ERROR	0x10
+#define SCS_SR_LOCK_SET_ERROR	0x10
+#define SCS_SR_ERASE_ERROR	0x20
+#define SCS_SR_LOCK_RESET_ERROR	0x20
+#define SCS_SR_ERASE_SUSPEND	0x40
+#define SCS_SR_READY		0x80
+
+/* AMD commands */
+#define AMD_SETUP_ERASE		0x80
+#define AMD_SETUP_WRITE		0xa0
+#define AMD_READ_ID 		0x90
+#define AMD_SUSPEND_ERASE	0xb0
+#define AMD_SECTOR_ERASE	0x30
+#define AMD_RESUME_ERASE	0x30
+#define AMD_RESET_ARRAY		0xf0
+
+/*
+ * SST flash distinguishes between SECTOR_ERASE (0x1000 bytes)
+ * and BLOCK_ERASE (0x10000 bytes).
+ */
+#define SST_BLOCK_ERASE         0x50
+
+#define	AMD_UNLOCK_1		0xaa
+#define AMD_UNLOCK_2		0x55
+
+#define AMD_UNLOCK_ADDR1	0x555
+#define	AMD_UNLOCK_ADDR2	0x2aa
+
+#define	AMD_D2			4	/* Toggles when erase suspended */
+#define AMD_D5			0x20	/* Set when programming timeout */
+#define	AMD_D6			0x40	/* Toggles when programming */
+
+/* CFI command set IDs */
+#define INTEL_COMMAND_SET	0x0001
+#define AMDFUJ_COMMAND_SET	0x0002
+
+/* CFI identification strings */
+#define ID_STR_LENGTH		3
+#define QUERY_ID_STR		"QRY"
+#define PRIMARY_ID_STR		"PRI"
+#define ALTERNATE_ID_STR	"ALT"
+
+/* optional commands support */
+#define CHIP_ERASE_SUPPORT	0x0001
+#define SUSPEND_ERASE_SUPPORT	0x0002
+#define SUSPEND_WRITE_SUPPORT	0x0004
+#define LOCK_SUPPORT		0x0008
+#define QUEUED_ERASE_SUPPORT	0x0010
+
+#ifndef DEBUG_PRINT
+#define DEBUG_PRINT(args)
+#endif
+
+/*
+ * Indicates that we're using an SST flash part (39VF160).
+ * This part uses an AMD/Fujitsu flash command set, but with
+ * different addresses than usual (0x5555 rather than 0x555,
+ * and 0x2aaa rather than 0x2aa).
+ */
+static BOOLEAN SSTflash;
+
+/*
+ * Structure to hold flash parameters.  Stores additional data for
+ * sysFlash interface.
+ */
+struct cfi {
+    UINT8 *base;	        /* base of config flash */
+    UINT16 type;		/* type of flash device */
+    UINT32 size;		/* size of flash device */
+    UINT32 blockSize;		/* erase block size for tffs */
+    UINT32 cap;			/* size CAP for tffs */
+    UINT16 wb;			/* write buffer depth */
+    UINT16 cmdSet;		/* Intel or AMD */
+    UINT32 eraseTimeoutMs;	/* Max erase timeout in milliseconds */
+    UINT32 writeTimeoutUs;	/* Max write timeout in microseconds */
+    BOOLEAN vpp;		/* true if need vpp */
+    BOOLEAN x16;		/* width of device */
+    BOOLEAN ok;			/* sysFlashConfigInit status */
+    BOOLEAN top;		/* top boot block part */
+    UINT8 *flcPtr[NFLC];	/* segment base address */
+    int flcSize[NFLC];		/* segment size */
+    int flcReq[NFLC];		/* segment required size */
+    FLStatus (*write)(FlashPTR flashPtr, int offset, UINT8 *p, int len);
+    FLStatus (*erase)(FlashPTR flashPtr);
+    INT8 readCmd;		/* READ_ARRAY command */
+    UINT32 eBlocks;             /* cache of erase block layout */
+#define MAX_EBLOCKS 8
+    UINT32 ebSize[MAX_EBLOCKS];
+    UINT32 ebNum[MAX_EBLOCKS];
+} cfi;
+
+#define QRY(FP, mul) \
+	(((char)FP[0x10*(mul)] == 'Q') && \
+	 ((char)FP[0x11*(mul)] == 'R') && \
+	 ((char)FP[0x12*(mul)] == 'Y'))
+
+/*
+ * Mutual exclusion for tffs vs config and boot rom update.
+ *
+ * On flash mode changes (erase and write) we need to prevent
+ * mixed access to the flash device.  Reads are also special
+ * as tffs reads are done outside the driver, so boot accesses
+ * also prevent rescheduling for the duration of their access.
+ *
+ * Boot changes are infrequent and usually quick for config
+ * updates, so this is not a major issue.
+ *
+ * It is ok for the sema allocation to not take place.  This
+ * can happen during boot rom start-up.  In this environment
+ * there are no races anyway.
+ */
+static int *flSem = NULL;
+#define FL_LOCK_BOOT	0x01
+#define FL_LOCK_WRITE	0x02
+static int
+cfiLock(int mode)
+{
+    int rc = 0;
+
+    if (flSem == NULL) {
+        //flSem = semBCreate(SEM_Q_PRIORITY, SEM_FULL);
+    }
+    if (flSem != NULL) {
+        //semTake(flSem, WAIT_FOREVER);
+        if (mode & FL_LOCK_BOOT) {
+            //taskLock();
+        }
+    }
+
+    if (mode & FL_LOCK_WRITE) {
+//        rc = sysRegRead(AR531X_FLASHCTL0);
+//        sysRegWrite(AR531X_FLASHCTL0, rc & ~FLASHCTL_WP);
+    }
+
+    return rc;
+}
+
+static void
+cfiUnlock(int mode, int cookie)
+{
+    if (mode & FL_LOCK_WRITE) {
+//        sysRegWrite(AR531X_FLASHCTL0, cookie);
+    }
+
+    if (flSem) {
+        //semGive(flSem);
+        if (mode & FL_LOCK_BOOT) {
+            //taskUnlock();
+        }
+    }
+}
+
+#ifdef INCLUDE_MTD_CFISCS
+
+#include "backgrnd.h"
+
+#define thisCFI   ((struct cfi *)vol.mtdVars)
+
+/*
+ * cfiWrite - MTD write interface for all flash types.
+ */
+static FLStatus
+cfiWrite(FLFlash vol, CardAddress address, const void *buffer,
+         int length, int mode)
+{
+    FLStatus status = flOK;
+    int from, eachWrite;
+    FlashPTR flashPtr;
+    int s;
+
+    DEBUG_PRINT(("Debug: write 0x%x for %d.\n", (int)address, length));
+
+    /* Only write words on word-boundary for x16 devices */
+    if (thisCFI->x16 && ((length & 1) || (address & 1))) {
+        return flBadParameter;
+    }
+
+    if (flWriteProtected(vol.socket)) {
+        return flWriteProtect;
+    }
+
+#ifdef SOCKET_12_VOLTS
+    if (thisCFI->vpp) {
+        checkStatus(flNeedVpp(vol.socket));
+    }
+#endif
+
+    s = cfiLock(FL_LOCK_WRITE);
+
+    eachWrite = thisCFI->wb;
+
+    for (from = 0; from < length && status == flOK; from += eachWrite) {
+        flashPtr = (FlashPTR)flMap(vol.socket, address + from);
+        status = thisCFI->write(flashPtr, 0,
+                                ((char *)buffer) + from,
+                                min(length - from, eachWrite));
+    }
+
+#ifdef SOCKET_12_VOLTS
+    if (thisCFI->vpp) {
+        flDontNeedVpp(vol.socket);
+    }
+#endif
+
+    flashPtr = (FlashPTR) flMap(vol.socket, address);
+    /* verify the data */
+    if (status == flOK && tffscmp((void *)flashPtr, buffer, length)) {
+        printk("cfiscs: write failed in verification @ %p.\n",
+               (void *)flashPtr);
+        status = flWriteFault;
+    }
+
+    cfiUnlock(FL_LOCK_WRITE, s);
+
+    return status;
+}
+
+/*
+ * cfiErase - MTD erase wrapper.
+ */
+static FLStatus
+cfiErase(FLFlash vol, int firstErasableBlock, int numOfErasableBlocks)
+{
+    FLStatus status = flOK;       /* unless proven otherwise */
+    FlashPTR flashPtr;
+    int blk;
+    int s;
+
+    DEBUG_PRINT(("Debug: erase 0x%lx %d blocks.\n",
+                 firstErasableBlock  * vol.erasableBlockSize,
+                 numOfErasableBlocks));
+
+    if (flWriteProtected(vol.socket)) {
+        return flWriteProtect;
+    }
+
+#ifdef SOCKET_12_VOLTS
+    if (thisCFI->vpp) {
+        checkStatus(flNeedVpp(vol.socket));
+    }
+#endif
+
+    s = cfiLock(FL_LOCK_WRITE);
+
+    for (blk = 0; blk < numOfErasableBlocks && status == flOK; blk++) {
+        flashPtr = (FlashPTR)vol.map(&vol,
+                                     (firstErasableBlock + blk) * vol.erasableBlockSize,
+                                     vol.interleaving);
+
+        status = thisCFI->erase(flashPtr);
+    }
+
+    cfiUnlock(FL_LOCK_WRITE, s);
+
+#ifdef SOCKET_12_VOLTS
+    if (thisCFI->vpp) {
+        flDontNeedVpp(vol.socket);
+    }
+#endif
+
+    return status;
+}
+
+/*
+ * cfiscsIdentify - Identifies media based on CFI and registers as an
+ *                  MTD for such.
+ *
+ * This routine will be placed on the MTD list in custom.h.  It must be
+ * an extern routine.
+ *
+ * On successful identification, the Flash structure is filled out and
+ * the write and erase routines registered.
+ */
+FLStatus
+cfiscsIdentify(FLFlash vol)
+{
+    int s;
+
+    DEBUG_PRINT(("Debug: entering CFISCS identification routine.\n"));
+
+    flSetWindowSpeed(vol.socket, 120);    /* 120 nsec. */
+    flSetWindowSize(vol.socket, 2);       /* 8 KBytes */
+
+    /*
+     * Interleaving probing support has been removed for
+     * simplicity and to allow the boot and tffs interfaces
+     * to share code.
+     */
+    vol.interleaving = 1;
+    vol.mtdVars = &cfi;
+    vol.noOfChips = 1;
+
+    if (thisCFI->ok == FALSE) {
+        DEBUG_PRINT(("Debug: device not ok.\n"));
+        return flUnknownMedia;
+    }
+
+    s = cfiLock(FL_LOCK_WRITE);
+
+    flSetWindowBusWidth(vol.socket, thisCFI->x16 ? 16 : 8);
+
+    vol.write = cfiWrite;
+    vol.erase = cfiErase;
+    vol.type = thisCFI->type;
+    vol.erasableBlockSize = thisCFI->blockSize;
+    vol.chipSize = thisCFI->cap;
+
+    cfiUnlock(FL_LOCK_WRITE, s);
+    DEBUG_PRINT(("Debug: ok.\n"));
+
+    return flOK;
+}
+#endif /* INCLUDE_MTD_CFISCS */
+
+#ifdef INCLUDE_CFI_SCS
+/*
+ * cfiscsBlockErase_x8 - Erase the block pointed to by flashPtr.
+ */
+static FLStatus
+cfiscsBlockErase_x8(FlashPTR flashPtr)
+{
+    FLStatus status = flOK;       /* unless proven otherwise */
+    int maxTo = cfi.eraseTimeoutMs * 10;
+    FLBoolean finished;
+    int to = 0;
+
+    /* Intel part does not have queued erase support */
+    flashPtr[0] = SCS_SETUP_BLOCK_ERASE;
+    flashPtr[0] = SCS_CONFIRM_ERASE;
+
+    do {
+        finished = TRUE;
+        flashPtr[0] = SCS_READ_STATUS;
+        udelay(100);			/* .1ms */
+        if (!(flashPtr[0] & SCS_SR_READY)) {
+            finished = FALSE;
+        } else if (flashPtr[0] & SCS_SR_ERASE_SUSPEND) {
+            flashPtr[0] = SCS_RESUME_ERASE;
+            finished = FALSE;
+        } else if (to++ > maxTo) {
+            status = flTimedOut;
+            finished = TRUE;
+        } else {
+            if (flashPtr[0] & SCS_WSM_ERROR) {
+                DEBUG_PRINT(("Debug: CFISCS erase error.\n"));
+                status = (flashPtr[0] & SCS_SR_VPP_ERROR) ?
+                    flVppFailure : flWriteFault;
+                flashPtr[0] = SCS_CLEAR_STATUS;
+            }
+        }
+    } while (!finished);
+
+    flashPtr[0] = SCS_READ_ARRAY;
+
+    return status;
+}
+
+/*
+ * cfiscsBlockErase_x16 - Erase the block pointed to by flashPtr.
+ */
+static FLStatus
+cfiscsBlockErase_x16(FlashPTR bytePtr)
+{
+    FlashWPTR flashPtr = (FlashWPTR)bytePtr;
+    FLStatus status = flOK;       /* unless proven otherwise */
+    int maxTo = cfi.eraseTimeoutMs * 10;
+    FLBoolean finished;
+    int to = 0;
+
+    /* Intel part does not have queued erase support */
+    flashPtr[0] = SCS_SETUP_BLOCK_ERASE; /* FlashPtr points at block */
+    flashPtr[0] = SCS_CONFIRM_ERASE;
+
+    do {
+        finished = TRUE;
+        flashPtr[0] = SCS_READ_STATUS;
+        udelay(100);		/* .1ms */
+        if (!(flashPtr[0] & SCS_SR_READY)) {
+            finished = FALSE;
+        } else if (flashPtr[0] & SCS_SR_ERASE_SUSPEND) {
+            flashPtr[0] = SCS_RESUME_ERASE;
+            finished = FALSE;
+        } else if (to++ > maxTo) {
+            status = flTimedOut;
+            finished = TRUE;
+        } else {
+            if (flashPtr[0] & SCS_WSM_ERROR) {
+                DEBUG_PRINT(("Debug: CFISCS erase error.\n"));
+                status = (flashPtr[0] & SCS_SR_VPP_ERROR) ?
+                    flVppFailure : flWriteFault;
+                flashPtr[0] = SCS_CLEAR_STATUS;
+            }
+        }
+    } while (!finished);
+
+    flashPtr[0] = SCS_READ_ARRAY;
+
+    return status;
+}
+
+/*
+ * cfiscsBufferWrite_x8 - write len bytes from p at flashPtr.
+ */
+static FLStatus
+cfiscsBufferWrite_x8(FlashPTR flashPtr, int offset, UINT8 *p, int len)
+{
+    FLStatus status = flOK;
+    int i, to;
+
+    to = 0;
+    do {
+        *flashPtr = SCS_WRITE_TO_BUFFER;
+        udelay(20);
+    } while (!(*flashPtr & SCS_SR_READY) && (to++ < 1000));
+    if (!(*flashPtr & SCS_SR_READY)) {
+        printk("cfiscs: timeout error for WRITE_TO_BUFFER @ %p.\n",
+               flashPtr);
+        status = flTimedOut;
+    }
+
+    *flashPtr = len - 1;		/* 0 == 1 byte */
+
+    /* tffscpy() */
+    for (i = 0; i < len; i++) {
+        flashPtr[offset+i] = p[i];
+    }
+
+    *flashPtr = SCS_CONFIRM_WRITE;
+
+    for (to=0; !(*flashPtr & SCS_SR_READY) && (to < cfi.writeTimeoutUs); to++) {
+        udelay(1);
+    }
+    if (!(*flashPtr & SCS_SR_READY)) {
+        printk("cfiscs: timeout error for CONFIRM_WRITE @ %p.\n",
+               flashPtr);
+        status = flTimedOut;
+    }
+    if (*flashPtr & SCS_WSM_ERROR) {
+        printk("cfiscs: WSM_ERROR @ %p.\n", flashPtr);
+        status = (*flashPtr & SCS_SR_VPP_ERROR) ? flVppFailure : flWriteFault;
+        *flashPtr = SCS_CLEAR_STATUS;
+    }
+
+    *flashPtr = SCS_READ_ARRAY;
+
+    return status;
+}
+
+/*
+ * cfiscsBufferWrite_x16 - write len bytes from p at flashPtr.  Interface
+ * is in bytes, not words.
+ */
+static FLStatus
+cfiscsBufferWrite_x16(FlashPTR bytePtr, int offset, UINT8 *p, int len)
+{
+    FlashWPTR flashPtr = (FlashWPTR)bytePtr;
+    FLStatus status = flOK;
+    int i, idx, to;
+    UINT16 val;
+    int pad;
+
+    to = 0;
+    do {
+        *flashPtr = SCS_WRITE_TO_BUFFER;
+        udelay(20);
+    } while (!(*flashPtr & SCS_SR_READY) && (to++ < 1000));
+    if (!(*flashPtr & SCS_SR_READY)) {
+        printk("cfiscs: timeout error for WRITE_TO_BUFFER @ %p.\n",
+               flashPtr);
+        status = flTimedOut;
+    }
+
+    /* handle pad byte at start and/or end.  Caller accomidates this */
+    pad = (offset & 1) + ((offset & 1) ^ (len & 1));
+    *flashPtr = ((len + pad) >> 1) - 1;		/* 0 == 1 word */
+
+    /* tffscpy() */
+    for (i = 0; i < len; ) {
+        idx = (offset + i) >> 1;
+        if (((offset+i) & 1) == 0) {
+            val = p[i++] << 8;
+            val |= (i < len) ? (p[i++] & 0xff) : 0x00ff;
+        } else {
+            val = (p[i++] & 0xff) | 0xff00;
+        }
+        flashPtr[idx] = val;
+    }
+
+    *flashPtr = SCS_CONFIRM_WRITE;
+
+    for (to=0; !(*flashPtr & SCS_SR_READY) && (to < cfi.writeTimeoutUs); to++) {
+        udelay(1);
+    }
+    if (!(*flashPtr & SCS_SR_READY)) {
+        printk("cfiscs: timeout error for CONFIRM_WRITE @ %p.\n",
+               flashPtr);
+        status = flTimedOut;
+    }
+    if (*flashPtr & SCS_WSM_ERROR) {
+        printk("cfiscs: WSM_ERROR @ %p.\n", flashPtr);
+        status = (*flashPtr & SCS_SR_VPP_ERROR) ? flVppFailure : flWriteFault;
+        *flashPtr = SCS_CLEAR_STATUS;
+    }
+
+    *flashPtr = SCS_READ_ARRAY;
+
+    return status;
+}
+#endif  /* INCLUDE_MTD_CFISCS */
+
+#ifdef INCLUDE_CFI_AMDFJ
+/*
+ * cfiamdBlockErase_x8 - Erase the block pointed to by flashPtr.
+ */
+#ifdef UNUSED
+static FLStatus
+cfiamdBlockErase_x8(FlashPTR flashPtr)
+{
+    int maxTo = cfi.eraseTimeoutMs * 10;
+    int to = 0;
+
+    cfi.base[0xaaa] = AMD_UNLOCK_1;
+    cfi.base[0x555] = AMD_UNLOCK_2;
+    cfi.base[0xaaa] = AMD_SETUP_ERASE;
+    cfi.base[0xaaa] = AMD_UNLOCK_1;
+    cfi.base[0x555] = AMD_UNLOCK_2;
+    flashPtr[0] = AMD_SECTOR_ERASE;
+
+    while (1) {
+        udelay(100);			/* .1ms */
+        if (((flashPtr[0] ^ flashPtr[0]) & AMD_D6) == 0) {
+            break;
+        }
+        if (to++ > maxTo) {
+            printk("cfiamd: erase timeout @ %p\n", (void *)flashPtr);
+            *flashPtr = AMD_RESET_ARRAY;
+            return flWriteFault;
+        }
+    }
+    if (flashPtr[0] != 0xff) {
+        if (flashPtr[0] & AMD_D5) {
+            printk("cfiamd: D5 erase timeout @ %p\n", (void *)flashPtr);
+        } else {
+            printk("cfiamd: erase mismatch @ %p\n", (void *)flashPtr);
+        }
+        *flashPtr = AMD_RESET_ARRAY;
+        return flWriteFault;
+    }
+
+    return flOK;
+}
+#endif
+/*
+ * cfiamdBlockErase_x16 - Erase the block pointed to by flashPtr.
+ */
+static FLStatus
+cfiamdBlockErase_x16(FlashPTR bytePtr)
+{
+    FlashWPTR flashBase = (FlashWPTR)cfi.base;
+    FlashWPTR flashPtr = (FlashWPTR)bytePtr;
+    int maxTo = cfi.eraseTimeoutMs * 10;
+    int to = 0;
+
+    if (SSTflash) {
+        flashBase[0x5555] = AMD_UNLOCK_1;
+        flashBase[0x2aaa] = AMD_UNLOCK_2;
+        flashBase[0x5555] = AMD_SETUP_ERASE;
+        flashBase[0x5555] = AMD_UNLOCK_1;
+        flashBase[0x2aaa] = AMD_UNLOCK_2;
+        flashPtr[0] = SST_BLOCK_ERASE;
+    } else {
+        flashBase[0x555] = AMD_UNLOCK_1;
+        flashBase[0x2aa] = AMD_UNLOCK_2;
+        flashBase[0x555] = AMD_SETUP_ERASE;
+        flashBase[0x555] = AMD_UNLOCK_1;
+        flashBase[0x2aa] = AMD_UNLOCK_2;
+        flashPtr[0] = AMD_SECTOR_ERASE;
+    }
+
+    while (1) {
+        udelay(100);			/* 0.1ms */
+        if (((flashPtr[0] ^ flashPtr[0]) & AMD_D6) == 0) {
+            break;
+        }
+        if (to++ > maxTo) {
+            printk("cfiamd: erase timeout @ %p\n", (void *)flashPtr);
+            *flashPtr = AMD_RESET_ARRAY;
+            return flWriteFault;
+        }
+    }
+    if (flashPtr[0] != 0xffff) {
+        if (flashPtr[0] & AMD_D5) {
+            printk("cfiamd: D5 erase timeout @ %p\n", (void *)flashPtr);
+        } else {
+            printk("cfiamd: erase mismatch @ %p\n", (void *)flashPtr);
+        }
+        *flashPtr = AMD_RESET_ARRAY;
+        return flWriteFault;
+    }
+
+    return flOK;
+}
+
+/*
+ * cfiamdBufferWrite_x8 - write len bytes from p at flashPtr.
+ */
+#ifdef UNUSED
+static FLStatus
+cfiamdBufferWrite_x8(FlashPTR flashPtr, int offset, UINT8 *p, int len)
+{
+    FlashPTR flashBase = (FlashPTR)cfi.base;
+    int maxTo = cfi.writeTimeoutUs;
+    int i, to;
+
+    for (i = 0; i < len; i++) {
+        flashBase[0xaaa] = AMD_UNLOCK_1;
+        flashBase[0x555] = AMD_UNLOCK_2;
+        flashBase[0xaaa] = AMD_SETUP_WRITE;   
+        flashPtr[offset+i] = p[i];
+
+        to = 0;
+        while (1) {
+            udelay(1);
+            if (((flashPtr[offset+i] ^ flashPtr[offset+i]) & AMD_D6) == 0) {
+                break;
+            }
+            if (to++ > maxTo) {
+                printk("cfiamd: write timeout @ %p\n", (void *)flashPtr+offset+i);
+                *flashPtr = AMD_RESET_ARRAY;
+            }
+        }
+
+        if (flashPtr[offset+i] != p[i]) {
+            printk("cfiamd: write %s @ %p (%x != %x)\n",
+                   (flashPtr[offset+i] & AMD_D5) ? "D5 timeout" : "mismatch",
+                   (void *)flashPtr+offset+i, flashPtr[offset+i], p[i]);
+            *flashPtr = AMD_RESET_ARRAY;
+            return flWriteFault;
+        }
+    }
+
+    return flOK;
+}
+#endif
+/*
+ * cfiamdBufferWrite_x16 - write len bytes from p at flashPtr.  Interface
+ * is in bytes, not words.
+ */
+static FLStatus
+cfiamdBufferWrite_x16(FlashPTR bytePtr, int offset, UINT8 *p, int len)
+{
+    FlashWPTR flashBase = (FlashWPTR)cfi.base;
+    FlashWPTR flashPtr = (FlashWPTR)bytePtr;
+    int maxTo = cfi.writeTimeoutUs;
+    int i, idx, to;
+    UINT16 val;
+
+    for (i = 0; i < len; ) {
+
+        idx = (offset + i) >> 1;
+        if (((offset+i) & 1) == 0) {
+            val = p[i++] << 8;
+            val |= (i < len) ? (p[i++] & 0xff) : (flashPtr[idx] & 0xff);
+        } else {
+            val = (p[i++] & 0xff) | (flashPtr[idx] & 0xff00);
+        }
+        if (SSTflash) {
+            flashBase[0x5555] = AMD_UNLOCK_1;
+            flashBase[0x2aaa] = AMD_UNLOCK_2;
+            flashBase[0x5555] = AMD_SETUP_WRITE;
+        } else {
+            flashBase[0x555] = AMD_UNLOCK_1;
+            flashBase[0x2aa] = AMD_UNLOCK_2;
+            flashBase[0x555] = AMD_SETUP_WRITE;
+        }
+        flashPtr[idx] = val;
+
+        to = 0;
+        while (1) {
+            udelay(1);
+            if (((flashPtr[idx] ^ flashPtr[idx]) & AMD_D6) == 0) {
+                break;
+            }
+            if (to++ > maxTo) {
+                printk("cfiamd: write timeout @ %p\n", (void *)flashPtr+offset+i);
+                *flashPtr = AMD_RESET_ARRAY;
+            }
+        }
+        if (flashPtr[idx] != val) {
+            printk("cfiamd: write %s @ %p (%x != %x)\n",
+                   (flashPtr[idx] & AMD_D5) ? "D5 timeout" : "mismatch",
+                   (void *)flashPtr+offset+i, flashPtr[offset+i], val);
+            *flashPtr = AMD_RESET_ARRAY;
+            return flWriteFault;
+        }
+    }
+
+    return flOK;
+}
+
+/*
+ * EEPROM on flash emulation low level support.  Uses common low level
+ * code and locking to avoid boot vs tffs contention.
+ *
+ * The last NFLC flash sector are reserved for various
+ * configuration items that do not belong in the flash filesystem
+ * as they are low level configuration (bootline), or wish to
+ * use the locking features of the flash device (board config).
+ *
+ * A top boot block part is prefered as it will waste less space
+ * as these configuration items are saved at the end of the device.
+ */
+#endif
+#ifdef UNUSED
+static BOOLEAN
+sysFlashConfigInit_x8(FlashPTR flashPtr)
+{
+    int i, j, off, nb, sz;
+    char *base;
+
+    cfi.size = 0;
+
+    /* Query the flash device */
+    flashPtr[0] = SCS_READ_ARRAY;
+    flashPtr[0x55*2] = CFI_QUERY;
+
+    /* Some boards have a x8 AMD part stuffed -- skip it */
+    if (!QRY(flashPtr, 2)) {
+        return FALSE;
+    }
+
+    cfi.cmdSet = flashPtr[0x13*2] | ((unsigned)flashPtr[0x14*2] << 8);
+#ifdef INCLUDE_CFI_SCS
+    if (cfi.cmdSet == INTEL_COMMAND_SET) {
+        cfi.write = cfiscsBufferWrite_x8;
+        cfi.erase = cfiscsBlockErase_x8;
+        cfi.readCmd = SCS_READ_ARRAY;
+    }
+#endif
+#ifdef INCLUDE_CFI_AMDFJ
+    if (cfi.cmdSet == AMDFUJ_COMMAND_SET) {
+        cfi.write = cfiamdBufferWrite_x8;
+        cfi.erase = cfiamdBlockErase_x8;
+        cfi.readCmd = AMD_RESET_ARRAY;
+    }
+#endif
+    if (cfi.write == NULL) {
+        return FALSE;
+    }
+
+    cfi.size = 1L << flashPtr[0x27*2];
+    cfi.type = (FlashType) ((flashPtr[0] << 8) | flashPtr[0x1*2]);
+    cfi.vpp = (flashPtr[0x1d*2] != 0) ? TRUE : FALSE;
+    cfi.wb = 1L << (flashPtr[0x2a*2] | ((unsigned)flashPtr[0x2b*2] << 8));
+
+    cfi.eraseTimeoutMs = (1 << flashPtr[0x21*2]) * (1 << flashPtr[0x25*2]);
+    if (cfi.wb == 1) {
+        /* single write */
+        cfi.writeTimeoutUs = (1 << flashPtr[0x1f*2]) * (1 << flashPtr[0x23*2]);
+    } else {
+        /* buffer write */
+        cfi.writeTimeoutUs = (1 << flashPtr[0x20*2]) * (1 << flashPtr[0x24*2]);
+    }
+
+    if (cfi.cmdSet == AMDFUJ_COMMAND_SET) {
+        /* check for top part */
+        off = flashPtr[0x15*2] | ((unsigned)flashPtr[0x16*2]<<8);
+        cfi.top = (flashPtr[(off+0xf)*2] == 3) ? TRUE : FALSE;
+    }
+
+    cfi.blockSize = 0;
+    cfi.eBlocks = flashPtr[0x2c*2];
+    off = 0x2d;
+    if (cfi.top) {
+        for (i=cfi.eBlocks-1; i >= 0; i--) {
+            cfi.ebNum[i] = (flashPtr[off*2] |
+                            ((unsigned)flashPtr[(off+1)*2]) << 8) + 1;
+            cfi.ebSize[i] = (flashPtr[(off+2)*2] |
+                             ((unsigned)flashPtr[(off+3)*2]) << 8) * 0x100;
+            if (cfi.ebSize[i] > cfi.blockSize) {
+                cfi.blockSize = cfi.ebSize[i];
+            }
+            off += 4;
+        }
+    } else {
+        for (i=0; i < cfi.eBlocks; i++) {
+            cfi.ebNum[i] = (flashPtr[off*2] |
+                            ((unsigned)flashPtr[(off+1)*2]) << 8) + 1;
+            cfi.ebSize[i] = (flashPtr[(off+2)*2] |
+                             ((unsigned)flashPtr[(off+3)*2]) << 8) * 0x100;
+            if (cfi.ebSize[i] > cfi.blockSize) {
+                cfi.blockSize = cfi.ebSize[i];
+            }
+            off += 4;
+        }
+    }
+    base = cfi.base + cfi.size;
+    off = cfi.eBlocks - 1;
+    i = NFLC - 1;
+    while (i >= 0) {
+        nb = cfi.ebNum[off];
+        //sz = cfi.ebSize[off];  // Siva
+        sz = (DK_BOARDCONFIG_SIZE > DK_RADIOCONFIG_SIZE)?DK_BOARDCONFIG_SIZE:DK_RADIOCONFIG_SIZE;
+        for (j=0; (j < nb) && (i >= 0); j++) {
+            base -= sz;
+            cfi.flcPtr[i] = base;
+            cfi.flcSize[i] = sz;
+            i--;
+        }
+        off--;
+    }
+
+    flashPtr[0] = cfi.readCmd;
+
+    return TRUE;
+}
+#endif
+/*
+ * We support two different varieties of flash parts with slightly
+ * different command sets (Intel versus AMD).  If a CFI QRY fails
+ * with the Intel command set, we try AMD.
+ *
+ * AR5311 flash parts all use Intel command set.
+ * AR5312 flash may use an SST flash part, which
+ * uses the AMD/Fujitsu command set at different addresses.
+ * We determine which part we have dynamically by trying
+ * several QRY commands and seeing which one works.
+ */
+static BOOLEAN
+sysFlashConfigInit_x16(FlashWPTR ptr)
+{
+    int i, off;
+    char *base;
+    FlashWPTR flashPtr;
+    char * basePtr;
+
+    cfi.size = 0;
+    cfi.base = (UINT8 *)(ioremap((phys_t)ptr, 0x10000));
+    flashPtr = (FlashWPTR)(cfi.base);
+
+    /* Query the flash device */
+    flashPtr[0] = SCS_READ_ARRAY;
+    flashPtr[0x55] = CFI_QUERY;
+
+printk("ptr is 0x%x\n", (unsigned int)ptr);
+printk("flashPtr is 0x%x\n", (unsigned int)flashPtr);
+
+    /* look for the query identification string "QRY" */
+    if (!QRY(flashPtr, 1)) {
+        flashPtr[0] = SCS_READ_ARRAY;
+        flashPtr[0x5555] = 0xaa;
+        flashPtr[0x2aaa] = 0x55;
+        flashPtr[0x5555] = CFI_QUERY;
+        if (!QRY(flashPtr, 1)) {
+            return FALSE;
+        } else {
+            /* Force SST device to look like AMD */
+            cfi.cmdSet = AMDFUJ_COMMAND_SET;
+            SSTflash = TRUE;
+        }
+    } else {
+        cfi.cmdSet = flashPtr[0x13] | (flashPtr[0x14] << 8);
+        SSTflash = FALSE;
+    }
+#ifdef INCLUDE_CFI_SCS
+    if (cfi.cmdSet == INTEL_COMMAND_SET) {
+        cfi.write = cfiscsBufferWrite_x16;
+        cfi.erase = cfiscsBlockErase_x16;
+        cfi.readCmd = SCS_READ_ARRAY;
+    }
+#endif
+#ifdef INCLUDE_CFI_AMDFJ
+    if (cfi.cmdSet == AMDFUJ_COMMAND_SET) {
+        cfi.write = cfiamdBufferWrite_x16;
+        cfi.erase = cfiamdBlockErase_x16;
+        cfi.readCmd = AMD_RESET_ARRAY;
+    }
+#endif
+    if (cfi.write == NULL) {
+        return FALSE;
+    }
+
+    cfi.size = 1L << flashPtr[0x27];
+    /* This is still bytes, which the low level code counts */
+    cfi.type = (flashPtr[0] << 8) | flashPtr[1];
+    cfi.vpp = (flashPtr[0x1d] != 0) ? TRUE : FALSE;
+    cfi.wb = 1L << (flashPtr[0x2a] | ((unsigned)flashPtr[0x2b] << 8));
+    if (cfi.wb > 2) {
+        /*
+         * Conservative for odd byte alignments, but stay a power
+         * of two to avoid odd erase block strides.
+         */
+        cfi.wb >>= 1;
+    }
+    /* AMD code only writes 1 x16 per cycle, so pass in more than 1B */
+    if (cfi.cmdSet == AMDFUJ_COMMAND_SET) {
+        if (cfi.wb == 1) {
+            cfi.wb = 16;
+        }
+        /* check for top part */
+        off = flashPtr[0x15] | ((unsigned)flashPtr[0x16]<<8);
+        cfi.top = (flashPtr[off+0xf] == 3) ? TRUE : FALSE;
+    }
+printk("cfi.size is 0x%x\n", cfi.size);
+printk("cfi.type is 0x%x\n", cfi.type);
+printk("cfi.vpp is 0x%x\n", cfi.vpp);
+printk("cfi.wb is 0x%x\n", cfi.wb);
+printk("cfi.top is 0x%x\n", cfi.top);
+
+    cfi.eraseTimeoutMs = (1 << flashPtr[0x21]) * (1 << flashPtr[0x25]);
+    cfi.writeTimeoutUs = (1 << flashPtr[0x1f]) * (1 << flashPtr[0x23]);
+printk("cfi.eraseTimeoutMs is 0x%x\n", cfi.eraseTimeoutMs);
+printk("cfi.writeTimeoutUs is 0x%x\n", cfi.writeTimeoutUs);
+
+    cfi.blockSize = 0;
+    cfi.eBlocks = flashPtr[0x2c];
+printk("cfi.bBlocks is 0x%x\n", cfi.eBlocks);
+    off = 0x2d;
+    if (cfi.top) {
+        for (i=cfi.eBlocks-1; i >= 0; i--) {
+            cfi.ebNum[i] = (flashPtr[off] |
+                            ((unsigned)flashPtr[(off+1)]) << 8) + 1;
+            cfi.ebSize[i] = (flashPtr[(off+2)] |
+                             ((unsigned)flashPtr[(off+3)]) << 8) * 0x100;
+            if (cfi.ebSize[i] > cfi.blockSize) {
+                cfi.blockSize = cfi.ebSize[i];
+            }
+            off += 4;
+        }
+    } else {
+        for (i=0; i < cfi.eBlocks; i++) {
+            cfi.ebNum[i] = (flashPtr[off] |
+                            ((unsigned)flashPtr[(off+1)]) << 8) + 1;
+            cfi.ebSize[i] = (flashPtr[(off+2)] |
+                             ((unsigned)flashPtr[(off+3)]) << 8) * 0x100;
+            if (cfi.ebSize[i] > cfi.blockSize) {
+                cfi.blockSize = cfi.ebSize[i];
+            }
+            off += 4;
+printk("i is %x, cfi.ebNum is 0x%x\n", i, cfi.ebNum[i]);
+printk("i is %x, cfi.ebSize is 0x%x\n", i, cfi.ebSize[i]);
+        }
+    }
+//    base = cfi.base + cfi.size;
+printk("ptr is 0x%x\n", (unsigned int)ptr);
+printk("cfi.base is 0x%x\n", cfi.size);
+printk("cfi.blockSize is 0x%x\n", cfi.blockSize);
+    off = cfi.eBlocks - 1;
+    base = (UINT8 *)(ptr) + cfi.size - cfi.ebSize[off];
+    basePtr = (UINT8 *)(ioremap((phys_t)base, cfi.ebSize[off]));
+    i = NFLC - 1;
+
+printk("base is 0x%x\n", (unsigned int)base);
+printk("basePtr is 0x%x\n", (unsigned int)basePtr);
+printk("off is 0x%x\n", off);
+    cfi.flcPtr[FLC_BOOTLINE] = basePtr;
+    cfi.flcSize[FLC_BOOTLINE] = 0;
+    cfi.flcPtr[FLC_BOARDDATA] = basePtr;
+    cfi.flcSize[FLC_BOARDDATA] = DK_BOARDCONFIG_SIZE;
+    cfi.flcPtr[FLC_RADIOCFG] = basePtr + DK_BOARDCONFIG_SIZE;
+    cfi.flcSize[FLC_RADIOCFG] = DK_RADIOCONFIG_SIZE;
+printk("i=0:fPtr=0x%x:fS=0x%x:ebSize=0x%x\n", (unsigned int)cfi.flcPtr[0], cfi.flcSize[0], cfi.ebSize[off]);
+printk("i=1:fPtr=0x%x:fS=0x%x:ebSize=0x%x\n", (unsigned int)cfi.flcPtr[1], cfi.flcSize[1], cfi.ebSize[off]);
+printk("i=2:fPtr=0x%x:fS=0x%x:ebSize=0x%x\n", (unsigned int)cfi.flcPtr[2], cfi.flcSize[2], cfi.ebSize[off]);
+
+    flashPtr[0] = cfi.readCmd;
+
+    return TRUE;
+}
+
+void
+sysFlashConfigInit(void *ptr, INT32 bl, INT32 bd, INT32 rc)
+{
+    int i;
+    if (cfi.ok == TRUE) {
+        /* No need to re-initialize the flash on reboot */
+        return;
+    }
+
+    cfi.ok = FALSE;
+    cfi.flcReq[FLC_BOOTLINE] = bl;
+    cfi.flcReq[FLC_BOARDDATA] = bd;
+    cfi.flcReq[FLC_RADIOCFG] = rc;
+    cfi.top = FALSE;
+    /* try x16 */
+    if (cfi.ok == FALSE) {
+        cfi.ok = sysFlashConfigInit_x16((FlashWPTR)ptr);
+        if (cfi.ok == FALSE) {
+            printk("\r\nCould not find flash device!\r\n");
+            return;
+        }
+        cfi.x16 = TRUE;
+    }
+
+    /* Calculate cap at end of the device */
+    cfi.cap = cfi.size;
+    if (cfi.top == TRUE) {
+        cfi.cap -= cfi.ebNum[cfi.eBlocks-1] * cfi.ebSize[cfi.eBlocks-1];
+    } else {
+        for (i=0; i < NFLC; i++) {
+            cfi.cap -= cfi.flcSize[i];
+        }
+    }
+}
+
+/*
+ * sysFlashConfigWriteX - write taking the device width into account.
+ */
+static FLStatus
+sysFlashConfigWriteX(FlashPTR flashPtr, int offset, UINT8 *p, int len)
+{
+    FLStatus rc = flOK;
+    int i;
+
+    for (i=0; i < len; i += cfi.wb) {
+        rc = cfi.write(flashPtr, offset+i, p+i, min((int)cfi.wb, len-i));
+        if (rc != flOK) {
+            break;
+        }
+    }
+    return rc;
+}
+
+static UINT8
+sysFlashConfigReadLocked(int flcn, int offset)
+{
+    volatile UINT8 *flashPtr = (volatile UINT8 *)cfi.flcPtr[flcn];
+
+    return (cfi.ok == TRUE) ? flashPtr[offset] : 'x';
+}
+
+UINT8
+sysFlashConfigRead(int flcn, int offset)
+{
+    UINT8 val;
+    int s;
+
+    s = cfiLock(FL_LOCK_BOOT);
+    val = sysFlashConfigReadLocked(flcn, offset);
+    cfiUnlock(FL_LOCK_BOOT, s);
+
+    return val;
+}
+
+static void
+sysFlashConfigEraseLocked(int flcn)
+{
+    FLStatus rc;
+
+    if (cfi.ok == TRUE) {
+        rc = cfi.erase(cfi.flcPtr[flcn]);
+    }
+
+    return;
+}
+
+void
+sysFlashConfigErase(int flcn)
+{
+    int s;
+
+    s = cfiLock(FL_LOCK_BOOT | FL_LOCK_WRITE);
+    sysFlashConfigEraseLocked(flcn);
+    cfiUnlock(FL_LOCK_BOOT | FL_LOCK_WRITE, s);
+
+    return;
+}
+
+unsigned int 
+sysFlashConfigWrite(int flcn, int offset, UINT8 *data, int len)
+{
+    int i, malloced = TRUE;
+    FLStatus rc;
+    UINT8 *p;
+    UINT8 b;
+    int s;
+
+    if (cfi.ok == FALSE) {
+		return (0);
+    }
+
+    //printk("sysFlashConfigWrite: flc=%d:offset=%d:len=%d\n", flcn, offset, len);
+    s = cfiLock(FL_LOCK_BOOT | FL_LOCK_WRITE);
+
+    for (i=0; i < len; i++) {
+        b = sysFlashConfigReadLocked(flcn, offset+i);
+        /* If any 0 bits need to be 1, then we need to erase */
+        if ((~b & data[i]) != 0) {
+            /* erase needed, save, merge, rewrite */
+//            p = kmalloc(cfi.flcReq[flcn], GFP_KERNEL);
+            /* all data are in one sector */
+            p = kmalloc(cfi.flcReq[FLC_BOOTLINE] + 
+                        cfi.flcReq[FLC_BOARDDATA] + 
+                        cfi.flcReq[FLC_RADIOCFG], GFP_KERNEL);
+            if (p == NULL) {
+                /* kmalloc can fail during early init */
+                malloced = FALSE;
+		printk("memory allocation fail\n");
+		return (-ENXIO);
+            }
+            for (i=0; i < cfi.flcReq[FLC_BOOTLINE]; i++) {
+                p[i]  = sysFlashConfigReadLocked(FLC_BOOTLINE, i);
+            }
+            for (i=0; i < cfi.flcReq[FLC_BOARDDATA]; i++) {
+                p[cfi.flcReq[FLC_BOOTLINE] + i]  = 
+                       sysFlashConfigReadLocked(FLC_BOARDDATA, i);
+            }
+            for (i=0; i < cfi.flcReq[FLC_RADIOCFG]; i++) {
+                p[cfi.flcReq[FLC_BOOTLINE] + cfi.flcReq[FLC_BOARDDATA] + i]  = 
+                       sysFlashConfigReadLocked(FLC_RADIOCFG, i);
+            }
+            for (i=0; i < len; i++) {
+                if(flcn == FLC_BOOTLINE) p[offset + i] = data[i];
+                if(flcn == FLC_BOARDDATA) 
+                    p[cfi.flcReq[FLC_BOOTLINE] + offset + i] = data[i];
+                if(flcn == FLC_RADIOCFG) 
+                    p[cfi.flcReq[FLC_BOOTLINE] + cfi.flcReq[FLC_BOARDDATA] + offset+i] = data[i];
+            }
+            sysFlashConfigEraseLocked(flcn);
+            rc = sysFlashConfigWriteX((FlashPTR)cfi.flcPtr[0], 0, p, 
+                  (cfi.flcReq[FLC_BOOTLINE] + 
+                  cfi.flcReq[FLC_BOARDDATA] + cfi.flcReq[FLC_RADIOCFG]));
+            cfiUnlock(FL_LOCK_BOOT | FL_LOCK_WRITE, s);
+            if (rc != flOK) {
+                printk("sysFlashConfigWrite: failed rc=%d\n", rc);
+		return (-EINVAL);
+            }
+            if (malloced) {
+                kfree(p);
+            }
+            return 1;
+        }
+    }
+    rc = sysFlashConfigWriteX(cfi.flcPtr[flcn], offset, data, len);
+    cfiUnlock(FL_LOCK_BOOT | FL_LOCK_WRITE, s);
+
+    if (rc != flOK) {
+        printk("sysFlashConfigWrite: failed rc=%d\n", rc);
+	return (-EINVAL);
+    }
+    return 1;
+}
+
+int flash_init(void) {
+
+
+    	sysFlashConfigInit((void *)(0x50000000),
+                       0,
+                       DK_BOARDCONFIG_SIZE,
+                       DK_RADIOCONFIG_SIZE);
+
+	 return 0;
+}
+
+void flash_exit(void) {
+     iounmap((void *)cfi.flcPtr[FLC_BOOTLINE]);
+     iounmap((void *)cfi.base);
+}
+
+unsigned int dk_flash_read (int flc, unsigned int offset, size_t len, UINT8 * buf) {
+   UINT16 iIndex;
+	
+   //Dprintk("buf=%x\n", buf);
+   for(iIndex=0; iIndex<len; iIndex++) 
+       buf[iIndex] = sysFlashConfigRead(flc, offset+iIndex);
+
+   return (1);
+
+}
+
+unsigned int dk_flash_write (int flc, unsigned int offset, size_t len, UINT8 * buf) {
+  return sysFlashConfigWrite(flc, offset, buf, len);
+}
+
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/dk_func.c apps_1.2/art_1.2/art/modules/dk_func.c
--- apps/art_1.2/art/modules/dk_func.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/dk_func.c	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,438 @@
+/* func.c contains the device functions */
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+
+#include "dk.h"
+#include "dk_ioctl.h"
+#include "client.h"
+
+
+
+static int dk_open
+(	
+ 	struct inode *inode, 
+	struct file *file
+)
+{
+		int minor;
+		int major;
+		int error;
+#ifdef DK_DEBUG
+		printk("DK:: dk_open \n");
+#endif
+		major = MAJOR(inode->i_rdev);
+		minor = MINOR(inode->i_rdev);
+		minor = minor & 0x0f;
+		
+#ifdef DK_DEBUG
+		printk("DK:: dk_open:minor=%d\n", minor);
+#endif
+		/* 
+		 * register client returns the cli id 
+		 * or error value
+		 */ 
+		error = register_client(major, minor);
+		if (error < 0) {
+				return error;
+		}
+		/*
+		 * Store the client id in the private data field
+		 */
+	
+
+		file->private_data = (void *)((unsigned long)error);
+
+		return 0;
+}
+static int dk_release
+(	
+ 	struct inode *inode, 
+	struct file *file
+)
+{
+		int cli_id;
+#ifdef DK_DEBUG
+		printk("DK:: dk_release \n");
+#endif
+
+		cli_id = (int) ((unsigned long)file->private_data);
+
+		unregister_client(cli_id);
+		return 0;
+}
+
+/*
+ * Architectures vary in how they handle caching for addresses
+ * outside of main memory.
+ *
+ */
+static inline int uncached_access(struct file *file, unsigned long addr)
+{
+         /*
+          * Accessing memory above the top the kernel knows about or through a file pointer
+          * that was marked O_SYNC will be done non-cached.
+          */
+         if (file->f_flags & O_SYNC)
+                 return 1;
+         return addr >= __pa(high_memory);
+}
+static int dk_mmap
+(
+ 	struct file *file,
+	struct vm_area_struct *vma
+)
+{
+
+#if defined(__HAVE_PHYS_MEM_ACCESS_PROT)
+        unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+        vma->vm_page_prot = phys_mem_access_prot(file, offset,
+                                                 vma->vm_end - vma->vm_start,
+                                                 vma->vm_page_prot);
+#elif defined(pgprot_noncached)
+        unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+        int uncached;
+        uncached = uncached_access(file, offset);
+        if (uncached)
+                vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+#endif
+
+
+
+        /* Remap-pfn-range will mark the range VM_IO and VM_RESERVED */
+        if (remap_pfn_range(vma,
+                            vma->vm_start,
+                            vma->vm_pgoff,
+                            vma->vm_end-vma->vm_start,
+                            vma->vm_page_prot))
+                return -EAGAIN;
+		return 0; 
+
+}
+
+
+
+static int dk_ioctl
+(
+ 	struct inode *inode, 
+	struct file *file,
+	unsigned int cmd,
+	unsigned long arg
+)
+{
+		INT32 ret=-1;
+		INT32 data;
+		struct cfg_op co;
+		INT32 cli_id;
+		INT32 i;
+		struct client_info ci;
+		struct event_op eo;
+		event_handle evt_hnd;
+		p_event_struct p_event;
+		p_atheros_dev p_client;
+		
+#ifdef DK_DEBUG
+		printk("DK::dk_ioctl \n");
+#endif
+
+		cli_id = (int) ((unsigned long)file->private_data);
+
+		p_client = get_client(cli_id);
+		if (p_client == NULL) {
+				printk("DK:: Invalid client \n");
+				return -1;
+		}
+		switch (cmd) {
+			case DK_IOCTL_GET_VERSION:
+#ifdef DK_DEBUG
+				printk("DK:: DK_IOCTL_GET_VERISION \n");
+#endif
+				data = (DRV_MAJOR_VERSION << 16) | (DRV_MINOR_VERSION);
+				ret = put_user(data, (INT32 *)arg);
+				break;
+			case DK_IOCTL_GET_CLIENT_INFO:
+#ifdef DK_DEBUG
+				printk("DK:: DK_IOCTL_GET_CLIENT_INFO \n");
+#endif
+				if (get_cli_info(cli_id,&ci) < 0) {
+					printk("DK:: get_cli_info failed, cli_id : %d \n", cli_id);
+					ret = -1;
+				} else {
+					ret = copy_to_user((void *)arg,(void *)&ci,sizeof(ci));
+				}
+				ret = 0;
+				break;
+			case DK_IOCTL_CFG_READ:
+#if !defined(P1020)
+				if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+						return -EFAULT;
+				}
+#ifdef DK_DEBUG
+				printk("DK::Cfg read @ offset %x \n",co.offset);
+#endif
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#ifdef WASP_OSPREY
+   if(cli_id!=0){ // For DBDC operation, Wasp radio's client ID is zero; 
+#endif
+				if (cli_cfg_read(cli_id,co.offset,co.size,&co.value) < 0) {
+					ret = -1;
+				} else {
+					ret = copy_to_user((void *)arg,(void *)&co,sizeof(co));
+				}
+#ifdef WASP_OSPREY
+  }
+#endif
+#endif
+#else
+                ret = -1;
+#endif
+				break;
+                        case DK_IOCTL_RTC_REG_READ:
+                                if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+                                                return -EFAULT;
+                                }
+#ifdef DK_DEBUG
+                                printk("DK::Rtc reg read @ offset %x \n",co.offset);
+#endif
+#ifndef OCTEON
+                                if (rtc_reg_read(cli_id,co.offset,&co.value) < 0) {
+                                        ret = -1;
+                                } else {
+                                        ret = copy_to_user((void *)arg,(void *)&co,sizeof(co));
+                                }
+#endif
+                                break;
+			case DK_IOCTL_GET_CHIP_ID:
+				if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+						return -EFAULT;
+				}
+#ifdef DK_DEBUG
+				printk("DK::Reading Chio ID @ offset %x \n",co.offset);
+#endif
+#ifndef OCTEON
+				if (get_chip_id(cli_id,co.offset,co.size,&co.value) < 0) {
+					ret = -1;
+				} else {
+					ret = copy_to_user((void *)arg,(void *)&co,sizeof(co));
+				}
+				break;
+#endif
+			case DK_IOCTL_CFG_WRITE:
+				if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+						return -EFAULT;
+				}
+#ifdef DK_DEBUG
+				printk("DK::Cfg write @ offset %x : %x \n",co.offset,co.value);
+#endif
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#ifdef WASP_OSPREY
+   if(cli_id!=0){ // For DBDC operation, Wasp radio's client ID is zero; 
+#endif
+				if (cli_cfg_write(cli_id,co.offset,co.size,co.value) < 0) {
+					ret = -1;
+				} else {
+					ret = 0;
+				}
+#ifdef WASP_OSPREY
+  }
+#endif
+#endif
+				break;
+                        case DK_IOCTL_SYS_REG_WRITE_32:
+						case DK_IOCTL_FULL_ADDR_WRITE:
+                                if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+                                                return -EFAULT;
+                                }
+#ifdef DK_DEBUG
+                                printk("DK::full addr write @ address %x : %x \n",co.offset,co.value);
+#endif
+#ifdef AP83
+                                if (full_addr_write(cli_id,co.offset,co.value) < 0) {
+                                        ret = -1;
+                                } else {
+                                        ret = 0;
+                                }
+#endif
+                                break;
+						case DK_IOCTL_SYS_REG_READ_32:
+                        case DK_IOCTL_FULL_ADDR_READ:
+                                if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+                                                return -EFAULT;
+                                }
+#ifdef DK_DEBUG
+                                printk("DK::Full add read @ address %x \n",co.offset);
+#endif
+#ifdef AP83
+                                if (full_addr_read(cli_id,co.offset,&co.value) < 0) {
+                                        ret = -1;
+                                } else {
+                                        ret = copy_to_user((void *)arg,(void *)&co,sizeof(co));
+                                }
+#endif
+                                break;
+                        case DK_IOCTL_RTC_REG_WRITE:
+                                if (copy_from_user((void *)&co,(void *)arg,sizeof(co))) {
+                                                return -EFAULT;
+                                }
+#ifdef DK_DEBUG
+                                printk("DK::rtc write @ offset %x : %x \n",co.offset,co.value);
+#endif
+#ifdef AP83
+#ifndef WASP
+                                if (rtc_reg_write(cli_id,co.offset,co.value) < 0) {
+                                        ret = -1;
+                                } else {
+                                        ret = 0;
+                                }
+#endif
+#endif
+                                break;
+			case DK_IOCTL_CREATE_EVENT:
+#ifdef DK_DEBUG
+				printk("DK::Create event \n");
+#endif
+				if (copy_from_user((void *)&eo,(void *)arg,sizeof(eo))) {
+						return -EFAULT;
+				}
+				ret = -1;
+				if (eo.valid) {
+			 		evt_hnd.eventID = eo.param[5] & 0xffff;
+					evt_hnd.f2Handle = (eo.param[5] >> 16) & 0xffff;
+					p_event = createEvent (eo.param[0], // type
+					                       eo.param[1], // persistent
+					                       eo.param[2], // param1
+					                       eo.param[3], // param2
+					                       eo.param[4], // param3
+					                       evt_hnd);
+					if (p_event != NULL) {
+						// need to look at the event type to see which queue
+						switch (p_event->type ) {
+							case ISR_INTERRUPT:
+								//if param1 is zero, we, by default
+								// set the "ISR IMR" to pass everything
+								if ( 0 == p_event->param1 ) {
+									p_event->param1 = 0xffffffff;
+								}
+								if (pushEvent(p_event, &p_client->isr_event_q,
+								               TRUE) ) {
+										ret = 0;
+								} else {
+									printk("DK::Push Event Failed \n");
+									kfree(p_event);
+								} 
+								break;
+							default:
+								printk("DK::Event Type %d not supported \n",p_event->type);
+								kfree(p_event);
+								break;
+						}
+					} 
+				}
+				break;
+			case DK_IOCTL_GET_NEXT_EVENT:
+#ifdef DK_DEBUG
+				printk("DK::Get next event \n");
+#endif
+				ret = 0;
+				eo.valid = 0;
+				if (p_client->trigered_event_q.queueSize) {
+					if (checkForEvents(&p_client->trigered_event_q,TRUE)){ 
+						p_event = popEvent(&p_client->trigered_event_q,TRUE);
+						eo.valid = 1;
+						eo.param[0] = p_event->type;
+						eo.param[1] = p_event->persistent;
+						eo.param[2] = p_event->param1; 
+						eo.param[3] = p_event->param2;
+						eo.param[4] = p_event->param3;
+						eo.param[5] = (p_event->eventHandle.f2Handle << 16) | 
+						               p_event->eventHandle.eventID; 
+						for (i=0;i<6;i++) { 
+							eo.param[6+i] = p_event->result[i]; 
+						} 
+					#ifdef DK_DEBUG 
+						printk("DK:: Pop event %x \n",(UINT32)p_event);
+					#endif 
+						kfree(p_event);
+					} 
+				}
+				ret = copy_to_user((void *)arg,(void *)&eo,sizeof(eo));
+				break;
+            case DK_IOCTL_FLASH_READ:
+                printk("DK:: Flash read is not supported any more from art driver\n");
+                break;
+            case DK_IOCTL_FLASH_WRITE:
+                printk("DK:: Flash read is not supported any more from art driver\n");
+                break; 
+/*
+#ifdef OWL_PB42
+            case DK_IOCTL_MAC_WRITE:
+#ifdef DK_DEBUG
+                 printk("DK::Get DK_IOCTL_MAC_WRITE\n ");
+#endif
+                 if (copy_from_user((void *)&flashMac,(void *)arg,sizeof(flashMac))) {
+                      printk("DK:: Copy_from_user failed 1\n");
+                      return -EFAULT;
+                 }
+                 if (copy_from_user((void *)mac0Addr,(void *)flashMac.pAddr0, 6)){
+                     printk("DK:: Copy_from_user failedi 2\n");
+                     return -EFAULT;
+                 }
+                 if (copy_from_user((void *)mac1Addr,(void *)flashMac.pAddr1, 6)){
+                     printk("DK:: Copy_from_user failed 3\n");
+                     return -EFAULT;
+                 }
+#ifdef DK_DEBUG
+                 printk("DK:: MAC Addr\n");
+				 for(i=0; i<6; i++)
+					printk("%x  ", mac0Addr[i]);
+				 printk("\n");
+				 for(i=0; i<6; i++)
+					printk("%x  ", mac1Addr[i]);
+				 printk("\n");
+#endif
+				memcpy(&hw_mac_cfg, 0xbf7f0000, 16);
+				ar7100_spi_sector_erase(0x7f0000);
+				// Copy mac address to ath_hw_cfg structure
+				for(i=0; i<6; i++)
+			        hw_mac_cfg.macAddr0[i] = mac0Addr[i];
+				for(i=0; i<6; i++)
+			        hw_mac_cfg.macAddr1[i] = mac1Addr[i];
+				ar7100_spi_write_page(0x7f0000, &hw_mac_cfg, 256);				
+				ret = 1;
+                break; 
+#endif
+*/
+			default:
+				printk("DK::Unreconginzed ioctl command %d \n",cmd);
+				break;
+		}
+		return ret;
+}
+
+static struct file_operations dk_fops = {
+	owner:	THIS_MODULE,
+	open:	dk_open,
+	release: dk_release,
+	mmap:	dk_mmap,
+
+	ioctl  : dk_ioctl
+
+};
+INT32  dk_dev_init(void) {
+		int status;
+		status = register_chrdev(DK_MAJOR_NUMBER,"dk",&dk_fops);
+		printk("dk_dev_init::status after register_chrdev(dk) = %d\n", status);
+#ifdef DK_UART
+	        status |= register_chrdev(DK_UART_MAJOR_NUMBER, "dk_uart", &dk_fops);
+		printk("dk_dev_init::status after register_chrdev(dk_uart) = %d\n", status);
+#endif
+		return status;
+}
+void dk_dev_exit(void) {
+		unregister_chrdev(DK_MAJOR_NUMBER,"dk");
+//#ifdef DK_UART
+		unregister_chrdev(DK_UART_MAJOR_NUMBER,"dk_uart");
+//#endif
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/dk_isr.c apps_1.2/art_1.2/art/modules/dk_isr.c
--- apps/art_1.2/art/modules/dk_isr.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/dk_isr.c	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,232 @@
+/* dk_irq.c - this file contains the interrupt handler for the dk driver */
+
+#include <asm/ptrace.h>
+#include <linux/kernel.h>
+
+#include "dk.h"
+#include "client.h"
+#include "dk_event.h"
+
+BOOLEAN dk_intr_handler
+(
+ 	INT32 irq,
+	VOID *param,
+	struct pt_regs *regs
+)
+{
+	p_event_struct p_event;
+	p_event_struct p_event_copy;
+	p_event_struct p_event_to_push;
+	p_event_queue p_isr_event_q;
+	p_event_queue p_trigered_event_q;
+	UINT32 priIsr;
+	UINT32 secIsr[5];
+	UINT32 i;
+	BOOLEAN bValidEvent;
+	p_atheros_dev p_client;
+	UINT32 cli_id;
+#ifndef AP83
+	INT32 reg_val;
+        UINT32 macRev;
+#endif
+
+	p_client = (p_atheros_dev)param;
+	cli_id = p_client->cli_id;
+#ifdef AP83
+       cli_reg_write(cli_id,0x0024,0x0); // disabling INT register..
+                /* Read the isr */
+                cli_reg_read(cli_id,0x00c0,&priIsr);
+               if(!priIsr) {
+                        //this might be first gen
+                        cli_reg_read(cli_id, 0x1c,&priIsr);
+                }
+
+#ifdef DK_DEBUG
+           printk("DK::Got interrupt:ISR = %x \n",priIsr);
+#endif
+
+                cli_reg_read(cli_id,0x00c4,&secIsr[0]);
+                cli_reg_read(cli_id,0x00c8,&secIsr[1]);
+                cli_reg_read(cli_id,0x00cc,&secIsr[2]);
+                cli_reg_read(cli_id,0x00d0,&secIsr[3]);
+                cli_reg_read(cli_id,0x00d4,&secIsr[4]);
+
+//        }
+
+
+        // catch spurios interrupts that comes before the client is registered
+        if (!BUSY_CLIENT(p_client)) return FALSE;
+
+        // start to scan the current queue of events
+        p_isr_event_q = &(p_client->isr_event_q);
+        p_trigered_event_q = &(p_client->trigered_event_q);
+        p_event = p_isr_event_q->pHead;
+
+        while ( p_event ) {
+
+                bValidEvent = FALSE;
+                switch ( p_event->type ) {
+                        case ISR_INTERRUPT: {
+                            if (priIsr & p_event->param1 ) {
+                                        // return the complete ISR value
+                                        // not anded with the mask
+                                        p_event->result[0] = priIsr;
+                                        for (i=0;i<5;i++) {
+                                                p_event->result[1+i] = secIsr[i];
+                                        }
+                                bValidEvent    = TRUE;
+                             }
+                             break;
+                        }
+                        default:
+                                printk("DK::Ilegal event type found in ISR event queue!\n");
+                                break;
+                } // switch
+
+                if ( !bValidEvent ) {
+                        p_event = p_event->pNext;
+                        continue;
+                }
+
+                // put the event in the event triggered Q,
+                // either move or copy event, depending
+                // on the persistent flag
+                if ( p_event->persistent ) {
+                        p_event_copy = copyEvent(p_event);
+                        if( !p_event_copy ) {
+                                printk("DK::Unable to copy event in interrupt\n");
+                                break;
+                        }
+                        p_event_to_push = p_event_copy;
+                } else {
+                        if (!removeEvent(p_event, p_isr_event_q, FALSE) ) {
+                                printk("DK::Unable to remove event from ISR queue \n");
+                                break;
+                        }
+                        p_event_to_push = p_event;
+                }
+
+                // push the event onto the triggered queue
+                if (!pushEvent(p_event_to_push, p_trigered_event_q,FALSE) ) {
+                        printk("DK::Unable to push event onto triggered queue\n");
+                        break;
+                }
+
+                // increment to next event
+                p_event = p_event->pNext;
+        } // while ( p_event )
+
+        return TRUE;
+
+#else  // end AP83
+
+        if (p_client->device_class == SIMPLE_COMM_CLASS) {
+	    cli_reg_read(cli_id, 0x8, &priIsr);
+#ifdef DK_DEBUG
+	    printk("DK::Got interrupt from simple comm class \n");
+#endif
+	}
+	
+	if (p_client->device_class == NETWORK_CLASS) {
+	   /* Read the interrupt pending register */
+	   
+                cli_reg_read(cli_id, 0x4020, &macRev); 
+	        printk("macRev is 0x%x  \n", macRev);
+                if (((macRev >= 0xc0) && (macRev <= 0xdf)) || ((macRev & 0xff) == 0xff)) {
+                    UINT32 h_intr_enable;
+                    UINT32 h_intr_cause;
+
+                    cli_reg_read(cli_id, 0x403c,&h_intr_enable); // async intr enable
+                    cli_reg_read(cli_id, 0x4038,&h_intr_cause); // async intr cause
+                    if (!(h_intr_enable & h_intr_cause))  return FALSE;
+                }
+                else  {
+                    cli_reg_read(cli_id,0x4008,&reg_val);
+     	            if ((reg_val & 0x00000001) == 0x0) return FALSE;
+                }
+ 	
+	        /* Read the isr */
+	        cli_reg_read(cli_id,0x00c0,&priIsr);
+               if(!priIsr) {
+                        //this might be first gen
+                        cli_reg_read(cli_id, 0x1c,&priIsr);
+                }
+
+#ifdef DK_DEBUG
+	   printk("DK::Got interrupt:ISR = %x \n",priIsr);
+#endif
+
+	        cli_reg_read(cli_id,0x00c4,&secIsr[0]);
+	        cli_reg_read(cli_id,0x00c8,&secIsr[1]);
+	        cli_reg_read(cli_id,0x00cc,&secIsr[2]);
+	        cli_reg_read(cli_id,0x00d0,&secIsr[3]);
+	        cli_reg_read(cli_id,0x00d4,&secIsr[4]);
+	
+	}
+    
+	// catch spurios interrupts that comes before the client is registered
+	if (!BUSY_CLIENT(p_client)) return FALSE; 
+	
+	// start to scan the current queue of events
+	p_isr_event_q = &(p_client->isr_event_q);
+	p_trigered_event_q = &(p_client->trigered_event_q);
+	p_event = p_isr_event_q->pHead;
+
+	while ( p_event ) {
+
+		bValidEvent = FALSE;
+		switch ( p_event->type ) {
+			case ISR_INTERRUPT: {
+
+	                    if (priIsr & p_event->param1 ) {
+					// return the complete ISR value
+					// not anded with the mask
+					p_event->result[0] = priIsr;
+					for (i=0;i<5;i++) {
+						p_event->result[1+i] = secIsr[i];
+					}
+				bValidEvent    = TRUE;
+			     }
+	                     break;
+                        }
+			default:
+				printk("DK::Ilegal event type found in ISR event queue!\n"); 
+				break;
+		} // switch
+
+		if ( !bValidEvent ) {
+			p_event = p_event->pNext;
+			continue;
+		}
+
+		// put the event in the event triggered Q,
+		// either move or copy event, depending
+		// on the persistent flag
+		if ( p_event->persistent ) {
+			p_event_copy = copyEvent(p_event);
+			if( !p_event_copy ) {
+				printk("DK::Unable to copy event in interrupt\n");
+				break;
+			}
+			p_event_to_push = p_event_copy;
+		} else {
+			if (!removeEvent(p_event, p_isr_event_q, FALSE) ) {
+				printk("DK::Unable to remove event from ISR queue \n");
+				break;
+			}
+			p_event_to_push = p_event;
+		}
+
+		// push the event onto the triggered queue
+		if (!pushEvent(p_event_to_push, p_trigered_event_q,FALSE) ) {
+			printk("DK::Unable to push event onto triggered queue\n");
+			break;
+		}
+
+		// increment to next event
+		p_event = p_event->pNext;
+	} // while ( p_event )
+		
+	return TRUE;
+#endif
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/dk_pci_bus.c apps_1.2/art_1.2/art/modules/dk_pci_bus.c
--- apps/art_1.2/art/modules/dk_pci_bus.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/dk_pci_bus.c	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,461 @@
+/* dk_pci_bus.c - contains functions specific to pci bus */
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include "dk.h"
+#include "client.h"
+#define ATHEROS_VENDOR_ID 0x168c
+#define MAX_CFG_OFFSET	256
+#define PCIE_1_LINK_ADDRESS 0xb80f0018
+#define PCIE_2_LINK_ADDRESS 0xb8280018
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static INT32 dk_pci_enable_wake
+(
+ 	struct pci_dev *dev,
+	UINT32 state,
+	INT32 enable
+)
+{
+#ifdef DK_DEBUG
+		printk("DK::Pci enable wake \n");
+#endif
+		return 0;
+}
+#endif
+
+static INT32 dk_pci_probe
+(
+ 	struct pci_dev *dev,
+	const struct pci_device_id *id
+)
+{
+	INT32 error;
+
+	A_UINT_PTR baseaddr[MAX_BARS];
+
+	UINT32 len[MAX_BARS];
+	UINT32 irq;
+#if  defined(PYTHON_EMU)
+        UINT32 *addr;
+	INT32 pci_ret_val;
+#endif
+#ifndef PYTHON_EMU
+	UINT8  csz;
+	UINT32 val;
+#endif
+	UINT32 iIndex, numBars;
+#ifdef DK_DEBUG
+    UINT32 device_id, vendor_id;
+#endif
+	INT8 ret_val;
+	UINT32 sIndex = WMAC_FN_DEV_START_NUM;
+
+#ifdef DK_DEBUG
+	printk("DK::Pci probe \n");
+#endif
+
+	error = pci_enable_device(dev);
+	if (error != 0) {
+			printk(KERN_ERR "DK:: pci_enable_device failed \n");
+			return error;
+	}
+#ifndef PYTHON_EMU
+        pci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &csz);
+        if (csz == 0) {
+                /*
+                 * Linux 2.4.18 (at least) writes the cache line size
+                 * register as a 16-bit wide register which is wrong.
+                 * We must have this setup properly for rx buffer
+                 * DMA to work so force a reasonable value here if it
+                 * comes up zero.
+                 */
+                csz = L1_CACHE_BYTES / sizeof(UINT32);
+                pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, csz);
+        }
+        /*
+         * The default setting of latency timer yields poor results,
+         * set it to the value used by other systems.  It may be worth
+         * tweaking this setting more.
+         */
+        pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0xa8);
+
+        pci_set_master(dev);
+
+        /*
+         * Disable the RETRY_TIMEOUT register (0x41) to keep
+         * PCI Tx retries from interfering with C3 CPU state.
+         *
+         * Code taken from ipw2100 driver - jg
+         */
+        pci_read_config_dword(dev, 0x40, &val);
+        if ((val & 0x0000ff00) != 0)
+                pci_write_config_dword(dev, 0x40, val & 0xffff00ff);
+
+#endif
+
+#ifdef PYTHON_EMU
+
+#define CHIP_ID_LOCATION 0xb8060090
+#ifndef OCTEON
+        INT32 chip_rev_id=0;
+#endif
+
+
+#ifndef OWL_PB42
+        get_chip_id(0,CHIP_ID_LOCATION,4,&chip_rev_id);
+#endif
+#define CHIP_REV_ID_SCORPION_A 0x013 // last nibble is for Chip revision which is ignored
+#define CHIP_REV_ID_SCORPION_B 0x113 // last nibble is for Chip revision which is ignored
+#define CHIP_REV_ID_DRANGONFLY 0x15
+	// Scorpion packages A and B (PCIE_2_LINK_ADDRESS is only valid for Scorpion)
+	// Dragonfly has one pcie at PCIE_2_LINK_ADDRESS.
+	if ((((chip_rev_id& 0xfff0)>>4) == CHIP_REV_ID_SCORPION_A)||
+	  (((chip_rev_id& 0xfff0)>>4) == CHIP_REV_ID_SCORPION_B)||
+	  (((chip_rev_id& 0x0ff0)>>4) == CHIP_REV_ID_DRANGONFLY)){
+		addr = (UINT32 *)(PCIE_2_LINK_ADDRESS);
+		pci_ret_val = readl(addr);
+		if(pci_ret_val==7){
+			pci_write_config_dword(dev,0x10,0x1201ffff);
+		}	  
+	}
+	if (((chip_rev_id& 0x0ff0)>>4) != CHIP_REV_ID_DRANGONFLY) {
+		addr = (UINT32 *)(PCIE_1_LINK_ADDRESS);
+		pci_ret_val = readl(addr);
+		if(pci_ret_val==7){
+			pci_write_config_dword(dev,0x10,0xffff);
+		}
+	}
+#endif
+
+    for (iIndex=0; iIndex<MAX_BARS; iIndex++) {
+	  baseaddr[iIndex] = pci_resource_start(dev,iIndex);
+
+	printk(KERN_ERR" Base Phsycal address :0x%08lx\n", baseaddr[iIndex]);
+
+	  len[iIndex] = pci_resource_len(dev,iIndex);
+      if (len[iIndex] == 0) break;
+    }
+    numBars = iIndex;
+#ifdef DK_DEBUG
+	printk("DK::num bars = %d\n", numBars);
+	(void) pci_read_config_dword(dev, PCI_DEVICE_ID, &device_id);
+	(void) pci_read_config_dword(dev, PCI_VENDOR_ID, &vendor_id);
+    printk("DK::Vendor Id=%x:Device id = %x\n", vendor_id, device_id);
+#endif
+	irq = dev->irq;
+
+#ifndef PYTHON_EMU
+    for (iIndex=0; iIndex<numBars; iIndex++) {
+
+	   pci_write_config_byte(dev,PCI_INTERRUPT_LINE, irq);
+    }
+#endif
+	(void) pci_read_config_byte(dev, 0xb, &ret_val); // Get the class code
+	if (ret_val == NETWORK_CLASS) {
+		sIndex = WMAC_FN_DEV_START_NUM;
+	}
+	if (ret_val == SIMPLE_COMM_CLASS) {
+		sIndex = UART_FN_DEV_START_NUM;
+	}
+	printk("Class code = %d:start search index=%d\n", ret_val, sIndex);
+
+	if (add_client(dev,baseaddr,len,irq, numBars, sIndex,1) < 0) {
+		printk(KERN_ERR "DK:: unable to add client \n");
+#if LINUX_VERSION_CODE > 132098
+		pci_disable_device(dev);
+#endif
+		return -ENODEV;
+	}
+
+#if 0
+	virmem = (UINT32)ioremap(pci_resource_start(dev, 0), pci_resource_len(dev,0));
+
+        printk(KERN_ERR"IOREMAP Addr: 0x%x\n", virmem);
+
+	writel(0x1, (UINT32*)((UINT8*)virmem+0x704c));
+	writel(0x0, (UINT32*)((UINT8*)virmem+0x7040));
+	writel(0x5, (UINT32*)((UINT8*)virmem+0x7040));
+	printk(KERN_ERR" Address: 0x%x, Status****: 0x%x\n", (UINT32)((UINT8*)virmem+0x7044), readl((UINT32*)((UINT8*)virmem+0x7044)));
+#endif
+	return 0;
+}
+
+static VOID dk_pci_remove
+(
+	struct pci_dev *dev
+)
+{
+#ifdef DK_DEBUG
+	printk("DK::Pci remove \n");
+#endif
+	remove_client(dev);
+#if LINUX_VERSION_CODE > 132098
+	pci_disable_device(dev);
+#endif
+
+	return;
+}
+
+#if LINUX_VERSION_CODE >= 132623
+static INT32 dk_pci_suspend
+(
+ 	struct pci_dev *dev,
+	pm_message_t state
+)
+#elif (LINUX_VERSION_CODE > 132098) && (LINUX_VERSION_CODE < 132623)
+static INT32 dk_pci_suspend
+(
+ 	struct pci_dev *dev,
+	UINT32 state
+)
+#else
+static VOID dk_pci_suspend
+(
+ 	struct pci_dev *dev
+)
+#endif
+{
+#ifdef DK_DEBUG
+		printk("DK::Pci suspend \n");
+#endif
+#if LINUX_VERSION_CODE > 132098
+		return 0;
+#else
+		return;
+#endif
+}
+
+#if LINUX_VERSION_CODE > 132098
+static INT32 dk_pci_resume
+(
+	struct pci_dev *dev
+)
+#else
+static VOID dk_pci_resume
+(
+	struct pci_dev *dev
+)
+#endif
+{
+#ifdef DK_DEBUG
+		printk("DK::Pci resume \n");
+#endif
+#if LINUX_VERSION_CODE > 132098
+		return 0;
+#else
+		return;
+#endif
+}
+
+
+static struct pci_device_id __devinitdata dk_id_tbl[] = {
+
+	{ATHEROS_VENDOR_ID, 0x0011, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"MAUI"},
+	{ATHEROS_VENDOR_ID, 0x0012, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OAHU"},
+	{ATHEROS_VENDOR_ID, 0x0013, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"VENICE"},
+	{ATHEROS_VENDOR_ID, 0x0014, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"VENICE_DERBY"},
+	{ATHEROS_VENDOR_ID, 0xff16, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"GRIFFIN_MAC"},
+	{ATHEROS_VENDOR_ID, 0x0023, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OWL"},
+	{ATHEROS_VENDOR_ID, 0x0026, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"NALA"},
+	{ATHEROS_VENDOR_ID, 0x0027, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"SOWL"},
+	{ATHEROS_VENDOR_ID, 0xff1c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"SOWL"},
+	{ATHEROS_VENDOR_ID, 0x0028, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"SOWL_PCIE"},
+	{ATHEROS_VENDOR_ID, 0x0029, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"MERLIN"},
+	{ATHEROS_VENDOR_ID, 0x002a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"MERLIN_PCIE"},
+	{ATHEROS_VENDOR_ID, 0x002b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"KITE_PCIE"},
+	{ATHEROS_VENDOR_ID, 0xff1d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OWL"},
+	{ATHEROS_VENDOR_ID, 0x001d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"NALA"},
+	{ATHEROS_VENDOR_ID, 0xff1a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"NALA"},
+    {ATHEROS_VENDOR_ID, 0x002d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"KIWI"},
+    {ATHEROS_VENDOR_ID, 0x002e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"KIWI_PCIE"},
+    {ATHEROS_VENDOR_ID, 0x0030, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OSPREY"},
+    {ATHEROS_VENDOR_ID, 0x0033, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"PEACOCK"},
+    {ATHEROS_VENDOR_ID, 0xabcd, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"OSPREY"},
+	{0,}
+};
+
+
+#ifdef DK_UART
+static struct pci_device_id __devinitdata dk_uart_id_tbl[] = {
+	{ATHEROS_VENDOR_ID, 0xff96, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (unsigned long)"GRIFFIN_UART"},
+	{0,}
+};
+#endif
+
+static struct pci_driver dkpci_driver = {
+		name:	"dkkernel",
+		id_table: dk_id_tbl,
+		probe: dk_pci_probe,
+		remove: dk_pci_remove,
+		suspend: dk_pci_suspend,
+		resume: dk_pci_resume,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+		enable_wake: dk_pci_enable_wake
+#endif
+};
+
+#ifdef DK_UART
+
+static struct pci_driver dkuart_pci_driver = {
+		name:	"dkuartkernel",
+		id_table: dk_uart_id_tbl,
+		probe: dk_pci_probe,
+		remove: dk_pci_remove,
+		suspend: dk_pci_suspend,
+		resume: dk_pci_resume,
+};
+
+#endif
+INT32 bus_module_init
+(
+ 	VOID
+)
+{
+	int status;
+#ifdef DK_DEBUG
+	printk("DK::Bus module init  \n");
+#endif // DK_DEBUG
+#ifdef MODULE
+#ifdef DK_DEBUG
+	printk("DK::MODULE\n");
+#endif // DK_DEBUG
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	status = pci_module_init(&dkpci_driver);
+#else
+	status = pci_register_driver(&dkpci_driver);
+#endif
+	printk("DK::bus_module_init:status=%d from dkpci_driver\n", status);
+#ifdef DK_UART
+	status |= pci_module_init(&dkuart_pci_driver);
+	printk("DK::bus_module_init:status=%d from dkuart_pci_driver\n", status);
+#endif
+	return status;
+#else
+	return pci_register_driver(&dkpci_driver);
+#endif // MODULE
+}
+
+VOID bus_module_exit
+(
+ 	VOID
+)
+{
+#ifdef DK_DEBUG
+	printk("DK::Bus module exit  \n");
+#endif // DK_DEBUG
+	pci_unregister_driver(&dkpci_driver);
+#ifdef DK_UART
+	pci_unregister_driver(&dkuart_pci_driver);
+#endif
+}
+
+#ifdef MODULE
+MODULE_DEVICE_TABLE(pci,dk_id_tbl);
+#endif
+
+INT32 bus_dev_init
+(
+ 	void  *bus_dev
+)
+{
+	struct pci_dev *dev;
+	UINT32 baseaddr;
+	UINT32 irq;
+
+	dev = (struct pci_dev *)bus_dev;
+	pci_set_master(dev);
+
+	baseaddr = pci_resource_start(dev,0);
+	irq = dev->irq;
+
+	/*
+	 * Program the base address and irq as the device may
+	 * be hotplugged without aware of the kernel
+	 */
+#ifndef PYTHON_EMU
+	pci_write_config_dword(dev,PCI_BASE_ADDRESS_0, baseaddr);
+	pci_write_config_byte(dev,PCI_INTERRUPT_LINE, irq);
+
+#endif
+	return 0;
+}
+
+VOID bus_dev_exit
+(
+ 	void  *bus_dev
+)
+{
+	return;
+}
+
+INT32 bus_cfg_read
+(
+ 	void  *bus_dev,
+ 	INT32 offset,
+	INT32 size,
+	INT32 *ret_val
+)
+{
+	struct pci_dev *dev;
+	int ret =  -1;
+
+	dev = (struct pci_dev *)bus_dev;
+
+	if (size < MAX_CFG_OFFSET) {
+		switch (size) {
+			case 1:
+				ret = pci_read_config_byte(dev,offset, (INT8 *)ret_val);
+				break;
+			case 2:
+				offset = offset & 0xfe;
+				ret = pci_read_config_word(dev,offset, (INT16 *)ret_val);
+				break;
+			case 4:
+				offset = offset & 0xfc;
+				ret = pci_read_config_dword(dev,offset, ret_val);
+				break;
+			default:
+				break;
+		}
+	}
+
+	return ret;
+
+}
+
+INT32 bus_cfg_write
+(
+ 	void  *bus_dev,
+ 	INT32 offset,
+	INT32 size,
+	INT32 val
+)
+{
+	struct pci_dev *dev;
+	int ret =  -1;
+
+	dev = (struct pci_dev *)bus_dev;
+	if (size < MAX_CFG_OFFSET) {
+		switch (size) {
+			case 1:
+				ret = pci_write_config_byte(dev,offset, val);
+				break;
+			case 2:
+				offset = offset & 0xfe;
+				ret = pci_write_config_word(dev,offset, val);
+				break;
+			case 4:
+				offset = offset & 0xfc;
+				ret = pci_write_config_dword(dev,offset,val);
+				break;
+			default:
+				break;
+		}
+	}
+
+	return ret;
+}
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/client.h apps_1.2/art_1.2/art/modules/include/client.h
--- apps/art_1.2/art/modules/include/client.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/client.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,164 @@
+#ifndef __CLIENT_H_
+#define __CLIENT_H_
+
+#include "dk.h"
+#include "dk_ioctl.h"
+#include "dk_event.h"
+
+#define MAX_CLIENTS_SUPPORTED 8
+#define INVALID_CLIENT -1
+#define DK_MAJOR_NUMBER 63
+#define DK_UART_MAJOR_NUMBER 64
+#define WMAC_FN_DEV_START_NUM      0
+#define UART_FN_DEV_START_NUM      4
+#define NETWORK_CLASS   0x2
+#define SIMPLE_COMM_CLASS       0x7
+
+
+
+/* atheros devices info */
+struct atheros_dev_ {
+    void *bus_dev;
+	A_UINT_PTR reg_phy_addr;
+	A_UINT_PTR reg_ker_vir_addr;
+	UINT32 reg_range;
+	A_UINT_PTR mem_phy_addr;
+	A_UINT_PTR mem_ker_vir_addr;
+	UINT32 mem_size;
+	UINT32 irq;
+    UINT32 dev_busy;
+	UINT32 cli_id;		// cli_id is same as the array index in the dev_table
+	event_queue isr_event_q;
+	event_queue trigered_event_q;
+	A_UINT_PTR areg_phy_addr[MAX_BARS];
+    A_UINT_PTR areg_ker_vir_addr[MAX_BARS];
+	UINT32 areg_range[MAX_BARS];
+    UINT32 numBars;
+    UINT32 device_class;
+	UINT32 dma_mem_addr;
+};
+
+typedef struct atheros_dev_ atheros_dev;
+typedef struct atheros_dev_ *p_atheros_dev;
+
+VOID init_client
+(
+ 	VOID
+);
+
+INT32 add_client
+(
+ 	VOID *bus_dev,
+	A_UINT_PTR baseaddr[MAX_BARS],
+	UINT32 len[MAX_BARS],
+	UINT32 irq,
+    UINT32 numBars,
+    UINT32 sIndex,
+    int pci
+);
+
+VOID remove_client
+(
+ 	VOID *bus_dev
+);
+
+VOID cleanup_client
+(
+     VOID
+);
+
+INT32 register_client
+(
+     INT32 major,
+     INT32 minor
+);
+
+
+VOID unregister_client
+(
+     INT32 cli_id
+);
+
+INT32 cli_cfg_read
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	INT32 size,
+	INT32 *ret_val
+);
+
+
+INT32 cli_cfg_write
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	INT32 size,
+	INT32 ret_val
+);
+
+INT32 cli_reg_read
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	UINT32 *ret_val
+);
+
+
+INT32 cli_reg_write
+(
+ 	INT32 cli_id,
+	INT32 offset,
+	UINT32 ret_val
+);
+
+INT32 get_cli_info
+(
+     INT32 cli_id,
+     struct client_info *ci
+);
+
+p_atheros_dev get_client
+(
+     INT32 cli_id
+);
+
+INT32 rtc_reg_read
+(
+        INT32 cli_id,           
+        INT32 offset,                   
+        INT32 *ret_val                  
+);
+
+INT32 full_addr_read
+(
+        INT32 cli_id,
+        INT32 offset,
+        INT32 *ret_val
+);
+INT32 full_addr_write
+(
+        INT32 cli_id,           
+        INT32 offset,                   
+        UINT32 ret_val                  
+);
+
+INT32 get_chip_id                     
+(                               
+        INT32 cli_id,                   
+        INT32 offset,           
+        INT32 size,             
+        INT32 *ret_val          
+);                       
+
+INT32 rtc_reg_write
+(
+        INT32 cli_id,
+        INT32 offset,
+        UINT32 data
+);
+
+
+#define VALID_CLIENT(x) ((x)->cli_id != INVALID_CLIENT)
+#define BUSY_CLIENT(x) ((x)->dev_busy != 0)
+
+#endif // __CLIENT_H_
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/dk_event.h apps_1.2/art_1.2/art/modules/include/dk_event.h
--- apps/art_1.2/art/modules/include/dk_event.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/dk_event.h	2014-05-30 03:43:07.296515324 -0700
@@ -0,0 +1,93 @@
+/* dk_event.h - contains definitions for event.c */
+
+/*
+                Copyright (c) 2014 Qualcomm Atheros, Inc. All rights reserved.
+                Qualcomm is a trademark of Qualcomm Technologies Incorporated, registered in the United States and other countries.
+                All Qualcomm Technologies Incorporated trademarks are used with permission.
+                Atheros is a trademark of Qualcomm Atheros, Inc., registered in the United States and other countries.
+                Other products and brand names may be trademarks or registered trademarks of their respective owners.
+*/
+
+#ifndef __DK_EVENT_H_
+#define __DK_EVENT_H_
+
+#include "dk.h"
+
+#define INTERRUPT_F2    1
+#define TIMEOUT         4
+#define ISR_INTERRUPT   0x10
+#define DEFAULT_TIMEOUT 0xff
+
+typedef struct event_handle_ {
+    UINT32 eventID;
+    UINT32 f2Handle;
+} event_handle;
+
+struct event_struct_ {
+	struct event_struct_ *pNext;         // pointer to next event
+	struct event_struct_ *pLast;         // backward pointer to pervious event
+	event_handle    eventHandle;
+	UINT32            type;
+	UINT32            persistent;
+	UINT32            param1;
+	UINT32            param2;
+	UINT32            param3;
+	UINT32            result[6];
+};
+
+typedef struct event_struct_ event_struct;
+typedef struct event_struct_ *p_event_struct;
+
+typedef struct event_queue_ {
+	p_event_struct  pHead;     // pointer to first event in queue
+	p_event_struct   pTail;     // pointer to last event in queue
+	UINT16       queueSize;  // count of how many items are in queue
+	UINT32		flags;
+} event_queue, *p_event_queue;
+
+void initEventQueue(p_event_queue);
+
+void deleteEventQueue(p_event_queue);
+
+p_event_struct createEvent
+(
+	UINT32    type,          // the event ID
+	UINT32    persistent,    // set if want a persistent event
+	UINT32    param1,        // optional args
+	UINT32    param2,
+	UINT32    param3,
+	event_handle    eventHandle
+);
+
+p_event_struct copyEvent
+(
+	p_event_struct pExistingEvent // pointer to event to copy
+);
+
+UINT16 pushEvent
+(
+	p_event_struct pEvent,    // pointer to event to add
+	p_event_queue pQueue,     // pointer to queue to add to
+	BOOLEAN          protect
+);
+
+p_event_struct popEvent
+(
+	p_event_queue pQueue, // pointer to queue to add to
+	BOOLEAN          protect
+);
+
+UINT16 removeEvent
+(
+	p_event_struct    pEvent,
+	p_event_queue     pQueue,
+	BOOLEAN          protect
+);
+
+UINT16 checkForEvents
+(
+	p_event_queue pQueue,
+	BOOLEAN          protect
+);
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/dk_flash.h apps_1.2/art_1.2/art/modules/include/dk_flash.h
--- apps/art_1.2/art/modules/include/dk_flash.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/dk_flash.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,27 @@
+/*
+ * SPI Flash Memory support header file.
+ *
+ * $Id: //depot/sw/branches/art2_main_per_cs/src/art2/driver/linux/modules/include/dk_flash.h#1 $
+ *
+ *
+ * Copyright (c) 2005, Atheros Communications Inc.
+ *
+ * This code is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#define CYGNUM_FLASH_BLOCK_SIZE  0x10000
+#define FALSE 0
+#define TRUE 1
+#define CYGNUM_FLASH_END_RESERVED_BYTES 0x10000
+
+#define DK_BOARDCONFIG_SIZE 0x1000
+#define DK_RADIOCONFIG_SIZE 0x1000
+
+int flash_init(void);
+void flash_exit(void);
+unsigned int dk_flash_read (int flc, unsigned int offset, size_t len, UINT8 * buf);
+unsigned int dk_flash_write (int flc, unsigned int offset, size_t len, UINT8 * buf);
+
+/**********************************************************************/
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/dk.h apps_1.2/art_1.2/art/modules/include/dk.h
--- apps/art_1.2/art/modules/include/dk.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/dk.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,42 @@
+/* dk.h - contains variable declarations */
+
+#ifndef __DK_H_
+#define __DK_H_
+
+// Driver information
+#define DRV_NAME    "linuxdk"
+#define DRV_MAJOR_VERSION 1
+#define DRV_MINOR_VERSION 2
+
+#ifdef MODULE
+#define MOD_LICENCE "GPL"
+#define MOD_AUTHOR "muddin@atheros.com"
+#define MOD_DESCRIPTION "Linux MDK driver 1.0" 
+#endif
+
+// Common variable types are typedefed 
+typedef short INT16;
+typedef unsigned short UINT16;
+typedef int INT32;
+typedef long A_INT_PTR;
+typedef unsigned long A_UINT_PTR;
+typedef unsigned int UINT32;
+typedef char CHAR8;
+typedef unsigned char UCHAR8;
+typedef char INT8;
+typedef unsigned char UINT8;
+typedef void VOID;
+
+#ifndef NULL
+#define NULL (void *)0
+#endif
+
+#define MAX_BARS 6
+
+typedef enum 
+{
+		FALSE=0,
+		TRUE
+} BOOLEAN;
+
+#endif // __DK_H_
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/dk_ioctl.h apps_1.2/art_1.2/art/modules/include/dk_ioctl.h
--- apps/art_1.2/art/modules/include/dk_ioctl.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/dk_ioctl.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,64 @@
+#ifndef __DK_IOCTL_H_
+#define __DK_IOCTL_H_
+
+
+#define DK_IOCTL_GET_VERSION 1
+#define DK_IOCTL_GET_CLIENT_INFO 2
+#define DK_IOCTL_CFG_READ 3
+#define DK_IOCTL_CFG_WRITE 4
+#define DK_IOCTL_CREATE_EVENT 5
+#define DK_IOCTL_GET_NEXT_EVENT 6
+#define DK_IOCTL_SYS_REG_READ_32 7
+#define DK_IOCTL_SYS_REG_WRITE_32 8
+#define DK_IOCTL_FLASH_READ 9
+#define DK_IOCTL_FLASH_WRITE 10
+#define DK_IOCTL_MAC_WRITE 11
+#define DK_IOCTL_GET_CHIP_ID 12
+#define DK_IOCTL_RTC_REG_READ 13
+#define DK_IOCTL_RTC_REG_WRITE 14
+#define DK_IOCTL_FULL_ADDR_READ 15
+#define DK_IOCTL_FULL_ADDR_WRITE 16
+
+#undef MAX_BARS
+#define MAX_BARS    6
+
+struct cfg_op {
+	int offset;
+	int size;
+	int value;
+};
+struct client_info {
+    unsigned long reg_phy_addr;
+    int reg_range;
+    unsigned long mem_phy_addr;
+    int mem_size;
+    int irq;
+    unsigned long areg_phy_addr[MAX_BARS];
+    int areg_range[MAX_BARS];
+    int numBars;
+    int device_class;
+    unsigned int dma_mem_addr;
+};
+
+struct event_op {
+	unsigned int valid;
+	unsigned int param[16];
+};
+
+struct flash_op{
+	int fcl;
+	int offset;
+	int len;
+	int retlen;
+	unsigned char value;
+};
+
+struct flash_op_wr{
+	int fcl;
+	int offset;
+	int len;
+	int retlen;
+	unsigned char *pvalue;
+};
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/dk_pci_bus.h apps_1.2/art_1.2/art/modules/include/dk_pci_bus.h
--- apps/art_1.2/art/modules/include/dk_pci_bus.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/dk_pci_bus.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,47 @@
+/* pci_bus.h - contains declarations of the pci bus functions */
+
+#ifndef __DK_PCI_BUS_H_
+#define __DK_PCI_BUS_H_
+
+#include "dk.h"
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+INT32 bus_module_init
+(
+	VOID
+);
+
+VOID bus_module_exit
+(
+	VOID
+);
+
+INT32 bus_dev_init
+(
+     void *bus_dev
+);
+
+
+INT32 bus_dev_exit
+(
+     void  *bus_dev
+);
+
+INT32 bus_cfg_read
+(
+     void *bus_dev,
+     INT32 offset,
+     INT32 size,
+     INT32 *ret_val
+);
+
+INT32 bus_cfg_write
+(
+    void *bus_dev,
+    INT32 offset,
+	INT32 size,
+	INT32 ret_val
+);
+
+#endif
+		
+#endif //__PCI_BUS_H_
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/flbase.h apps_1.2/art_1.2/art/modules/include/flbase.h
--- apps/art_1.2/art/modules/include/flbase.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/flbase.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,188 @@
+
+#ifndef FLBASE_H
+#define FLBASE_H
+
+#include "flcustom.h"
+
+/* standard type definitions */
+typedef int 		FLBoolean;
+
+/* Boolean constants */
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+#ifndef TRUE
+#define	TRUE	1
+#endif
+
+#ifndef ON
+#define	ON	1
+#endif
+#ifndef OFF
+#define	OFF	0
+#endif
+
+#define SECTOR_SIZE		(1 << SECTOR_SIZE_BITS)
+
+
+
+#define FAR_LEVEL       0
+/* define SectorNo range according to media maximum size */
+#if (MAX_VOLUME_MBYTES * 0x100000l) / SECTOR_SIZE > 0x10000l
+typedef unsigned long SectorNo;
+#define	UNASSIGNED_SECTOR 0xffffffffl
+#else
+typedef unsigned short SectorNo;
+#define UNASSIGNED_SECTOR 0xffff
+#endif
+
+#if FAR_LEVEL > 0
+  #define FAR0	far
+#else
+  #define FAR0
+#endif
+
+#if FAR_LEVEL > 1
+  #define FAR1	far
+#else
+  #define FAR1
+#endif
+
+#if FAR_LEVEL > 2
+  #define FAR2	far
+#else
+  #define FAR2
+#endif
+
+
+#define vol (*pVol)
+
+
+#ifndef BIG_ENDIAN
+
+typedef unsigned short LEushort;
+typedef unsigned long LEulong;
+
+#define LE2(arg)	arg
+#define	toLE2(to,arg)	(to) = (arg)
+#define LE4(arg)	arg
+#define	toLE4(to,arg)	(to) = (arg)
+#define COPY2(to,arg)	(to) = (arg)
+#define COPY4(to,arg)	(to) = (arg)
+
+typedef unsigned char Unaligned[2];
+typedef Unaligned Unaligned4[2];
+
+#define UNAL2(arg)	fromUNAL(arg)
+#define toUNAL2(to,arg)	toUNAL(to,arg)
+
+#define UNAL4(arg)	fromUNALLONG(arg)
+#define toUNAL4(to,arg)	toUNALLONG(to,arg)
+
+extern void toUNAL(unsigned char FAR0 *unal, unsigned n);
+
+extern unsigned short fromUNAL(unsigned char const FAR0 *unal);
+
+extern void toUNALLONG(Unaligned FAR0 *unal, unsigned long n);
+
+extern unsigned long fromUNALLONG(Unaligned const FAR0 *unal);
+
+#else
+
+typedef unsigned char LEushort[2];
+typedef unsigned char LEulong[4];
+
+#define LE2(arg)	fromLEushort(arg)
+#define	toLE2(to,arg)	toLEushort(to,arg)
+#define LE4(arg)	fromLEulong(arg)
+#define	toLE4(to,arg)	toLEulong(to,arg)
+#define COPY2(to,arg)	copyShort(to,arg)
+#define COPY4(to,arg)	copyLong(to,arg)
+
+#define	Unaligned	LEushort
+#define	Unaligned4	LEulong
+
+extern void toLEushort(unsigned char FAR0 *le, unsigned n);
+
+extern unsigned short fromLEushort(unsigned char const FAR0 *le);
+
+extern void toLEulong(unsigned char FAR0 *le, unsigned long n);
+
+extern unsigned long fromLEulong(unsigned char const FAR0 *le);
+
+extern void copyShort(unsigned char FAR0 *to,
+		      unsigned char const FAR0 *from);
+
+extern void copyLong(unsigned char FAR0 *to,
+		     unsigned char const FAR0 *from);
+
+#define	UNAL2		LE2
+#define	toUNAL2		toLE2
+
+#define	UNAL4		LE4
+#define	toUNAL4		toLE4
+
+#endif /* BIG_ENDIAN */
+
+
+typedef enum {flOK 		= 0,	/* Status code for operation.
+					   A zero value indicates success,
+					   other codes are the extended
+					   DOS codes. */
+	     flBadFunction	= 1,
+	     flFileNotFound	= 2,
+	     flPathNotFound	= 3,
+	     flTooManyOpenFiles = 4,
+	     flNoWriteAccess	= 5,
+	     flBadFileHandle	= 6,
+	     flDriveNotAvailable = 9,
+	     flNonFATformat	= 10,
+	     flFormatNotSupported = 11,
+	     flNoMoreFiles	= 18,
+	     flWriteProtect 	= 19,
+	     flBadDriveHandle	= 20,
+	     flDriveNotReady 	= 21,
+	     flUnknownCmd 	= 22,
+	     flBadFormat	= 23,
+	     flBadLength	= 24,
+	     flDataError	= 25,
+	     flUnknownMedia 	= 26,
+	     flSectorNotFound 	= 27,
+	     flOutOfPaper 	= 28,
+	     flWriteFault 	= 29,
+	     flReadFault	= 30,
+	     flGeneralFailure 	= 31,
+	     flDiskChange 	= 34,
+	     flVppFailure	= 50,
+	     flBadParameter	= 51,
+	     flNoSpaceInVolume	= 52,
+	     flInvalidFATchain	= 53,
+	     flRootDirectoryFull = 54,
+	     flNotMounted	= 55,
+	     flPathIsRootDirectory = 56,
+	     flNotADirectory	= 57,
+	     flDirectoryNotEmpty = 58,
+	     flFileIsADirectory	= 59,
+	     flAdapterNotFound	= 60,
+	     flFormattingError	= 62,
+	     flNotEnoughMemory	= 63,
+	     flVolumeTooSmall	= 64,
+	     flBufferingError	= 65,
+	     flFileAlreadyExists = 80,
+
+	     flIncomplete	= 100,
+	     flTimedOut		= 101,
+	     flTooManyComponents = 102
+
+	     } FLStatus;
+
+/* call a procedure returning status and fail if it fails. This works only in
+   routines that return Status */
+
+#define checkStatus(exp)      {	FLStatus status = (exp); \
+				if (status != flOK)	 \
+				  return status; }
+
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/flbuffer.h apps_1.2/art_1.2/art/modules/include/flbuffer.h
--- apps/art_1.2/art/modules/include/flbuffer.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/flbuffer.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,44 @@
+
+/*
+ * $Log:   P:/user/amir/lite/vcs/flbuffer.h_v  $
+   
+      Rev 1.5   10 Sep 1997 16:15:52   danig
+   Got rid of generic names
+   
+      Rev 1.4   28 Aug 1997 16:47:30   danig
+   include flbase.h
+   
+      Rev 1.3   07 Jul 1997 15:23:28   amirban
+   Ver 2.0
+   
+      Rev 1.2   18 Aug 1996 13:48:02   amirban
+   Comments
+   
+      Rev 1.1   01 Jul 1996 15:41:58   amirban
+   Doesn't define buffer
+   
+      Rev 1.0   20 Mar 1996 13:33:20   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+#ifndef FLBUFFER_H
+#define FLBUFFER_H
+
+#include "flbase.h"
+
+typedef struct {
+  unsigned char data[SECTOR_SIZE];	/* sector buffer */
+  SectorNo	sectorNo;		/* current sector in buffer */
+  void		*owner;			/* owner of buffer */
+  FLBoolean	dirty;			/* sector in buffer was changed */
+  FLBoolean	checkPoint;		/* sector in buffer must be flushed */
+} FLBuffer;
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/flcustom.h apps_1.2/art_1.2/art/modules/include/flcustom.h
--- apps/art_1.2/art/modules/include/flcustom.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/flcustom.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,317 @@
+/*
+ * $Log:   P:/user/amir/lite/vcs/flcustom.h_v  $
+
+      Rev 1.10   14 Aug 1997 16:05:12   danig
+   MIN_CLUSTER_SIZE
+
+      Rev 1.9   04 Aug 1997 13:13:48   danig
+   Low level API
+
+      Rev 1.8   24 Jul 1997 18:11:14   amirban
+   Moved stuff to flsystem.h
+
+      Rev 1.7   07 Jul 1997 15:23:42   amirban
+   Ver 2.0
+
+      Rev 1.6   21 Oct 1996 18:12:58   amirban
+   Split/join option
+
+      Rev 1.5   14 Aug 1996 14:16:26   amirban
+   BACKGROUND
+
+      Rev 1.4   14 Jul 1996 16:48:56   amirban
+   No more formatting parameters
+
+      Rev 1.3   09 Jul 1996 14:36:38   amirban
+   CPU_i386 define
+
+      Rev 1.2   08 Jul 1996 17:21:00   amirban
+   Added ABS_READ_WRITE
+
+      Rev 1.1   19 Jun 1996 15:23:10   amirban
+   Added EXIT option
+
+      Rev 1.0   19 May 1996 19:44:42   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+
+#ifndef FLCUSTOM_H
+#define FLCUSTOM_H
+
+/*
+ *
+ *		Section 2: File System Customization
+ *		------------------------------------
+ */
+
+/* ISSUE #2.1: Number of drives
+ *
+ * Defines the maximum number of drives (and sockets) supported.
+ *
+ * The actual number of drives depends on which socket controllers are
+ * actually registered.
+ */
+
+#define DRIVES	5
+
+
+/* ISSUE #2.1: Number of open files
+ *
+ * Defines the maximum number of files that may be open at a time.
+ */
+
+#define FILES	  0
+
+
+/* ISSUE #2.2: Sector size
+ *
+ * Define the log2 of sector size for the FAT & FTL layer. Note that the
+ * default 512 bytes is the de-facto standard and practically the only one
+ * that provides real PC interoperability.
+ */
+
+#define SECTOR_SIZE_BITS	9
+
+
+/* ISSUE #2.3: Formatting
+ *
+ * Uncomment the following line if you need to format with fsFormatVolume.
+ */
+
+#define FORMAT_VOLUME
+
+
+/* ISSUE #2.4: Defragmentation
+ *
+ * Uncomment the following line if you need to defragment with
+ * fsDefragmentVolume.
+ */
+
+/* #define DEFRAGMENT_VOLUME */
+
+
+/* ISSUE #2.5: Sub-directories
+ *
+ * Uncomment the following line if you need support for sub-directories
+ */
+
+/* #define SUB_DIRECTORY */
+
+
+/* ISSUE #2.6: Rename file
+ *
+ * Uncomment the following line if you need to rename files with fsRenameFile.
+ */
+
+/* #define RENAME_FILE */
+
+
+/* ISSUE #2.7: Split / join file
+ *
+ * Uncomment the following line if you need to split or join files with
+ * fsSplitFile and fsJoinFile
+ */
+
+/* #define SPLIT_JOIN_FILE */
+
+
+/* ISSUE #2.8: 12-bit FAT support
+ *
+ * Comment the following line if you do not need support for DOS media with
+ * 12-bit FAT (typically media of 2 MBytes or less).
+ */
+
+#define FAT_12BIT
+
+
+/* ISSUE #2.9: Parse path function
+ *
+ * Uncomment the following line if you need to parse DOS-like path names
+ * with fsParsePath.
+ */
+
+/* #define PARSE_PATH */
+
+
+/* ISSUE #2.10: Maximum supported medium size
+ *
+ * Define here the largest Flash medium size (in MBytes) you want supported.
+ */
+
+#define MAX_VOLUME_MBYTES	40
+
+
+/* ISSUE #2.11: Assumed card parameters
+ *
+ * This issue is relevant only if you are not defining any allocation
+ * routines in #5.2.
+ *
+ * The following are assumptions about FTL parameters of the Flash media.
+ * They affect the size of the heap buffer allocated in FTLLITE.C.
+ */
+
+#define ASSUMED_FTL_UNIT_SIZE	0x20000l	/* Intel interleave-2 */
+#define	ASSUMED_VM_LIMIT	0x10000l	/* limit at 64 KB */
+#define ASSUMED_NFTL_UNIT_SIZE	0x4000l
+
+
+/* ISSUE #2.12: Number of buffers
+ *
+ * Normally two sector buffers are needed, one for the FAT layer, another
+ * for the FTL layer. You may save about 512 bytes of RAM requirements by
+ * uncommenting the following definition.
+ * This will come at the cost of both read and write performance.
+ */
+
+/*#define SINGLE_BUFFER */
+
+
+/* ISSUE #2.13: Absolute read & write
+ *
+ * Uncomment the following line if you want to be able to read & write
+ * sectors by absolute sector number (i.e. without regard to files and
+ * directories).
+ */
+
+#define ABS_READ_WRITE
+
+
+/* ISSUE #2.14: Low level operations
+ *
+ * Uncomment the following line if you want to do low level operations.
+ * Low level operations include: read from a physical address, write to
+ * a physical address, erase a unit according to its physical unit number.
+ */
+
+#define LOW_LEVEL
+
+
+/* ISSUE #2.15: Application exit
+ *
+ * If the FLite application ever exits, it needs to call fsEXit before
+ * exitting. Uncomment the following line to enable this.
+ */
+
+/* #define EXIT */
+
+
+/* ISSUE #2.16: Number of sectors per cluster
+ *
+ * Define the minimum cluster size in sectors.
+ */
+
+#define MIN_CLUSTER_SIZE   4
+
+
+/*
+ *
+ *		Section 3: Socket Hardware Customization
+ *		----------------------------------------
+ */
+
+/* ISSUE #3.1: Vpp voltage
+ *
+ * If your socket does not supply 12 volts, comment the following line. In
+ * this case, you will be able to work only with Flash cards that do not
+ * require external 12 Volt Vpp.
+ *
+ */
+
+#define SOCKET_12_VOLTS
+
+
+/* ISSUE #3.2: Fixed or removable media
+ *
+ * If your Flash media is fixed, uncomment the following line, and ignore
+ * issue #3.3.
+ */
+
+/* #define FIXED_MEDIA */
+
+
+/* ISSUE #3.3: Hardware card change detection
+ *
+ * This issue is now obsolete
+ *
+ */
+
+
+/* ISSUE #3.4: Interval timer
+ *
+ * The following defines a timer polling interval in milliseconds. If the
+ * value is 0, an interval timer is not installed.
+ *
+ * If you select an interval timer, you should provide an implementation
+ * for 'installTimer' defined in timer.h.
+ *
+ * An interval timer is not a must, but it is recommended. The following
+ * will occur if an interval timer is absent:
+ *
+ * - Card changes can be recognized only if socket hardware detects them
+ *   (see issue #3.2).
+ * - The Vpp delayed turn-off procedure is not applied. This may downgrade
+ *   write performance significantly if the Vpp switching time is slow.
+ * - The watchdog timer that guards against certain operations being stuck
+ *   indefinitely will not be active.
+ */
+
+#define	POLLING_INTERVAL 100		/* Polling interval in millisec.
+					   if 0, no polling is done */
+
+
+/*
+ *
+ *		       Section 4: MTD Customization
+ *		       ----------------------------
+ */
+
+/* ISSUE #4.1: MTD Installation
+ *
+ * This issue is now obsolete
+ *
+ */
+
+
+/* ISSUE #4.2: Background erasing
+ *
+ * If you include support for Flash technology that has suspend-for-write
+ * capability, you can gain considerable write performance and improve
+ * real-time response for your write operations by including background erase
+ * capability. In some cases, you can gain performance by including this
+ * feature even if no suspend-for-write capability is supported. See the
+ * FLite manual for complete details.
+ *
+ * On the other hand, this feature adds to required code & RAM, makes
+ * necessary some additional customization on your part, and depends on
+ * compiler features that, while defined as ANSI-C standard, may have
+ * a problematic implementation in your particular environment. See the
+ * FLite manual for complete details.
+ *
+ * Uncomment the following line to support background erasing.
+ */
+
+/* #define	BACKGROUND */
+
+
+/* ISSUE #4.3: Maximum MTD's and Translation Layers
+ *
+ * Define here the maximum number of Memory Technology Drivers and
+ * Translation Layers that may be installed. Note that the actual
+ * number installed is determined by which components are installed in
+ * 'registerComponents' (custom.c)
+ */
+
+#define MTDS	10	/* Up to 5 MTD's */
+
+#define	TLS	5	/* Up to 3 Translation Layers */
+
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/flflash.h apps_1.2/art_1.2/art/modules/include/flflash.h
--- apps/art_1.2/art/modules/include/flflash.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/flflash.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,230 @@
+
+/*
+ * $Log:   P:/user/amir/lite/vcs/flflash.h_v  $
+   
+      Rev 1.10   03 Nov 1997 16:12:52   danig
+   amdCmdRoutine receives FlashPTR
+   
+      Rev 1.9   28 Jul 1997 14:46:20   danig
+   setPowerOnCallback
+   
+      Rev 1.8   24 Jul 1997 17:55:08   amirban
+   FAR to FAR0
+   
+      Rev 1.7   21 Jul 1997 14:45:26   danig
+   No parallelLimit
+   
+      Rev 1.6   07 Jul 1997 15:23:44   amirban
+   Ver 2.0
+   
+      Rev 1.5   08 Jun 1997 19:19:10   danig
+   BIG_PAGE & FULL_PAGE
+   
+      Rev 1.4   18 May 1997 17:34:14   amirban
+   Defined write mode flags
+   
+      Rev 1.3   18 Aug 1996 13:47:46   amirban
+   Comments
+   
+      Rev 1.2   31 Jul 1996 14:29:34   amirban
+   New flash.erase definition
+   
+      Rev 1.1   04 Jul 1996 18:19:52   amirban
+   New flag field
+   
+      Rev 1.0   20 Mar 1996 13:33:20   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+
+#ifndef FLFLASH_H
+#define FLFLASH_H
+
+#include "flsocket.h"
+
+/* Some useful types for mapped Flash locations */
+
+typedef volatile unsigned char FAR0 * FlashPTR;
+typedef volatile unsigned short int FAR0 * FlashWPTR;
+typedef volatile unsigned long FAR0 * FlashDPTR;
+
+typedef unsigned short FlashType;	/* JEDEC id */
+
+#define	NOT_FLASH	0
+
+/* page characteristics flags */
+#define  BIG_PAGE    0x0100             /* page size > 100H*/
+#define  FULL_PAGE  0x0200          	/* no partial page programming*/
+
+/* MTD write routine mode flags */
+#define OVERWRITE	1	/* Overwriting non-erased area  */
+#define EDC		2	/* Activate ECC/EDC		*/
+#define EXTRA		4	/* Read/write spare area	*/
+
+
+/*----------------------------------------------------------------------*/
+/*	         Flash array identification structure			*/
+/*									*/
+/* This structure contains a description of the Flash array and		*/
+/* routine pointers for the map, read, write & erase functions.		*/
+/* 									*/
+/* The structure is initialized by the MTD that identifies the Flash	*/
+/* array.                                                               */
+/* On entry to an MTD, the Flash structure contains default routines	*/
+/* for all operations. This routines are sufficient forread-only access	*/
+/* to NOR Flash on a memory-mapped socket. The MTD should override the	*/
+/* default routines with MTD specific ones when appropriate.		*/
+/*----------------------------------------------------------------------*/
+
+/* Flash array identification structure */
+
+typedef struct tFlash FLFlash;		/* Forward definition */
+
+struct tFlash {
+  FlashType	type;			/* Flash device type (JEDEC id) */
+  long int	erasableBlockSize;	/* Smallest physically erasable size
+					   (with interleaving taken in account) */
+  long int	chipSize;		/* chip size */
+  int		noOfChips;		/* no of chips in array */
+  int		interleaving;		/* chip interleaving
+					   (The interleaving is defined as
+					   the address difference between
+					   two consecutive bytes on a chip) */
+  unsigned	flags;			/* Special capabilities & options
+					   Bits 0-7 may be used by FLite.
+					   Bits 8-15 are not used bt FLite
+					   and may be used by MTD's for MTD-
+					   specific purposes. */
+  void *	mtdVars;		/* Points to MTD private area for
+					   this socket.
+					   This field, if used by the MTD, is
+					   initialized by the MTD identification
+					   routine */
+  FLSocket *	socket;			/* Socket of this drive */
+
+
+/* Flag bit values */
+
+#define SUSPEND_FOR_WRITE	1	/* MTD provides suspend for write */
+#define	NFTL_ENABLED		2	/* Flash can run NFTL */
+
+
+/*----------------------------------------------------------------------*/
+/*      	          f l a s h . m a p				*/
+/*									*/
+/* MTD specific map routine						*/
+/*                                                                      */
+/* The default routine maps by socket mapping, and is suitable for all  */
+/* NOR Flash.                                                           */
+/* NAND or other type Flash should use map-through-copy emulation: Read */
+/* a block of Flash to an internal buffer and return a pointer to that	*/
+/* buffer.								*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*      address		: Card address to map				*/
+/*	length		: Length to map					*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	Pointer to required card address				*/
+/*----------------------------------------------------------------------*/
+  void FAR0 *	(*map)(FLFlash *, CardAddress, int);
+
+/*----------------------------------------------------------------------*/
+/*      	          f l a s h . r e a d				*/
+/*									*/
+/* MTD specific Flash read routine					*/
+/*									*/
+/* The default routine reads by copying from a mapped window, and is	*/
+/* suitable for all NOR Flash.						*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*      address		: Card address to read				*/
+/*	buffer		: Area to read into				*/
+/*	length		: Length to read				*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  FLStatus	(*read)(FLFlash *, CardAddress, void FAR1 *, int, int);
+
+/*----------------------------------------------------------------------*/
+/*                       f l a s h . w r i t e				*/
+/*									*/
+/* MTD specific Flash write routine					*/
+/*									*/
+/* The default routine returns a write-protect error.			*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*      address		: Card address to write to			*/
+/*      buffer		: Address of data to write			*/
+/*	length		: Number of bytes to write			*/
+/*	modes		: See write mode flags definition above		*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	FLStatus	: 0 on success, failed otherwise		*/
+/*----------------------------------------------------------------------*/
+  FLStatus 	(*write)(FLFlash *, CardAddress, const void FAR1 *, int, int);
+
+/*----------------------------------------------------------------------*/
+/*                       f l a s h . e r a s e				*/
+/*									*/
+/* Erase one or more contiguous Flash erasable blocks			*/
+/*									*/
+/* The default routine returns a write-protect error.			*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*      firstErasableBlock : Number of first block to erase		*/
+/*	numOfErasableBlocks: Number of blocks to erase			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	FLStatus	: 0 on success, failed otherwise		*/
+/*----------------------------------------------------------------------*/
+  FLStatus 	(*erase)(FLFlash *, int, int);
+
+/*----------------------------------------------------------------------*/
+/*      	 f l a s h . s e t P o w e r O n C a l l b a c k	*/
+/*									*/
+/* Register power on callback routine. Default: no routine is 		*/
+/* registered.								*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void 	(*setPowerOnCallback)(FLFlash *);
+};
+
+
+
+/* MTD registration information */
+
+extern int noOfMTDs;	/* No. of MTDs actually registered */
+
+typedef FLStatus (*MTDidentifyRoutine) (FLFlash vol);
+
+extern MTDidentifyRoutine mtdTable[];
+
+
+/* See interface documentation of functions in flash.c	*/
+
+extern void flIntelIdentify(FLFlash *, 
+                            void (*)(FLFlash *, CardAddress, unsigned char, FlashPTR), 
+                            CardAddress);
+
+extern FLStatus	flIntelSize(FLFlash *, 
+                            void (*)(FLFlash *, CardAddress, unsigned char, FlashPTR), 
+                            CardAddress);
+
+extern FLStatus	flIdentifyFlash(FLSocket *socket, FLFlash *flash);
+
+#endif
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/flsocket.h apps_1.2/art_1.2/art/modules/include/flsocket.h
--- apps/art_1.2/art/modules/include/flsocket.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/flsocket.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,296 @@
+
+/*
+ * $Log:   P:/user/amir/lite/vcs/flsocket.h_v  $
+   
+      Rev 1.11   28 Sep 1997 18:23:28   danig
+   flExitSocket 
+   
+      Rev 1.10   10 Sep 1997 16:16:20   danig
+   Got rid of generic names
+   
+      Rev 1.9   28 Aug 1997 17:48:04   danig
+   Buffer & remapped per socket
+   
+      Rev 1.8   24 Jul 1997 18:05:24   amirban
+   FAR to FAR0
+   
+      Rev 1.7   20 Jul 1997 17:16:28   amirban
+   No watchDogTimer
+   
+      Rev 1.6   07 Jul 1997 15:23:46   amirban
+   Ver 2.0
+   
+      Rev 1.5   08 Jun 1997 17:03:16   amirban
+   power on callback
+   
+      Rev 1.4   08 Oct 1996 12:17:34   amirban
+   Defined remapped
+   
+      Rev 1.3   18 Aug 1996 13:47:44   amirban
+   Comments
+   
+      Rev 1.2   12 Aug 1996 15:47:42   amirban
+   Changed value of UNDEF_MAPPING
+   
+      Rev 1.1   31 Jul 1996 14:29:08   amirban
+   Defined set/getMappingContext
+
+      Rev 1.0   20 Mar 1996 13:33:20   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+
+#ifndef FLSOCKET_H
+#define FLSOCKET_H
+
+#include "flbase.h"
+#include "flbuffer.h"
+
+#define ATTRIBUTE_SPACE_MAPPED	0x8000
+
+typedef enum {PowerOff, PowerGoingOff, PowerOn} PowerState;
+
+
+/* Socket state variables */
+typedef struct tSocket FLSocket;	/* Forward definition */
+
+struct tSocket {
+  unsigned	volNo;		/* Volume no. of socket */
+  unsigned 	serialNo; 	/* Serial no. of socket on controller */
+
+  FLBoolean	cardChanged;	/* need media change notification */
+
+  int 		VccUsers;	/* No. of current VCC users */
+  int 		VppUsers;	/* No. of current VPP users */
+
+  PowerState	VccState;	/* Actual VCC state */
+  PowerState	VppState;	/* Actual VPP state */
+
+  FLBoolean	remapped;       /* set to TRUE whenever the socket window is moved */
+
+  void		(*powerOnCallback)(void *flash); /* Notification routine for Vcc on */
+  void *	flash;		/* Flash object for callback */
+
+  struct {                      /* Window state */
+    unsigned int baseAddress;	/* Physical base as a 4K page */
+    unsigned int currentPage;	/* Our current window page mapping */
+    void FAR0 *	base;		/* Pointer to window base */
+    long int	size;           /* Window size (must by power of 2) */
+    unsigned	speed;		/* in nsec. */
+    unsigned 	busWidth;	/* 8 or 16 bits */
+  } window;
+
+/*----------------------------------------------------------------------*/
+/*      	          c a r d D e t e c t e d			*/
+/*									*/
+/* Detect if a card is present (inserted)				*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	0 = card not present, other = card present			*/
+/*----------------------------------------------------------------------*/
+  FLBoolean (*cardDetected)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	               V c c O n				*/
+/*									*/
+/* Turns on Vcc (3.3/5 Volts). Vcc must be known to be good on exit.	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*VccOn)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	             V c c O f f				*/
+/*									*/
+/* Turns off Vcc.							*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*VccOff)(FLSocket vol);
+
+#ifdef SOCKET_12_VOLTS
+
+/*----------------------------------------------------------------------*/
+/*      	               V p p O n				*/
+/*									*/
+/* Turns on Vpp (12 Volts. Vpp must be known to be good on exit.	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	FLStatus	: 0 on success, failed otherwise		*/
+/*----------------------------------------------------------------------*/
+  FLStatus (*VppOn)(FLSocket vol);
+
+
+/*----------------------------------------------------------------------*/
+/*      	             V p p O f f				*/
+/*									*/
+/* Turns off Vpp.							*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*VppOff)(FLSocket vol);
+
+#endif	/* SOCKET_12_VOLTS */
+
+/*----------------------------------------------------------------------*/
+/*      	          i n i t S o c k e t			        */
+/*									*/
+/* Perform all necessary initializations of the socket or controller	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	FLStatus	: 0 on success, failed otherwise		*/
+/*----------------------------------------------------------------------*/
+  FLStatus (*initSocket)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	            s e t W i n d o w				*/
+/*									*/
+/* Sets in hardware all current window parameters: Base address, size,  */
+/* speed and bus width.							*/
+/* The requested settings are given in the 'vol.window' structure.	*/
+/*									*/
+/* If it is not possible to set the window size requested in		*/
+/* 'vol.window.size', the window size should be set to a larger value,	*/
+/* if possible. In any case, 'vol.window.size' should contain the	*/
+/* actual window size (in 4 KB units) on exit.				*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*setWindow)(FLSocket vol);
+
+
+/*----------------------------------------------------------------------*/
+/*      	   s e t M a p p i n g C o n t e x t			*/
+/*									*/
+/* Sets the window mapping register to a card address.			*/
+/*									*/
+/* The window should be set to the value of 'vol.window.currentPage',	*/
+/* which is the card address divided by 4 KB. An address over 128KB,	*/
+/* (page over 32K) specifies an attribute-space address.		*/
+/*									*/
+/* The page to map is guaranteed to be on a full window-size boundary.	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+  void (*setMappingContext)(FLSocket vol, unsigned page);
+
+/*----------------------------------------------------------------------*/
+/*     	 g e t A n d C l e a r C a r d C h a n g e I n d i c a t o r    */
+/*									*/
+/* Returns the hardware card-change indicator and clears it if set.	*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	0 = Card not changed, other = card changed			*/
+/*----------------------------------------------------------------------*/
+  FLBoolean (*getAndClearCardChangeIndicator)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	          w r i t e P r o t e c t e d			*/
+/*									*/
+/* Returns the write-protect state of the media				*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/* Returns:                                                             */
+/*	0 = not write-protected, other = write-protected		*/
+/*----------------------------------------------------------------------*/
+  FLBoolean (*writeProtected)(FLSocket vol);
+
+/*----------------------------------------------------------------------*/
+/*      	          f r e e S o c k e t				*/
+/*									*/
+/* Free resources that were allocated for this socket.			*/
+/* This function is called when FLite exits.				*/
+/*									*/
+/* Parameters:                                                          */
+/*	vol		: Pointer identifying drive			*/
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+#ifdef EXIT
+  void (*freeSocket)(FLSocket vol);
+#endif
+};
+
+
+#define	UNDEFINED_MAPPING	0x7fff
+
+typedef unsigned long CardAddress;	/* Physical offset on card */
+
+/* See interface documentation of functions in socket.c */
+
+extern FLStatus	flInitSockets(void);
+
+#ifdef EXIT
+extern void	flExitSocket(FLSocket *);
+#endif
+
+extern unsigned	flSocketNoOf(const FLSocket *);
+extern FLSocket * flSocketOf(unsigned volNo);
+extern FLBuffer *flBufferOf(unsigned volNo);
+
+extern void	flNeedVcc(FLSocket *);
+extern void	flDontNeedVcc(FLSocket *);
+#ifdef SOCKET_12_VOLTS
+extern FLStatus	flNeedVpp(FLSocket *);
+extern void	flDontNeedVpp(FLSocket *);
+#endif
+extern void	flSocketSetBusy(FLSocket *, FLBoolean);	/* entry/exit operations */
+extern FLBoolean  flWriteProtected(FLSocket *); /* write-protection status */
+#ifndef FIXED_MEDIA
+extern FLStatus	flMediaCheck(FLSocket *);	/* check for media status change */
+extern void	flResetCardChanged(FLSocket *);
+#endif
+extern unsigned flGetMappingContext(FLSocket *);  /* Currently mapped 4KB page */
+extern void FAR0 *flMap(FLSocket *, CardAddress);	/* map and point at card address */
+extern void	flSetWindowBusWidth(FLSocket *, unsigned); /* set window data-path */
+extern void	flSetWindowSpeed(FLSocket *, unsigned);	/* set window speed (nsec.) */
+extern void	flSetWindowSize(FLSocket *, unsigned);	/* in 4KB units */
+
+extern void	flSetPowerOnCallback(FLSocket *, void (*)(void *), void *);
+			/* Set MTD notification for socket power on */
+extern	void 	flIntervalRoutine(FLSocket *);	/* socket interval routine */
+
+
+extern unsigned	noOfDrives;	/* No. of drives actually registered */
+
+/* The milliseconds counter is active when socket polling is enabled. When
+   the socket interval routine is called, the counter is incremented by
+   the interval in milliseconds.
+   The counter can be used to avoid getting in a loop that is not guaranteed
+   to terminate (such as waiting for a flash status register). Save the counter
+   at entry to the loop, and check in the loop the amount of time that
+   was spent in the loop. */
+
+extern unsigned long 	flMsecCounter;
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/include/flsystem.h apps_1.2/art_1.2/art/modules/include/flsystem.h
--- apps/art_1.2/art/modules/include/flsystem.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/include/flsystem.h	2014-05-30 03:41:19.055257650 -0700
@@ -0,0 +1,284 @@
+/*
+ * $Log:   V:/flsystem.h_v  $
+
+      Rev 1.0   13 Jan 1999 22:18:07   Yogu
+   added vxLib.h and macro for fault safe write in isRAM.
+
+      Rev 1.0   08 Jan 1998 17:20:00   Hdei
+   changed MALLOC FREE to MALLOC_TFFS FREE_TFFS.
+
+      Rev 1.0   24 Jul 1997 18:13:06   amirban
+   Initial revision.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*		FAT-FTL Lite Software Development Kit			*/
+/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
+/*									*/
+/************************************************************************/
+
+
+#ifndef FLSYSTEM_H
+#define FLSYSTEM_H
+
+#include <vxWorks.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <ctype.h>
+#include <tickLib.h>
+#include <wdLib.h>
+#include <sysLib.h>
+#include <excLib.h>
+#include <semLib.h>
+#include <ioLib.h>
+#include <iosLib.h>
+#include <memLib.h>
+#include <errnoLib.h>
+#include <vxLib.h>
+
+
+/*
+ * 			signed/unsigned char
+ *
+ * It is assumed that 'char' is signed. If this is not your compiler
+ * default, use compiler switches, or insert a #pragma here to define this.
+ *
+ */
+
+/* char is signed by default in GNU C */
+
+
+/* 			CPU target
+ *
+ * Use compiler switches or insert a #pragma here to select the CPU type
+ * you are targeting.
+ *
+ * If the target is an Intel 80386 or above, also uncomment the CPU_i386
+ * definition.
+ */
+
+/* defined in VxWorks makefile */
+
+/* 			NULL constant
+ *
+ * Some compilers require a different definition for the NULL pointer
+ */
+
+/* #include <_null.h> */
+
+
+/* 			Little-endian/big-endian
+ *
+ * FAT and FTL structures use the little-endian (Intel) format for integers.
+ * If your machine uses the big-endian (Motorola) format, uncomment the
+ * following line.
+ * This option needs a C++ compiler.
+ * Note that even on big-endian machines you may omit the BIG_ENDIAN
+ * definition for smaller code size and better performance, but your media
+ * will not be compatible with standard FAT and FTL.
+ */
+
+/* we are using VxWorks #define _BYTE_ORDER here */
+#ifndef _BYTE_ORDER
+#error "byte order is not defined"
+#else  /* _BYTE_ORDER */
+#if (_BYTE_ORDER == _BIG_ENDIAN)
+#define BIG_ENDIAN
+#else  /* (_BYTE_ORDER == _BIG_ENDIAN) */
+#undef BIG_ENDIAN
+#endif /* (_BYTE_ORDER == _BIG_ENDIAN) */
+#endif /* _BYTE_ORDER */
+
+
+/* 			Far pointers
+ *
+ * Specify here which pointers may be far, if any.
+ * Far pointers are usually relevant only to 80x86 architectures.
+ *
+ * Specify FAR_LEVEL:
+ *   0 -	if using a flat memory model or having no far pointers.
+ *   1 -        if only the socket window may be far
+ *   2 -	if only the socket window and caller's read/write buffers
+ *		may be far.
+ *   3 -	if socket window, caller's read/write buffers and the
+ *		caller's I/O request packet may be far
+ */
+
+#define FAR_LEVEL       0
+
+
+/* 			Memory routines
+ *
+ * You need to supply library routines to copy, set and compare blocks of
+ * memory, internally and to/from callers. The code uses the names 'tffscpy',
+ * 'tffsset' and 'tffscmp' with parameters as in the standard 'memcpy',
+ * 'memset' and 'memcmp' C library routines.
+ */
+
+#if FAR_LEVEL > 0
+#define tffscpy _fmemcpy
+#define tffsset  _fmemset
+#define tffscmp  _fmemcmp
+#else
+/* XXX
+#define tffscpy  sysTffsCpy
+#define tffsset  sysTffsSet
+*/
+#define tffscpy  memcpy
+#define tffsset  memset
+#define tffscmp  memcmp
+#endif
+
+#define tffscpyWords(dest,src,nbytes)     bcopyWords((char *)(src), \
+                                                  (char *)(dest), (nbytes)/2)
+extern int tffscmpWords(void *buf1, void *buf2, int nbytes);
+
+
+/* 			Pointer arithmetic
+ *
+ * The following macros define machine- and compiler-dependent macros for
+ * handling pointers to physical window addresses. The definitions below are
+ * for PC real-mode Borland-C.
+ *
+ * 'physicalToPointer' translates a physical flat address to a (far) pointer.
+ * Note that if when your processor uses virtual memory, the code should
+ * map the physical address to virtual memory, and return a pointer to that
+ * memory (the size parameter tells how much memory should be mapped).
+ *
+ * 'addToFarPointer' adds an increment to a pointer and returns a new
+ * pointer. The increment may be as large as your window size. The code
+ * below assumes that the increment may be larger than 64 KB and so performs
+ * huge pointer arithmetic.
+ */
+
+#if FAR_LEVEL > 0
+#include <dos.h>
+
+#define physicalToPointer(physical,size,drive)		\
+	MK_FP((int) ((physical) >> 4),(int) (physical) & 0xF)
+
+#define addToFarPointer(base,increment)		\
+	MK_FP(FP_SEG(base) +			\
+		((unsigned short) ((FP_OFF(base) + (increment)) >> 16) << 12), \
+	      FP_OFF(base) + (int) (increment))
+#else
+#define physicalToPointer(physical,size,drive)          \
+	((void *) (physical))
+
+#define addToFarPointer(base,increment)		\
+	((void *) ((unsigned char *) (base) + (increment)))
+#endif
+
+
+/* 			Default calling convention
+ *
+ * C compilers usually use the C calling convention to routines (cdecl), but
+ * often can also use the pascal calling convention, which is somewhat more
+ * economical in code size. Some compilers also have specialized calling
+ * conventions which may be suitable. Use compiler switches or insert a
+ * #pragma here to select your favorite calling convention.
+ */
+
+/* use GNU C default calling convention */
+
+
+
+/* 			Mutex type
+ *
+ * If you intend to access the FLite API in a multi-tasking environment,
+ * you may need to implement some resource management and mutual-exclusion
+ * of FLite with mutex & semaphore services that are available to you. In
+ * this case, define here the Mutex type you will use, and provide your own
+ * implementation of the Mutex functions incustom.c
+ *
+ * By default, a Mutex is defined as a simple counter, and the Mutex
+ * functions in custom.c implement locking and unlocking by incrementing
+ * and decrementing the counter. This will work well on all single-tasking
+ * environment, as well as on many multi-tasking environments.
+ */
+
+typedef SEM_ID FLMutex;
+
+#define flStartCriticalSection(mutexPtr)  flTakeMutex(mutexPtr,1)
+#define flEndCriticalSection(mutexPtr)    flFreeMutex(mutexPtr)
+
+
+
+/* 			Memory allocation
+ *
+ * The translation layers (e.g. FTL) need to allocate memory to handle
+ * Flash media. The size needed depends on the media being handled.
+ *
+ * You may choose to use the standard 'malloc' and 'free' to handle such
+ * memory allocations, provide your own equivalent routines, or you may
+ * choose not to define any memory allocation routine. In this case, the
+ * memory will be allocated statically at compile-time on the assumption of
+ * the largest media configuration you need to support. This is the simplest
+ * choice, but may cause your RAM requirements to be larger than you
+ * actually need.
+ *
+ * If you define routines other than malloc & free, they should have the
+ * same parameters and return types as malloc & free. You should either code
+ * these routines in custom.c or include them when you link your application.
+ */
+
+#define MALLOC_TFFS malloc
+#define FREE_TFFS free
+
+/*			isRAM fault safe write
+ * The function isRAM() does a direct write to verify if the location 
+ * specified is RAM. It is possible that hardware is tailered to fault 
+ * in such situations. 
+ */
+
+#ifdef ORIG
+#define ISRAM_WRITE(src,dst) dst = src
+#else /* !ORG */
+#define ISRAM_WRITE(src,dst) \
+	vxMemProbe ((char *)dst, VX_WRITE, 4, (char *)&src)
+#endif /* ORIG */
+
+/*                      Pointer arithmetic
+ *
+ * The following macros define machine- and compiler-dependent macros for
+ * handling pointers to physical window addresses. The definitions below are
+ * for PC real-mode Borland-C.
+ *
+ * 'physicalToPointer' translates a physical flat address to a (far) pointer.
+ * Note that if when your processor uses virtual memory, the code should
+ * map the physical address to virtual memory, and return a pointer to that
+ * memory (the size parameter tells how much memory should be mapped).
+ *
+ * 'addToFarPointer' adds an increment to a pointer and returns a new
+ * pointer. The increment may be as large as your window size. The code
+ * below assumes that the increment may be larger than 64 KB and so performs
+ * huge pointer arithmetic.
+ */
+
+#if FAR_LEVEL > 0
+#include <dos.h>
+
+#define physicalToPointer(physical,size,drive)          \
+        MK_FP((int) ((physical) >> 4),(int) (physical) & 0xF)
+
+/*NEW*/ #define pointerToPhysical(ptr)                  \
+        (((unsigned long) FP_SEG(ptr) << 4) + FP_OFF(ptr))
+
+#define addToFarPointer(base,increment)         \
+        MK_FP(FP_SEG(base) +                    \
+                ((unsigned short) ((FP_OFF(base) + (increment)) >> 16) << 12), \
+        FP_OFF(base) + (int) (increment))
+#else
+#define physicalToPointer(physical,size,drive)          \
+        ((void *) (physical))
+
+/*NEW*/ #define pointerToPhysical(ptr)  ((unsigned long)(ptr))
+
+#define addToFarPointer(base,increment)         \
+        ((void *) ((unsigned char *) (base) + (increment)))
+#endif
+
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/main.c apps_1.2/art_1.2/art/modules/main.c
--- apps/art_1.2/art/modules/main.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/main.c	2014-05-30 03:43:07.296515324 -0700
@@ -0,0 +1,278 @@
+/* main.c main 'C' file for the linux dk driver */
+/*
+                Copyright (c) 2014 Qualcomm Atheros, Inc. All rights reserved.
+                Qualcomm is a trademark of Qualcomm Technologies Incorporated, registered in the United States and other countries.
+                All Qualcomm Technologies Incorporated trademarks are used with permission.
+                Atheros is a trademark of Qualcomm Atheros, Inc., registered in the United States and other countries.
+                Other products and brand names may be trademarks or registered trademarks of their respective owners.
+*/
+
+/* Copyright (c) 2001 Atheros Communications, Inc., All Rights Reserved */
+/*
+                Copyright (c) 2014 Qualcomm Atheros, Inc. All rights reserved.
+                Qualcomm is a trademark of Qualcomm Technologies Incorporated, registered in the United States and other countries.
+                All Qualcomm Technologies Incorporated trademarks are used with permission.
+                Atheros is a trademark of Qualcomm Atheros, Inc., registered in the United States and other countries.
+                Other products and brand names may be trademarks or registered trademarks of their respective owners.
+*/
+
+// Include files
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#include <linux/pci.h>
+#endif
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/page-flags.h>
+#include <asm/io.h>
+#include "dk.h"
+#include "client.h"
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+//#ifdef PCI_BUS
+#include "dk_pci_bus.h"
+//#endif
+#endif
+#define CHIP_ID_LOCATION 0xb8060090
+#define HOWL_WMAC_BASE_PHY_ADDRESS 0x180c0000
+#define MERLIN_PCI_COMMAND_REG_ADDRESS 0xb4000004
+#define SCORPION_PCI_COMMAND_REG_ADDRESS 0xb6000004
+#define VIRIAN_BASE_ADDRESS 0xb80f0000
+#define SCORPION_BASE_ADDRESS 0xb8280000
+#define WASP_WMAC_BASE_PHY_ADDRESS 0x18100000
+#define HORNET_WMAC_BASE_PHY_ADDRESS 0x18100000
+#define PCIE_1_LINK_ADDRESS 0xb80f0018
+#define PCIE_2_LINK_ADDRESS 0xb8280018
+#define CHIP_REV_ID_SCORPION_A 0x013 // last nibble is for Chip revision which is ignored
+#define CHIP_REV_ID_SCORPION_B 0x113 // last nibble is for Chip revision which is ignored
+#define CHIP_REV_ID_DRANGONFLY 0x15  
+extern INT32  dk_dev_init(void);
+#if  defined(P1020)
+extern A_UINT_PTR get_pci_reg_addr();
+#endif
+extern void dk_dev_exit(void);
+extern INT32 get_chip_id(INT32 cli_id,INT32 offset,INT32 size,INT32 *ret_val);
+int init_wmac_device(void);
+static INT32 __init dk_module_init(void)
+{
+		INT32 error;
+#if  defined(P1020)
+
+	A_UINT_PTR baseaddr[1];
+
+	UINT32 len[1];
+	UINT32 irq;
+#ifndef PYTHON_EMU
+	UINT8  csz;
+	UINT32 val;
+#endif
+	UINT32 iIndex, numBars;
+#ifdef DK_DEBUG
+    UINT32 device_id, vendor_id;
+#endif
+	INT8 ret_val;
+	UINT32 sIndex = WMAC_FN_DEV_START_NUM;
+ 	VOID *dev;
+#endif
+#if  !defined(P1020)
+#if  defined(PYTHON_EMU)
+        	UINT32 *addr;
+		INT32 ret_val;
+#endif
+#ifndef OCTEON
+        INT32 chip_rev_id=0;
+#endif
+#ifdef DK_DEBUG
+		printk("DK::Module init \n");
+#endif // DK_DEBUG
+#ifndef OWL_PB42
+        get_chip_id(0,CHIP_ID_LOCATION,4,&chip_rev_id); // for getting the chip rev_id; to differentiate between PB and AP
+        printk("CHIP REV ID: %x\n",chip_rev_id);
+#endif
+#if  defined(PYTHON_EMU)
+	// Scorpion packages A and B (PCIE_2_LINK_ADDRESS is only valid for Scorpion)
+    // Dragonfly has one pcie at PCIE_2_LINK_ADDRESS.
+	if ((((chip_rev_id& 0xfff0)>>4) == CHIP_REV_ID_SCORPION_A)||
+		(((chip_rev_id& 0xfff0)>>4) == CHIP_REV_ID_SCORPION_B)||
+		(((chip_rev_id& 0x0ff0)>>4) == CHIP_REV_ID_DRANGONFLY)){ 
+	          addr = (UINT32 *)(PCIE_2_LINK_ADDRESS);
+	          ret_val = readl(addr);
+		if(ret_val==7){
+	         	printk("Writing value 0x6 to  PCI_2 command register\n");
+	         	addr = (UINT32 *)(SCORPION_PCI_COMMAND_REG_ADDRESS);
+	        	writel(0x6,addr); // enabling ddr and dma of Merlin
+		}else{
+	         	printk("No link on PCIe_2\n");
+		}
+	}
+	if (((chip_rev_id& 0x0ff0)>>4) != CHIP_REV_ID_DRANGONFLY) {
+		addr = (UINT32 *)(PCIE_1_LINK_ADDRESS);
+		ret_val = readl(addr);
+		if(ret_val==7){
+			printk("Writing value 0x6 to PCI_1 command register\n");
+			addr = (UINT32 *)(MERLIN_PCI_COMMAND_REG_ADDRESS);
+			writel(0x6,addr); // enabling ddr and dma of Merlin
+		}else{
+			printk("No link on PCIe_1\n");
+		}
+	}
+	if((chip_rev_id==0x100)||(chip_rev_id==0x1100)||(chip_rev_id==0x101)||(chip_rev_id==0x1101)
+	||(chip_rev_id==0x2120)||(chip_rev_id==0x1120)||(chip_rev_id==0x0120) // Wasp 1.0 package C, B and A
+	||(chip_rev_id==0x2121)||(chip_rev_id==0x1121)||(chip_rev_id==0x0121) // Wasp 1.1 package C, B and A
+	||(chip_rev_id==0x2122)||(chip_rev_id==0x1122)||(chip_rev_id==0x0122) // Wasp 1.2 package C, B and A
+	||(chip_rev_id==0x2123)||(chip_rev_id==0x1123)||(chip_rev_id==0x0123) // Wasp 1.3 package C, B and A
+	||(chip_rev_id==0x12123)||(chip_rev_id==0x11123)||(chip_rev_id==0x10123)) {// Wasp 1.3.0.1 package C, B and A
+	        addr = (UINT32 *)(VIRIAN_BASE_ADDRESS);
+        	writel(readl(addr)& 0xfffeffff,addr);
+	        printk("Resetting bit 16 of VIRIAN register 0xb80f0000\n");
+	} else if (((chip_rev_id& 0xfff0)>>4 == CHIP_REV_ID_SCORPION_A)||((chip_rev_id& 0xfff0)>>4 == CHIP_REV_ID_SCORPION_B)){ // Scorpion packages A and B
+          	addr = (UINT32 *)(PCIE_2_LINK_ADDRESS);
+          	ret_val = readl(addr);
+		if(ret_val==7){
+	        	printk("Bit 16 of 0xb8280000 need not be reset\n");
+		}
+          	addr = (UINT32 *)(PCIE_1_LINK_ADDRESS);
+          	ret_val = readl(addr);
+		if(ret_val==7){
+	        	printk("Resetting bit 16 of VIRIAN register 0xb80f0000\n");
+	        	addr = (UINT32 *)(VIRIAN_BASE_ADDRESS);
+        		writel(readl(addr)& 0xfffeffff,addr);
+		}
+	} else if (((chip_rev_id& 0x0ff0)>>4) == CHIP_REV_ID_DRANGONFLY) {
+			addr = (UINT32 *)(PCIE_2_LINK_ADDRESS);
+			ret_val = readl(addr);
+			if(ret_val==7){
+				printk("Bit 16 of 0xb8280000 need not be reset\n");
+			}
+   	} else {
+                addr = (UINT32 *)(0xb80f001c );
+                writel(readl(addr)& 0xfffeffff,addr);
+                printk("Resetting bit 16 of Python  register 0xb80f001c \n");
+	}
+#endif
+#endif // #if  !defined(P1020)
+
+		error = dk_dev_init();
+		if (error < 0) {
+			printk("DK::Cannot register device \n");
+			return error;
+		}
+		init_client();
+#if  !defined(P1020)
+#ifdef AP83
+                if (init_wmac_device()){ // enabling the wmac ; setting the handle for applications
+                         printk("Error in initializing wmac \n");
+                         return error;
+                }
+#ifndef WASP_OSPREY
+		return 0;
+#endif
+#endif
+#endif
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+#if  !defined(P1020)
+		     error = bus_module_init();
+#endif
+#if  defined(P1020)
+	iIndex=0;
+
+	baseaddr[iIndex] = (A_UINT_PTR)get_pci_reg_addr();
+	printk(KERN_ERR" Base Phsycal address :0x%08lx\n", baseaddr[iIndex]);
+
+	len[iIndex] = 0x20000;
+    numBars = 1;
+	irq = 17;
+	sIndex = 0;
+	if (add_client(dev,baseaddr,len,irq, numBars, sIndex,0) < 0) {
+		printk(KERN_ERR "DK:: unable to add client \n");
+#if LINUX_VERSION_CODE > 132098
+//		pci_disable_device(dev);
+#endif
+		return -ENODEV;
+	}
+#endif
+#endif
+#if !defined(OWL_PB42) && !defined(PYTHON_EMU)
+		if (error < 0) {
+			cleanup_client();
+			dk_dev_exit();
+			printk("DK::Cannot locate device. Reset the machine \n");
+			return error;
+		}
+#endif
+		return 0;
+}
+#ifdef AP83
+int init_wmac_device()
+{
+        VOID *dev;
+	UINT32 baseaddr[MAX_BARS];
+	UINT32 len[MAX_BARS];
+	UINT32 irq;
+	UINT32 iIndex, numBars;
+#ifdef DK_DEBUG
+    UINT16 device_id, vendor_id;
+#endif
+	UINT32 sIndex = WMAC_FN_DEV_START_NUM;
+	dev=0;
+for (iIndex=0; iIndex<1; iIndex++) { // assume that only one wmac
+#ifdef WASP
+	  baseaddr[iIndex] =WASP_WMAC_BASE_PHY_ADDRESS;
+#elif HORNET
+	  baseaddr[iIndex] =HORNET_WMAC_BASE_PHY_ADDRESS;
+#else
+	  baseaddr[iIndex] =HOWL_WMAC_BASE_PHY_ADDRESS;
+#endif
+	printk(KERN_ERR" Base Phsycal address :0x%x\n", baseaddr[iIndex]);
+	  len[iIndex] = 0x00ffffff;
+      if (len[iIndex] == 0) break;
+    }
+    numBars = iIndex;
+    irq=2;
+
+if (add_client(dev,(A_UINT_PTR *)baseaddr,len,irq, numBars, sIndex,0) < 0) {
+
+		printk(KERN_ERR "DK:: unable to add client \n");
+#if LINUX_VERSION_CODE > 132098
+		//pci_disable_device(dev);
+                //MKDEV
+                //processEepromWriteByteBasedBlockCmd
+                //pci_enable_device
+#endif
+		return -1;
+	}
+	return 0;
+
+}
+#endif
+
+static void __exit  dk_module_exit(void)
+{
+#ifdef DK_DEBUG
+		printk("DK::Module exit \n");
+#endif // DK_DEBUG
+#if defined(OWL_PB42) || defined(PYTHON_EMU)
+
+		bus_module_exit();
+
+#endif
+		cleanup_client();
+		dk_dev_exit();
+		return;
+}
+#ifdef MODULE
+#if LINUX_VERSION_CODE > 132098
+	MODULE_LICENSE(MOD_LICENCE);
+#endif
+MODULE_AUTHOR(MOD_AUTHOR);
+MODULE_DESCRIPTION(MOD_DESCRIPTION);
+module_init(dk_module_init);
+module_exit(dk_module_exit);
+#endif // MODULE
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/art_1.2/art/modules/Makefile apps_1.2/art_1.2/art/modules/Makefile
--- apps/art_1.2/art/modules/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/art_1.2/art/modules/Makefile	2014-05-30 03:41:19.051257603 -0700
@@ -0,0 +1,55 @@
+EXTRA_CFLAGS += -I$(PWD)/modules/include  -DPCI_BUS -D__KERNEL__ -DMODULE 
+IX_CFLAGS += -I$(ROOTDIR)
+
+ifeq ($(PB42),1)
+EXTRA_CFLAGS += -DOWL_PB42
+endif
+
+
+
+ifeq ($(PYTHON_EMU),1)
+EXTRA_CFLAGS += -DPYTHON_EMU
+endif
+
+ifeq ($(DEBUG),1)
+EXTRA_CFLAGS += -DDK_DEBUG
+endif
+
+ifeq ($(AP83),1)
+EXTRA_CFLAGS += -DAP83
+endif
+
+
+ifeq ($(P1020),1)
+EXTRA_CFLAGS += -DP1020
+endif
+
+ifeq ($(WASP),1)
+EXTRA_CFLAGS += -DAP83
+EXTRA_CFLAGS += -DWASP
+endif
+
+ifeq ($(WASP_OSPREY),1)
+EXTRA_CFLAGS += -DWASP_OSPREY
+endif
+
+ifeq ($(PCI_2),1)
+EXTRA_CFLAGS += -DPCI_2
+endif
+
+ifeq ($(HORNET),1)
+EXTRA_CFLAGS += -DAP83
+EXTRA_CFLAGS += -DHORNET
+endif
+
+ifeq ($(OCTEON),1)
+EXTRA_CFLAGS += -DOCTEON
+endif
+
+obj-m := art.o
+art-objs := dk_func.o client.o main.o dk_pci_bus.o dk_isr.o dk_event.o
+
+clean:
+	rm -rf *.o *.ko .*.cmd *mod.c .tmp_versions
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/defconfig-ap135 apps_1.2/busybox-1.01/defconfig-ap135
--- apps/busybox-1.01/defconfig-ap135	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/defconfig-ap135	2014-05-30 03:43:44.040943050 -0700
@@ -0,0 +1,475 @@
+#
+# Automatically generated make config: don't edit
+#
+HAVE_DOT_CONFIG=y
+
+#
+# General Configuration
+#
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_FEATURE_VERBOSE_USAGE=y
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_DEVFS is not set
+CONFIG_FEATURE_DEVPTS=y
+# CONFIG_FEATURE_CLEAN_UP is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+CONFIG_STATIC=y
+CONFIG_LFS=y
+USING_CROSS_COMPILER=y
+CROSS_COMPILER_PREFIX="mips-linux-uclibc-"
+EXTRA_CFLAGS_OPTIONS=""
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+PREFIX="./_install"
+
+#
+# Archival Utilities
+#
+# CONFIG_AR is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+CONFIG_FEATURE_TAR_CREATE=y
+CONFIG_FEATURE_TAR_BZIP2=y
+# CONFIG_FEATURE_TAR_FROM is not set
+CONFIG_FEATURE_TAR_GZIP=y
+# CONFIG_FEATURE_TAR_COMPRESS is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY is not set
+CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNZIP is not set
+
+#
+# Common options for cpio and tar
+#
+# CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+# CONFIG_CHOWN is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CMP is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+CONFIG_FEATURE_DATE_ISOFMT=y
+CONFIG_DD=y
+CONFIG_DF=y
+CONFIG_DIRNAME=y
+# CONFIG_DOS2UNIX is not set
+CONFIG_DU=y
+CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+CONFIG_EXPR=y
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+# CONFIG_HEAD is not set
+CONFIG_HEAD=y
+CONFIG_FEATURE_FANCY_HEAD=y
+# CONFIG_HOSTID is not set
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+CONFIG_FEATURE_LS_COLOR=y
+CONFIG_MD5SUM=y
+CONFIG_MKDIR=y
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_OD is not set
+# CONFIG_PRINTF is not set
+CONFIG_PWD=y
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+CONFIG_RMDIR=y
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_STTY is not set
+CONFIG_SYNC=y
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+# CONFIG_TEE is not set
+CONFIG_TEST=y
+
+#
+# test (forced enabled for use with shell)
+#
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+# CONFIG_TR is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WATCH is not set
+CONFIG_WC=y
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls and more
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum
+#
+CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+CONFIG_MKTEMP=y
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_READLINK is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_PATCH is not set
+CONFIG_SED=y
+CONFIG_VI=y
+CONFIG_FEATURE_VI_COLON=y
+CONFIG_FEATURE_VI_YANKMARK=y
+CONFIG_FEATURE_VI_SEARCH=y
+CONFIG_FEATURE_VI_USE_SIGNALS=y
+CONFIG_FEATURE_VI_DOT_CMD=y
+CONFIG_FEATURE_VI_READONLY=y
+CONFIG_FEATURE_VI_SETOPTS=y
+CONFIG_FEATURE_VI_SET=y
+CONFIG_FEATURE_VI_WIN_RESIZE=y
+CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+CONFIG_FIND=y
+CONFIG_FEATURE_FIND_MTIME=y
+CONFIG_FEATURE_FIND_PERM=y
+CONFIG_FEATURE_FIND_TYPE=y
+CONFIG_FEATURE_FIND_XDEV=y
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+CONFIG_XARGS=y
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_INITRD=y
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+CONFIG_FEATURE_INIT_SWAPON=y
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_HALT is not set
+# CONFIG_POWEROFF is not set
+CONFIG_REBOOT=y
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_DELUSER is not set
+CONFIG_GETTY=y
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+CONFIG_LOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_SU=y
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Common options for adduser, deluser, login, su
+#
+CONFIG_FEATURE_SHADOWPASSWDS=y
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_CROND is not set
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_LAST is not set
+# CONFIG_HDPARM is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_MT is not set
+# CONFIG_RX is not set
+CONFIG_STRINGS=y
+# CONFIG_TIME is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_FACTORYRESET=y
+CONFIG_ETHREG=y
+# CONFIG_ETHDEBUG is not set
+CONFIG_MDMM=y
+#
+# Linux Module Utilities
+#
+CONFIG_INSMOD=y
+# CONFIG_FEATURE_2_4_MODULES is not set
+CONFIG_FEATURE_2_6_MODULES=y
+CONFIG_LSMOD=y
+CONFIG_MODPROBE=y
+CONFIG_RMMOD=y
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+CONFIG_ARPING=y
+CONFIG_BRCTL=y
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_HOSTNAME is not set
+CONFIG_HTTPD=y
+# CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+CONFIG_FEATURE_HTTPD_CGI=y
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_S26QOS is not set
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# CONFIG_FEATURE_IFCONFIG_VLAN_IGMP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFUPDOWN is not set
+# CONFIG_INETD is not set
+# CONFIG_IP is not set
+# CONFIG_IPCALC is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+CONFIG_IPROUTE=y
+# CONFIG_IPTUNNEL is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_NC is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+CONFIG_FEATURE_FANCY_PING=y
+CONFIG_ROUTE=y
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_TELNETD=y
+# CONFIG_FEATURE_TELNETD_INETD is not set
+# CONFIG_FEATURE_TELNETD_NO_DAEMONIZE is not set
+CONFIG_TFTP=y
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_FEATURE_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+CONFIG_VCONFIG=y
+# CONFIG_WGET is not set
+
+#
+# udhcp Server/Client
+#
+CONFIG_UDHCPD=y
+CONFIG_UDHCPC=y
+# CONFIG_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# CONFIG_FEATURE_UDHCP_DEBUG is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_PIDOF is not set
+CONFIG_PS=y
+# CONFIG_RENICE is not set
+# CONFIG_TOP is not set
+# CONFIG_UPTIME is not set
+# CONFIG_SYSCTL is not set
+
+#
+# Another Bourne-like Shell
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_LASH is not set
+# CONFIG_FEATURE_SH_IS_MSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+CONFIG_ASH_JOB_CONTROL=y
+CONFIG_ASH_ALIAS=y
+CONFIG_ASH_MATH_SUPPORT=y
+CONFIG_ASH_MATH_SUPPORT_64=y
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_HUSH is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+CONFIG_FEATURE_COMMAND_EDITING=y
+CONFIG_FEATURE_COMMAND_HISTORY=15
+CONFIG_FEATURE_COMMAND_SAVEHISTORY=y
+CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_LOGGER is not set
+
+#
+# Linux System Utilities
+#
+CONFIG_DMESG=y
+# CONFIG_FBSET is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_GETOPT is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_MKSWAP is not set
+CONFIG_MORE=y
+CONFIG_FEATURE_USE_TERMIOS=y
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_SWAPONOFF is not set
+CONFIG_MOUNT=y
+CONFIG_NFSMOUNT=y
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_MOUNT_FORCE=y
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Atheros Communications peek utility
+#
+# CONFIG_PEEK is not set
+
+#
+# Atheros Communications sw_reset utility
+#
+# CONFIG_SW_RESET is not set
+
+#
+# Atheros Communications flash_mac utility
+#
+# CONFIG_FLASH_MAC is not set
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/defconfig-board953x apps_1.2/busybox-1.01/defconfig-board953x
--- apps/busybox-1.01/defconfig-board953x	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/defconfig-board953x	2014-05-30 03:43:44.044943097 -0700
@@ -0,0 +1,473 @@
+#
+# Automatically generated make config: don't edit
+#
+HAVE_DOT_CONFIG=y
+
+#
+# General Configuration
+#
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_FEATURE_VERBOSE_USAGE=y
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_DEVFS is not set
+CONFIG_FEATURE_DEVPTS=y
+# CONFIG_FEATURE_CLEAN_UP is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+CONFIG_STATIC=y
+CONFIG_LFS=y
+USING_CROSS_COMPILER=y
+CROSS_COMPILER_PREFIX="mips-linux-uclibc-"
+EXTRA_CFLAGS_OPTIONS=""
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+PREFIX="./_install"
+
+#
+# Archival Utilities
+#
+# CONFIG_AR is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+CONFIG_FEATURE_TAR_CREATE=y
+CONFIG_FEATURE_TAR_BZIP2=y
+# CONFIG_FEATURE_TAR_FROM is not set
+CONFIG_FEATURE_TAR_GZIP=y
+# CONFIG_FEATURE_TAR_COMPRESS is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY is not set
+CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNZIP is not set
+
+#
+# Common options for cpio and tar
+#
+# CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+# CONFIG_CHOWN is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CMP is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+CONFIG_FEATURE_DATE_ISOFMT=y
+CONFIG_DD=y
+CONFIG_DF=y
+CONFIG_DIRNAME=y
+# CONFIG_DOS2UNIX is not set
+CONFIG_DU=y
+CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+CONFIG_EXPR=y
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+# CONFIG_HEAD is not set
+# CONFIG_HOSTID is not set
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+CONFIG_FEATURE_LS_COLOR=y
+CONFIG_MD5SUM=y
+CONFIG_MKDIR=y
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_OD is not set
+# CONFIG_PRINTF is not set
+CONFIG_PWD=y
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+CONFIG_RMDIR=y
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_STTY is not set
+CONFIG_SYNC=y
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+# CONFIG_TEE is not set
+CONFIG_TEST=y
+
+#
+# test (forced enabled for use with shell)
+#
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+# CONFIG_TR is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WATCH is not set
+CONFIG_WC=y
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls and more
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum
+#
+CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+CONFIG_MKTEMP=y
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_READLINK is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_PATCH is not set
+CONFIG_SED=y
+CONFIG_VI=y
+CONFIG_FEATURE_VI_COLON=y
+CONFIG_FEATURE_VI_YANKMARK=y
+CONFIG_FEATURE_VI_SEARCH=y
+CONFIG_FEATURE_VI_USE_SIGNALS=y
+CONFIG_FEATURE_VI_DOT_CMD=y
+CONFIG_FEATURE_VI_READONLY=y
+CONFIG_FEATURE_VI_SETOPTS=y
+CONFIG_FEATURE_VI_SET=y
+CONFIG_FEATURE_VI_WIN_RESIZE=y
+CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+CONFIG_FIND=y
+CONFIG_FEATURE_FIND_MTIME=y
+CONFIG_FEATURE_FIND_PERM=y
+CONFIG_FEATURE_FIND_TYPE=y
+CONFIG_FEATURE_FIND_XDEV=y
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+CONFIG_XARGS=y
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_INITRD=y
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+CONFIG_FEATURE_INIT_SWAPON=y
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_HALT is not set
+# CONFIG_POWEROFF is not set
+CONFIG_REBOOT=y
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_DELUSER is not set
+CONFIG_GETTY=y
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+CONFIG_LOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_SU=y
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Common options for adduser, deluser, login, su
+#
+CONFIG_FEATURE_SHADOWPASSWDS=y
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_CROND is not set
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_LAST is not set
+# CONFIG_HDPARM is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_MT is not set
+# CONFIG_RX is not set
+CONFIG_STRINGS=y
+# CONFIG_TIME is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_FACTORYRESET=y
+CONFIG_ETHREG=y
+# CONFIG_ETHDEBUG is not set
+CONFIG_MDMM=y
+#
+# Linux Module Utilities
+#
+CONFIG_INSMOD=y
+# CONFIG_FEATURE_2_4_MODULES is not set
+CONFIG_FEATURE_2_6_MODULES=y
+CONFIG_LSMOD=y
+CONFIG_MODPROBE=y
+CONFIG_RMMOD=y
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+CONFIG_ARPING=y
+CONFIG_BRCTL=y
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_HOSTNAME is not set
+CONFIG_HTTPD=y
+# CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+CONFIG_FEATURE_HTTPD_CGI=y
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_S26QOS is not set
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# CONFIG_FEATURE_IFCONFIG_VLAN_IGMP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFUPDOWN is not set
+# CONFIG_INETD is not set
+# CONFIG_IP is not set
+# CONFIG_IPCALC is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+CONFIG_IPROUTE=y
+# CONFIG_IPTUNNEL is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_NC is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+CONFIG_FEATURE_FANCY_PING=y
+CONFIG_ROUTE=y
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_TELNETD=y
+# CONFIG_FEATURE_TELNETD_INETD is not set
+# CONFIG_FEATURE_TELNETD_NO_DAEMONIZE is not set
+CONFIG_TFTP=y
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_FEATURE_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+CONFIG_VCONFIG=y
+# CONFIG_WGET is not set
+
+#
+# udhcp Server/Client
+#
+CONFIG_UDHCPD=y
+CONFIG_UDHCPC=y
+# CONFIG_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# CONFIG_FEATURE_UDHCP_DEBUG is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_PIDOF is not set
+CONFIG_PS=y
+# CONFIG_RENICE is not set
+# CONFIG_TOP is not set
+# CONFIG_UPTIME is not set
+# CONFIG_SYSCTL is not set
+
+#
+# Another Bourne-like Shell
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_LASH is not set
+# CONFIG_FEATURE_SH_IS_MSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+CONFIG_ASH_JOB_CONTROL=y
+CONFIG_ASH_ALIAS=y
+CONFIG_ASH_MATH_SUPPORT=y
+CONFIG_ASH_MATH_SUPPORT_64=y
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_HUSH is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+CONFIG_FEATURE_COMMAND_EDITING=y
+CONFIG_FEATURE_COMMAND_HISTORY=15
+CONFIG_FEATURE_COMMAND_SAVEHISTORY=y
+CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_LOGGER is not set
+
+#
+# Linux System Utilities
+#
+CONFIG_DMESG=y
+# CONFIG_FBSET is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_GETOPT is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_MKSWAP is not set
+CONFIG_MORE=y
+CONFIG_FEATURE_USE_TERMIOS=y
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_SWAPONOFF is not set
+CONFIG_MOUNT=y
+CONFIG_NFSMOUNT=y
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_MOUNT_FORCE=y
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Atheros Communications peek utility
+#
+# CONFIG_PEEK is not set
+
+#
+# Atheros Communications sw_reset utility
+#
+# CONFIG_SW_RESET is not set
+
+#
+# Atheros Communications flash_mac utility
+#
+# CONFIG_FLASH_MAC is not set
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/defconfig-board955x apps_1.2/busybox-1.01/defconfig-board955x
--- apps/busybox-1.01/defconfig-board955x	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/defconfig-board955x	2014-05-30 03:43:44.040943050 -0700
@@ -0,0 +1,475 @@
+#
+# Automatically generated make config: don't edit
+#
+HAVE_DOT_CONFIG=y
+
+#
+# General Configuration
+#
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_FEATURE_VERBOSE_USAGE=y
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_DEVFS is not set
+CONFIG_FEATURE_DEVPTS=y
+# CONFIG_FEATURE_CLEAN_UP is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+CONFIG_STATIC=y
+CONFIG_LFS=y
+USING_CROSS_COMPILER=y
+CROSS_COMPILER_PREFIX="mips-linux-uclibc-"
+EXTRA_CFLAGS_OPTIONS=""
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+PREFIX="./_install"
+
+#
+# Archival Utilities
+#
+# CONFIG_AR is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+CONFIG_FEATURE_TAR_CREATE=y
+CONFIG_FEATURE_TAR_BZIP2=y
+# CONFIG_FEATURE_TAR_FROM is not set
+CONFIG_FEATURE_TAR_GZIP=y
+# CONFIG_FEATURE_TAR_COMPRESS is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY is not set
+CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNZIP is not set
+
+#
+# Common options for cpio and tar
+#
+# CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+# CONFIG_CHOWN is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CMP is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+CONFIG_FEATURE_DATE_ISOFMT=y
+CONFIG_DD=y
+CONFIG_DF=y
+CONFIG_DIRNAME=y
+# CONFIG_DOS2UNIX is not set
+CONFIG_DU=y
+CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+CONFIG_EXPR=y
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+# CONFIG_HEAD is not set
+CONFIG_HEAD=y
+CONFIG_FEATURE_FANCY_HEAD=y
+# CONFIG_HOSTID is not set
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+CONFIG_FEATURE_LS_COLOR=y
+CONFIG_MD5SUM=y
+CONFIG_MKDIR=y
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_OD is not set
+# CONFIG_PRINTF is not set
+CONFIG_PWD=y
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+CONFIG_RMDIR=y
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_STTY is not set
+CONFIG_SYNC=y
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+# CONFIG_TEE is not set
+CONFIG_TEST=y
+
+#
+# test (forced enabled for use with shell)
+#
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+# CONFIG_TR is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WATCH is not set
+CONFIG_WC=y
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls and more
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum
+#
+CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+CONFIG_MKTEMP=y
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_READLINK is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_PATCH is not set
+CONFIG_SED=y
+CONFIG_VI=y
+CONFIG_FEATURE_VI_COLON=y
+CONFIG_FEATURE_VI_YANKMARK=y
+CONFIG_FEATURE_VI_SEARCH=y
+CONFIG_FEATURE_VI_USE_SIGNALS=y
+CONFIG_FEATURE_VI_DOT_CMD=y
+CONFIG_FEATURE_VI_READONLY=y
+CONFIG_FEATURE_VI_SETOPTS=y
+CONFIG_FEATURE_VI_SET=y
+CONFIG_FEATURE_VI_WIN_RESIZE=y
+CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+CONFIG_FIND=y
+CONFIG_FEATURE_FIND_MTIME=y
+CONFIG_FEATURE_FIND_PERM=y
+CONFIG_FEATURE_FIND_TYPE=y
+CONFIG_FEATURE_FIND_XDEV=y
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+CONFIG_XARGS=y
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_INITRD=y
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+CONFIG_FEATURE_INIT_SWAPON=y
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_HALT is not set
+# CONFIG_POWEROFF is not set
+CONFIG_REBOOT=y
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_DELUSER is not set
+CONFIG_GETTY=y
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+CONFIG_LOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_SU=y
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Common options for adduser, deluser, login, su
+#
+CONFIG_FEATURE_SHADOWPASSWDS=y
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_CROND is not set
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_LAST is not set
+# CONFIG_HDPARM is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_MT is not set
+# CONFIG_RX is not set
+CONFIG_STRINGS=y
+# CONFIG_TIME is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_FACTORYRESET=y
+CONFIG_ETHREG=y
+# CONFIG_ETHDEBUG is not set
+CONFIG_MDMM=y
+#
+# Linux Module Utilities
+#
+CONFIG_INSMOD=y
+# CONFIG_FEATURE_2_4_MODULES is not set
+CONFIG_FEATURE_2_6_MODULES=y
+CONFIG_LSMOD=y
+CONFIG_MODPROBE=y
+CONFIG_RMMOD=y
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+CONFIG_ARPING=y
+CONFIG_BRCTL=y
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_HOSTNAME is not set
+CONFIG_HTTPD=y
+# CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+CONFIG_FEATURE_HTTPD_CGI=y
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_S26QOS is not set
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# CONFIG_FEATURE_IFCONFIG_VLAN_IGMP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFUPDOWN is not set
+# CONFIG_INETD is not set
+# CONFIG_IP is not set
+# CONFIG_IPCALC is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+CONFIG_IPROUTE=y
+# CONFIG_IPTUNNEL is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_NC is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+CONFIG_FEATURE_FANCY_PING=y
+CONFIG_ROUTE=y
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_TELNETD=y
+# CONFIG_FEATURE_TELNETD_INETD is not set
+# CONFIG_FEATURE_TELNETD_NO_DAEMONIZE is not set
+CONFIG_TFTP=y
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_FEATURE_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+CONFIG_VCONFIG=y
+# CONFIG_WGET is not set
+
+#
+# udhcp Server/Client
+#
+CONFIG_UDHCPD=y
+CONFIG_UDHCPC=y
+# CONFIG_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# CONFIG_FEATURE_UDHCP_DEBUG is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_PIDOF is not set
+CONFIG_PS=y
+# CONFIG_RENICE is not set
+# CONFIG_TOP is not set
+# CONFIG_UPTIME is not set
+# CONFIG_SYSCTL is not set
+
+#
+# Another Bourne-like Shell
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_LASH is not set
+# CONFIG_FEATURE_SH_IS_MSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+CONFIG_ASH_JOB_CONTROL=y
+CONFIG_ASH_ALIAS=y
+CONFIG_ASH_MATH_SUPPORT=y
+CONFIG_ASH_MATH_SUPPORT_64=y
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_HUSH is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+CONFIG_FEATURE_COMMAND_EDITING=y
+CONFIG_FEATURE_COMMAND_HISTORY=15
+CONFIG_FEATURE_COMMAND_SAVEHISTORY=y
+CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_LOGGER is not set
+
+#
+# Linux System Utilities
+#
+CONFIG_DMESG=y
+# CONFIG_FBSET is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_GETOPT is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_MKSWAP is not set
+CONFIG_MORE=y
+CONFIG_FEATURE_USE_TERMIOS=y
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_SWAPONOFF is not set
+CONFIG_MOUNT=y
+CONFIG_NFSMOUNT=y
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_MOUNT_FORCE=y
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Atheros Communications peek utility
+#
+# CONFIG_PEEK is not set
+
+#
+# Atheros Communications sw_reset utility
+#
+# CONFIG_SW_RESET is not set
+
+#
+# Atheros Communications flash_mac utility
+#
+# CONFIG_FLASH_MAC is not set
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/defconfig-board956x apps_1.2/busybox-1.01/defconfig-board956x
--- apps/busybox-1.01/defconfig-board956x	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/defconfig-board956x	2014-05-30 03:43:44.040943050 -0700
@@ -0,0 +1,475 @@
+#
+# Automatically generated make config: don't edit
+#
+HAVE_DOT_CONFIG=y
+
+#
+# General Configuration
+#
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_FEATURE_VERBOSE_USAGE=y
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_DEVFS is not set
+CONFIG_FEATURE_DEVPTS=y
+# CONFIG_FEATURE_CLEAN_UP is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+CONFIG_STATIC=y
+CONFIG_LFS=y
+USING_CROSS_COMPILER=y
+CROSS_COMPILER_PREFIX="mips-linux-uclibc-"
+EXTRA_CFLAGS_OPTIONS=""
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+PREFIX="./_install"
+
+#
+# Archival Utilities
+#
+# CONFIG_AR is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+CONFIG_FEATURE_TAR_CREATE=y
+CONFIG_FEATURE_TAR_BZIP2=y
+# CONFIG_FEATURE_TAR_FROM is not set
+CONFIG_FEATURE_TAR_GZIP=y
+# CONFIG_FEATURE_TAR_COMPRESS is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY is not set
+CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNZIP is not set
+
+#
+# Common options for cpio and tar
+#
+# CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+# CONFIG_CHOWN is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CMP is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+CONFIG_FEATURE_DATE_ISOFMT=y
+CONFIG_DD=y
+CONFIG_DF=y
+CONFIG_DIRNAME=y
+# CONFIG_DOS2UNIX is not set
+CONFIG_DU=y
+CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+CONFIG_EXPR=y
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+# CONFIG_HEAD is not set
+CONFIG_HEAD=y
+CONFIG_FEATURE_FANCY_HEAD=y
+# CONFIG_HOSTID is not set
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+CONFIG_FEATURE_LS_COLOR=y
+CONFIG_MD5SUM=y
+CONFIG_MKDIR=y
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_OD is not set
+# CONFIG_PRINTF is not set
+CONFIG_PWD=y
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+CONFIG_RMDIR=y
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_STTY is not set
+CONFIG_SYNC=y
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+# CONFIG_TEE is not set
+CONFIG_TEST=y
+
+#
+# test (forced enabled for use with shell)
+#
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+# CONFIG_TR is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WATCH is not set
+CONFIG_WC=y
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls and more
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum
+#
+CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+CONFIG_MKTEMP=y
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_READLINK is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_PATCH is not set
+CONFIG_SED=y
+CONFIG_VI=y
+CONFIG_FEATURE_VI_COLON=y
+CONFIG_FEATURE_VI_YANKMARK=y
+CONFIG_FEATURE_VI_SEARCH=y
+CONFIG_FEATURE_VI_USE_SIGNALS=y
+CONFIG_FEATURE_VI_DOT_CMD=y
+CONFIG_FEATURE_VI_READONLY=y
+CONFIG_FEATURE_VI_SETOPTS=y
+CONFIG_FEATURE_VI_SET=y
+CONFIG_FEATURE_VI_WIN_RESIZE=y
+CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+CONFIG_FIND=y
+CONFIG_FEATURE_FIND_MTIME=y
+CONFIG_FEATURE_FIND_PERM=y
+CONFIG_FEATURE_FIND_TYPE=y
+CONFIG_FEATURE_FIND_XDEV=y
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+CONFIG_XARGS=y
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_INITRD=y
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+CONFIG_FEATURE_INIT_SWAPON=y
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_HALT is not set
+# CONFIG_POWEROFF is not set
+CONFIG_REBOOT=y
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_DELUSER is not set
+CONFIG_GETTY=y
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+CONFIG_LOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_SU=y
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Common options for adduser, deluser, login, su
+#
+CONFIG_FEATURE_SHADOWPASSWDS=y
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_CROND is not set
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_LAST is not set
+# CONFIG_HDPARM is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_MT is not set
+# CONFIG_RX is not set
+CONFIG_STRINGS=y
+# CONFIG_TIME is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_FACTORYRESET=y
+CONFIG_ETHREG=y
+# CONFIG_ETHDEBUG is not set
+CONFIG_MDMM=y
+#
+# Linux Module Utilities
+#
+CONFIG_INSMOD=y
+# CONFIG_FEATURE_2_4_MODULES is not set
+CONFIG_FEATURE_2_6_MODULES=y
+CONFIG_LSMOD=y
+CONFIG_MODPROBE=y
+CONFIG_RMMOD=y
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+CONFIG_ARPING=y
+CONFIG_BRCTL=y
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_HOSTNAME is not set
+CONFIG_HTTPD=y
+# CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+CONFIG_FEATURE_HTTPD_CGI=y
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_S26QOS is not set
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# CONFIG_FEATURE_IFCONFIG_VLAN_IGMP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFUPDOWN is not set
+# CONFIG_INETD is not set
+# CONFIG_IP is not set
+# CONFIG_IPCALC is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+CONFIG_IPROUTE=y
+# CONFIG_IPTUNNEL is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_NC is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+CONFIG_FEATURE_FANCY_PING=y
+CONFIG_ROUTE=y
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_TELNETD=y
+# CONFIG_FEATURE_TELNETD_INETD is not set
+# CONFIG_FEATURE_TELNETD_NO_DAEMONIZE is not set
+CONFIG_TFTP=y
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_FEATURE_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+CONFIG_VCONFIG=y
+# CONFIG_WGET is not set
+
+#
+# udhcp Server/Client
+#
+CONFIG_UDHCPD=y
+CONFIG_UDHCPC=y
+# CONFIG_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# CONFIG_FEATURE_UDHCP_DEBUG is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_PIDOF is not set
+CONFIG_PS=y
+# CONFIG_RENICE is not set
+# CONFIG_TOP is not set
+# CONFIG_UPTIME is not set
+# CONFIG_SYSCTL is not set
+
+#
+# Another Bourne-like Shell
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_LASH is not set
+# CONFIG_FEATURE_SH_IS_MSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+CONFIG_ASH_JOB_CONTROL=y
+CONFIG_ASH_ALIAS=y
+CONFIG_ASH_MATH_SUPPORT=y
+CONFIG_ASH_MATH_SUPPORT_64=y
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_HUSH is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+CONFIG_FEATURE_COMMAND_EDITING=y
+CONFIG_FEATURE_COMMAND_HISTORY=15
+CONFIG_FEATURE_COMMAND_SAVEHISTORY=y
+CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_LOGGER is not set
+
+#
+# Linux System Utilities
+#
+CONFIG_DMESG=y
+# CONFIG_FBSET is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_GETOPT is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_MKSWAP is not set
+CONFIG_MORE=y
+CONFIG_FEATURE_USE_TERMIOS=y
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_SWAPONOFF is not set
+CONFIG_MOUNT=y
+CONFIG_NFSMOUNT=y
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_MOUNT_FORCE=y
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Atheros Communications peek utility
+#
+# CONFIG_PEEK is not set
+
+#
+# Atheros Communications sw_reset utility
+#
+# CONFIG_SW_RESET is not set
+
+#
+# Atheros Communications flash_mac utility
+#
+# CONFIG_FLASH_MAC is not set
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/defconfig-board956x_vlan apps_1.2/busybox-1.01/defconfig-board956x_vlan
--- apps/busybox-1.01/defconfig-board956x_vlan	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/defconfig-board956x_vlan	2014-05-30 03:43:44.040943050 -0700
@@ -0,0 +1,483 @@
+#
+# Automatically generated make config: don't edit
+#
+HAVE_DOT_CONFIG=y
+
+#
+# General Configuration
+#
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_FEATURE_VERBOSE_USAGE=y
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_DEVFS is not set
+CONFIG_FEATURE_DEVPTS=y
+# CONFIG_FEATURE_CLEAN_UP is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+CONFIG_STATIC=y
+CONFIG_LFS=y
+USING_CROSS_COMPILER=y
+CROSS_COMPILER_PREFIX="mips-linux-uclibc-"
+EXTRA_CFLAGS_OPTIONS=""
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+PREFIX="./_install"
+
+#
+# Archival Utilities
+#
+# CONFIG_AR is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+CONFIG_FEATURE_TAR_CREATE=y
+CONFIG_FEATURE_TAR_BZIP2=y
+# CONFIG_FEATURE_TAR_FROM is not set
+CONFIG_FEATURE_TAR_GZIP=y
+# CONFIG_FEATURE_TAR_COMPRESS is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY is not set
+CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNZIP is not set
+
+#
+# Common options for cpio and tar
+#
+# CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+# CONFIG_CHOWN is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CMP is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+CONFIG_FEATURE_DATE_ISOFMT=y
+CONFIG_DD=y
+CONFIG_DF=y
+CONFIG_DIRNAME=y
+# CONFIG_DOS2UNIX is not set
+CONFIG_DU=y
+CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+CONFIG_EXPR=y
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+# CONFIG_HEAD is not set
+CONFIG_HEAD=y
+CONFIG_FEATURE_FANCY_HEAD=y
+# CONFIG_HOSTID is not set
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+CONFIG_FEATURE_LS_COLOR=y
+CONFIG_MD5SUM=y
+CONFIG_MKDIR=y
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_OD is not set
+# CONFIG_PRINTF is not set
+CONFIG_PWD=y
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+CONFIG_RMDIR=y
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_STTY is not set
+CONFIG_SYNC=y
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+# CONFIG_TEE is not set
+CONFIG_TEST=y
+
+#
+# test (forced enabled for use with shell)
+#
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+# CONFIG_TR is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WATCH is not set
+CONFIG_WC=y
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls and more
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum
+#
+CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+CONFIG_MKTEMP=y
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_READLINK is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_PATCH is not set
+CONFIG_SED=y
+CONFIG_VI=y
+CONFIG_FEATURE_VI_COLON=y
+CONFIG_FEATURE_VI_YANKMARK=y
+CONFIG_FEATURE_VI_SEARCH=y
+CONFIG_FEATURE_VI_USE_SIGNALS=y
+CONFIG_FEATURE_VI_DOT_CMD=y
+CONFIG_FEATURE_VI_READONLY=y
+CONFIG_FEATURE_VI_SETOPTS=y
+CONFIG_FEATURE_VI_SET=y
+CONFIG_FEATURE_VI_WIN_RESIZE=y
+CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+CONFIG_FIND=y
+CONFIG_FEATURE_FIND_MTIME=y
+CONFIG_FEATURE_FIND_PERM=y
+CONFIG_FEATURE_FIND_TYPE=y
+CONFIG_FEATURE_FIND_XDEV=y
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+CONFIG_XARGS=y
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_INITRD=y
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+CONFIG_FEATURE_INIT_SWAPON=y
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_HALT is not set
+# CONFIG_POWEROFF is not set
+CONFIG_REBOOT=y
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_DELUSER is not set
+CONFIG_GETTY=y
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+CONFIG_LOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_SU=y
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Common options for adduser, deluser, login, su
+#
+CONFIG_FEATURE_SHADOWPASSWDS=y
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_CROND is not set
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_LAST is not set
+# CONFIG_HDPARM is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_MT is not set
+# CONFIG_RX is not set
+CONFIG_STRINGS=y
+# CONFIG_TIME is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_FACTORYRESET=y
+CONFIG_ETHREG=y
+# CONFIG_ETHDEBUG is not set
+CONFIG_MDMM=y
+#
+# Linux Module Utilities
+#
+CONFIG_INSMOD=y
+# CONFIG_FEATURE_2_4_MODULES is not set
+CONFIG_FEATURE_2_6_MODULES=y
+CONFIG_LSMOD=y
+CONFIG_MODPROBE=y
+CONFIG_RMMOD=y
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+CONFIG_ARPING=y
+CONFIG_BRCTL=y
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_HOSTNAME is not set
+CONFIG_HTTPD=y
+# CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+CONFIG_FEATURE_HTTPD_CGI=y
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_S26QOS is not set
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# CONFIG_FEATURE_IFCONFIG_VLAN_IGMP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFUPDOWN is not set
+# CONFIG_INETD is not set
+CONFIG_IP=y
+CONFIG_FEATURE_IP_ADDRESS=y
+CONFIG_FEATURE_IP_LINK=y
+CONFIG_FEATURE_IP_ROUTE=y
+
+#
+#   route (forced enabled for iproute)
+#
+# CONFIG_FEATURE_IP_TUNNEL is not set
+# CONFIG_IPCALC is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+CONFIG_IPROUTE=y
+# CONFIG_IPTUNNEL is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_NC is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+CONFIG_FEATURE_FANCY_PING=y
+CONFIG_ROUTE=y
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_TELNETD=y
+# CONFIG_FEATURE_TELNETD_INETD is not set
+# CONFIG_FEATURE_TELNETD_NO_DAEMONIZE is not set
+CONFIG_TFTP=y
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_FEATURE_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+CONFIG_VCONFIG=y
+# CONFIG_WGET is not set
+
+#
+# udhcp Server/Client
+#
+CONFIG_UDHCPD=y
+CONFIG_UDHCPC=y
+# CONFIG_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# CONFIG_FEATURE_UDHCP_DEBUG is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_PIDOF is not set
+CONFIG_PS=y
+# CONFIG_RENICE is not set
+# CONFIG_TOP is not set
+# CONFIG_UPTIME is not set
+# CONFIG_SYSCTL is not set
+
+#
+# Another Bourne-like Shell
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_LASH is not set
+# CONFIG_FEATURE_SH_IS_MSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+CONFIG_ASH_JOB_CONTROL=y
+CONFIG_ASH_ALIAS=y
+CONFIG_ASH_MATH_SUPPORT=y
+CONFIG_ASH_MATH_SUPPORT_64=y
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_HUSH is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+CONFIG_FEATURE_COMMAND_EDITING=y
+CONFIG_FEATURE_COMMAND_HISTORY=15
+CONFIG_FEATURE_COMMAND_SAVEHISTORY=y
+CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_LOGGER is not set
+
+#
+# Linux System Utilities
+#
+CONFIG_DMESG=y
+# CONFIG_FBSET is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_GETOPT is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_MKSWAP is not set
+CONFIG_MORE=y
+CONFIG_FEATURE_USE_TERMIOS=y
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_SWAPONOFF is not set
+CONFIG_MOUNT=y
+CONFIG_NFSMOUNT=y
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_MOUNT_FORCE=y
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Atheros Communications peek utility
+#
+# CONFIG_PEEK is not set
+
+#
+# Atheros Communications sw_reset utility
+#
+# CONFIG_SW_RESET is not set
+
+#
+# Atheros Communications flash_mac utility
+#
+# CONFIG_FLASH_MAC is not set
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/defconfig-db12x apps_1.2/busybox-1.01/defconfig-db12x
--- apps/busybox-1.01/defconfig-db12x	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/defconfig-db12x	2014-05-30 03:43:44.048943144 -0700
@@ -0,0 +1,475 @@
+#
+# Automatically generated make config: don't edit
+#
+HAVE_DOT_CONFIG=y
+
+#
+# General Configuration
+#
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_FEATURE_VERBOSE_USAGE=y
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_DEVFS is not set
+CONFIG_FEATURE_DEVPTS=y
+# CONFIG_FEATURE_CLEAN_UP is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+CONFIG_STATIC=y
+CONFIG_LFS=y
+USING_CROSS_COMPILER=y
+CROSS_COMPILER_PREFIX="mips-linux-uclibc-"
+EXTRA_CFLAGS_OPTIONS=""
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+PREFIX="./_install"
+
+#
+# Archival Utilities
+#
+# CONFIG_AR is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+CONFIG_FEATURE_TAR_CREATE=y
+CONFIG_FEATURE_TAR_BZIP2=y
+# CONFIG_FEATURE_TAR_FROM is not set
+CONFIG_FEATURE_TAR_GZIP=y
+# CONFIG_FEATURE_TAR_COMPRESS is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY is not set
+CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNZIP is not set
+
+#
+# Common options for cpio and tar
+#
+# CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+# CONFIG_CHOWN is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CMP is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+CONFIG_FEATURE_DATE_ISOFMT=y
+CONFIG_DD=y
+CONFIG_DF=y
+CONFIG_DIRNAME=y
+# CONFIG_DOS2UNIX is not set
+CONFIG_DU=y
+CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+CONFIG_EXPR=y
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+# CONFIG_HEAD is not set
+CONFIG_HEAD=y
+CONFIG_FEATURE_FANCY_HEAD=y
+# CONFIG_HOSTID is not set
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+CONFIG_FEATURE_LS_COLOR=y
+CONFIG_MD5SUM=y
+CONFIG_MKDIR=y
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_OD is not set
+# CONFIG_PRINTF is not set
+CONFIG_PWD=y
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+CONFIG_RMDIR=y
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_STTY is not set
+CONFIG_SYNC=y
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+# CONFIG_TEE is not set
+CONFIG_TEST=y
+
+#
+# test (forced enabled for use with shell)
+#
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+# CONFIG_TR is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WATCH is not set
+CONFIG_WC=y
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls and more
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum
+#
+CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+CONFIG_MKTEMP=y
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_READLINK is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_PATCH is not set
+CONFIG_SED=y
+CONFIG_VI=y
+CONFIG_FEATURE_VI_COLON=y
+CONFIG_FEATURE_VI_YANKMARK=y
+CONFIG_FEATURE_VI_SEARCH=y
+CONFIG_FEATURE_VI_USE_SIGNALS=y
+CONFIG_FEATURE_VI_DOT_CMD=y
+CONFIG_FEATURE_VI_READONLY=y
+CONFIG_FEATURE_VI_SETOPTS=y
+CONFIG_FEATURE_VI_SET=y
+CONFIG_FEATURE_VI_WIN_RESIZE=y
+CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+CONFIG_FIND=y
+CONFIG_FEATURE_FIND_MTIME=y
+CONFIG_FEATURE_FIND_PERM=y
+CONFIG_FEATURE_FIND_TYPE=y
+CONFIG_FEATURE_FIND_XDEV=y
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+CONFIG_XARGS=y
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_INITRD=y
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+CONFIG_FEATURE_INIT_SWAPON=y
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_HALT is not set
+# CONFIG_POWEROFF is not set
+CONFIG_REBOOT=y
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_DELUSER is not set
+CONFIG_GETTY=y
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+CONFIG_LOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_SU=y
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Common options for adduser, deluser, login, su
+#
+CONFIG_FEATURE_SHADOWPASSWDS=y
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_CROND is not set
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_LAST is not set
+# CONFIG_HDPARM is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_MT is not set
+# CONFIG_RX is not set
+CONFIG_STRINGS=y
+# CONFIG_TIME is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_FACTORYRESET=y
+CONFIG_ETHREG=y
+# CONFIG_ETHDEBUG is not set
+CONFIG_MDMM=y
+#
+# Linux Module Utilities
+#
+CONFIG_INSMOD=y
+# CONFIG_FEATURE_2_4_MODULES is not set
+CONFIG_FEATURE_2_6_MODULES=y
+CONFIG_LSMOD=y
+CONFIG_MODPROBE=y
+CONFIG_RMMOD=y
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+CONFIG_ARPING=y
+CONFIG_BRCTL=y
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_HOSTNAME is not set
+CONFIG_HTTPD=y
+# CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+CONFIG_FEATURE_HTTPD_CGI=y
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_S26QOS is not set
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# CONFIG_FEATURE_IFCONFIG_VLAN_IGMP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFUPDOWN is not set
+# CONFIG_INETD is not set
+# CONFIG_IP is not set
+# CONFIG_IPCALC is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+CONFIG_IPROUTE=y
+# CONFIG_IPTUNNEL is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_NC is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+CONFIG_FEATURE_FANCY_PING=y
+CONFIG_ROUTE=y
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_TELNETD=y
+# CONFIG_FEATURE_TELNETD_INETD is not set
+# CONFIG_FEATURE_TELNETD_NO_DAEMONIZE is not set
+CONFIG_TFTP=y
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_FEATURE_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+CONFIG_VCONFIG=y
+# CONFIG_WGET is not set
+
+#
+# udhcp Server/Client
+#
+CONFIG_UDHCPD=y
+CONFIG_UDHCPC=y
+# CONFIG_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# CONFIG_FEATURE_UDHCP_DEBUG is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_PIDOF is not set
+CONFIG_PS=y
+# CONFIG_RENICE is not set
+# CONFIG_TOP is not set
+# CONFIG_UPTIME is not set
+# CONFIG_SYSCTL is not set
+
+#
+# Another Bourne-like Shell
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_LASH is not set
+# CONFIG_FEATURE_SH_IS_MSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+CONFIG_ASH_JOB_CONTROL=y
+CONFIG_ASH_ALIAS=y
+CONFIG_ASH_MATH_SUPPORT=y
+CONFIG_ASH_MATH_SUPPORT_64=y
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_HUSH is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+CONFIG_FEATURE_COMMAND_EDITING=y
+CONFIG_FEATURE_COMMAND_HISTORY=15
+CONFIG_FEATURE_COMMAND_SAVEHISTORY=y
+CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_LOGGER is not set
+
+#
+# Linux System Utilities
+#
+CONFIG_DMESG=y
+# CONFIG_FBSET is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_GETOPT is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_MKSWAP is not set
+CONFIG_MORE=y
+CONFIG_FEATURE_USE_TERMIOS=y
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_SWAPONOFF is not set
+CONFIG_MOUNT=y
+CONFIG_NFSMOUNT=y
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_MOUNT_FORCE=y
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Atheros Communications peek utility
+#
+# CONFIG_PEEK is not set
+
+#
+# Atheros Communications sw_reset utility
+#
+# CONFIG_SW_RESET is not set
+
+#
+# Atheros Communications flash_mac utility
+#
+# CONFIG_FLASH_MAC is not set
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/defconfig-db12x-db12x-master apps_1.2/busybox-1.01/defconfig-db12x-db12x-master
--- apps/busybox-1.01/defconfig-db12x-db12x-master	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/defconfig-db12x-db12x-master	2014-05-30 03:43:44.040943050 -0700
@@ -0,0 +1,473 @@
+#
+# Automatically generated make config: don't edit
+#
+HAVE_DOT_CONFIG=y
+
+#
+# General Configuration
+#
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_FEATURE_VERBOSE_USAGE=y
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_DEVFS is not set
+CONFIG_FEATURE_DEVPTS=y
+# CONFIG_FEATURE_CLEAN_UP is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_SELINUX is not set
+
+#
+# Build Options
+#
+CONFIG_STATIC=y
+CONFIG_LFS=y
+USING_CROSS_COMPILER=y
+CROSS_COMPILER_PREFIX="mips-linux-uclibc-"
+EXTRA_CFLAGS_OPTIONS=""
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+PREFIX="./_install"
+
+#
+# Archival Utilities
+#
+# CONFIG_AR is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+CONFIG_FEATURE_TAR_CREATE=y
+CONFIG_FEATURE_TAR_BZIP2=y
+# CONFIG_FEATURE_TAR_FROM is not set
+CONFIG_FEATURE_TAR_GZIP=y
+# CONFIG_FEATURE_TAR_COMPRESS is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY is not set
+CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNZIP is not set
+
+#
+# Common options for cpio and tar
+#
+# CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+# CONFIG_CHOWN is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CMP is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+CONFIG_FEATURE_DATE_ISOFMT=y
+CONFIG_DD=y
+CONFIG_DF=y
+CONFIG_DIRNAME=y
+# CONFIG_DOS2UNIX is not set
+CONFIG_DU=y
+CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+CONFIG_EXPR=y
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+# CONFIG_HEAD is not set
+# CONFIG_HOSTID is not set
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+CONFIG_FEATURE_LS_COLOR=y
+CONFIG_MD5SUM=y
+CONFIG_MKDIR=y
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_OD is not set
+# CONFIG_PRINTF is not set
+CONFIG_PWD=y
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+CONFIG_RMDIR=y
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_STTY is not set
+CONFIG_SYNC=y
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+# CONFIG_TEE is not set
+CONFIG_TEST=y
+
+#
+# test (forced enabled for use with shell)
+#
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+# CONFIG_TR is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WATCH is not set
+CONFIG_WC=y
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls and more
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum
+#
+CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_SETKEYCODES is not set
+
+#
+# Debian Utilities
+#
+CONFIG_MKTEMP=y
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_READLINK is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_PATCH is not set
+CONFIG_SED=y
+CONFIG_VI=y
+CONFIG_FEATURE_VI_COLON=y
+CONFIG_FEATURE_VI_YANKMARK=y
+CONFIG_FEATURE_VI_SEARCH=y
+CONFIG_FEATURE_VI_USE_SIGNALS=y
+CONFIG_FEATURE_VI_DOT_CMD=y
+CONFIG_FEATURE_VI_READONLY=y
+CONFIG_FEATURE_VI_SETOPTS=y
+CONFIG_FEATURE_VI_SET=y
+CONFIG_FEATURE_VI_WIN_RESIZE=y
+CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+CONFIG_FIND=y
+CONFIG_FEATURE_FIND_MTIME=y
+CONFIG_FEATURE_FIND_PERM=y
+CONFIG_FEATURE_FIND_TYPE=y
+CONFIG_FEATURE_FIND_XDEV=y
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+CONFIG_XARGS=y
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_INITRD=y
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+CONFIG_FEATURE_INIT_SWAPON=y
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_HALT is not set
+# CONFIG_POWEROFF is not set
+CONFIG_REBOOT=y
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_DELUSER is not set
+CONFIG_GETTY=y
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+CONFIG_LOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_SU=y
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Common options for adduser, deluser, login, su
+#
+CONFIG_FEATURE_SHADOWPASSWDS=y
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_CROND is not set
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_LAST is not set
+# CONFIG_HDPARM is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_MT is not set
+# CONFIG_RX is not set
+CONFIG_STRINGS=y
+# CONFIG_TIME is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_FACTORYRESET is not set
+CONFIG_ETHREG=y
+# CONFIG_ETHDEBUG is not set
+CONFIG_MDMM=y
+#
+# Linux Module Utilities
+#
+CONFIG_INSMOD=y
+# CONFIG_FEATURE_2_4_MODULES is not set
+CONFIG_FEATURE_2_6_MODULES=y
+CONFIG_LSMOD=y
+CONFIG_MODPROBE=y
+CONFIG_RMMOD=y
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+CONFIG_ARPING=y
+CONFIG_BRCTL=y
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_HOSTNAME is not set
+CONFIG_HTTPD=y
+# CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+CONFIG_FEATURE_HTTPD_CGI=y
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_S26QOS is not set
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# CONFIG_FEATURE_IFCONFIG_VLAN_IGMP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFUPDOWN is not set
+# CONFIG_INETD is not set
+# CONFIG_IP is not set
+# CONFIG_IPCALC is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+CONFIG_IPROUTE=y
+# CONFIG_IPTUNNEL is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_NC is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+CONFIG_FEATURE_FANCY_PING=y
+CONFIG_ROUTE=y
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_TELNETD=y
+# CONFIG_FEATURE_TELNETD_INETD is not set
+# CONFIG_FEATURE_TELNETD_NO_DAEMONIZE is not set
+CONFIG_TFTP=y
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_FEATURE_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+CONFIG_VCONFIG=y
+# CONFIG_WGET is not set
+
+#
+# udhcp Server/Client
+#
+CONFIG_UDHCPD=y
+CONFIG_UDHCPC=y
+# CONFIG_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# CONFIG_FEATURE_UDHCP_DEBUG is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_PIDOF is not set
+CONFIG_PS=y
+# CONFIG_RENICE is not set
+# CONFIG_TOP is not set
+# CONFIG_UPTIME is not set
+# CONFIG_SYSCTL is not set
+
+#
+# Another Bourne-like Shell
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_LASH is not set
+# CONFIG_FEATURE_SH_IS_MSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+
+#
+# Ash Shell Options
+#
+CONFIG_ASH_JOB_CONTROL=y
+CONFIG_ASH_ALIAS=y
+CONFIG_ASH_MATH_SUPPORT=y
+CONFIG_ASH_MATH_SUPPORT_64=y
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_HUSH is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+CONFIG_FEATURE_COMMAND_EDITING=y
+CONFIG_FEATURE_COMMAND_HISTORY=15
+CONFIG_FEATURE_COMMAND_SAVEHISTORY=y
+CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
+# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_SH_FANCY_PROMPT=y
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_LOGGER is not set
+
+#
+# Linux System Utilities
+#
+CONFIG_DMESG=y
+# CONFIG_FBSET is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_GETOPT is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_MKSWAP is not set
+CONFIG_MORE=y
+CONFIG_FEATURE_USE_TERMIOS=y
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_SWAPONOFF is not set
+CONFIG_MOUNT=y
+CONFIG_NFSMOUNT=y
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_MOUNT_FORCE=y
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Atheros Communications peek utility
+#
+# CONFIG_PEEK is not set
+
+#
+# Atheros Communications sw_reset utility
+#
+# CONFIG_SW_RESET is not set
+
+#
+# Atheros Communications flash_mac utility
+#
+# CONFIG_FLASH_MAC is not set
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/include/applets.h apps_1.2/busybox-1.01/include/applets.h
--- apps/busybox-1.01/include/applets.h	2014-05-30 03:41:18.047245954 -0700
+++ apps_1.2/busybox-1.01/include/applets.h	2014-05-30 03:43:44.040943050 -0700
@@ -1,4 +1,22 @@
 /*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+/*
  * applets.h - a listing of all busybox applets.
  *
  * If you write a new applet, you need to add an entry to this list to make
@@ -184,9 +202,18 @@
 #ifdef CONFIG_ENV
 	APPLET(env, env_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
+#if defined(CONFIG_ETHREG)
+	APPLET_NOUSAGE("ethreg", ethreg_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
+#if defined(CONFIG_ETHDEBUG)
+	APPLET_NOUSAGE("ethdebug", ethdebug_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_EXPR
 	APPLET(expr, expr_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
+#ifdef CONFIG_FACTORYRESET
+	APPLET(factoryreset, factoryreset_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_FALSE
 	APPLET(false, false_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
@@ -208,6 +235,9 @@
 #ifdef CONFIG_FIND
 	APPLET(find, find_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
+#ifdef CONFIG_FLASH_MAC
+	APPLET(flash_mac, flash_mac_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_FOLD
 	APPLET(fold, fold_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
@@ -364,6 +394,9 @@
 #ifdef CONFIG_MAKEDEVS
 	APPLET(makedevs, makedevs_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
 #endif
+#if defined(CONFIG_MDMM)
+	APPLET_NOUSAGE("md", md_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_MD5SUM
 	APPLET(md5sum, md5sum_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
@@ -388,6 +421,9 @@
 #ifdef CONFIG_MKTEMP
 	APPLET(mktemp, mktemp_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
+#if defined(CONFIG_MDMM)
+	APPLET_NOUSAGE("mm", mm_main, _BB_DIR_BIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_MODPROBE
 	APPLET(modprobe, modprobe_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
 #endif
@@ -430,6 +466,9 @@
 #ifdef CONFIG_PATCH
 	APPLET(patch, patch_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
+#ifdef CONFIG_PEEK
+	APPLET(peek, peek_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_PIDOF
 	APPLET(pidof, pidof_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
@@ -547,6 +586,9 @@
 #ifdef CONFIG_SWAPONOFF
 	APPLET(swapon, swap_on_off_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
 #endif
+#ifdef CONFIG_SW_RESET
+	APPLET(sw_reset, sw_reset_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_SYNC
 	APPLET(sync, sync_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/include/athrs_ctrl.h apps_1.2/busybox-1.01/include/athrs_ctrl.h
--- apps/busybox-1.01/include/athrs_ctrl.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/include/athrs_ctrl.h	2014-05-30 03:43:44.040943050 -0700
@@ -0,0 +1,200 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+#ifndef ATHRS_CTRL_H
+#define ATHRS_CTRL_H
+
+/* Ioctl subroutines */
+#define ATHR_GMAC_QOS_CTRL_IOC      (SIOCDEVPRIVATE | 0x01)
+#define ATHR_GMAC_CTRL_IOC          (SIOCDEVPRIVATE | 0x02)
+#define ATHR_PHY_CTRL_IOC           (SIOCDEVPRIVATE | 0x03)
+#define ATHR_VLAN_IGMP_IOC          (SIOCDEVPRIVATE | 0x04)
+#define ATHR_HW_ACL_IOC             (SIOCDEVPRIVATE | 0x05)
+
+/* 
+ *GMAC_CTRL_IOC_COMMANDS
+ */
+#define ATHR_GMAC_TX_FLOW_CTRL            ((ATHR_GMAC_CTRL_IOC << 16) | 0x1)
+#define ATHR_GMAC_RX_FLOW_CTRL            ((ATHR_GMAC_CTRL_IOC << 16) | 0x2)
+#define ATHR_GMAC_DMA_CHECK               ((ATHR_GMAC_CTRL_IOC << 16) | 0x3)
+#define ATHR_GMAC_SOFT_LED_BLINK          ((ATHR_GMAC_CTRL_IOC << 16) | 0x4)
+#define ATHR_GMAC_SW_ONLY_MODE            ((ATHR_GMAC_CTRL_IOC << 16) | 0x5)
+#define ATHR_GMAC_STATS                   ((ATHR_GMAC_CTRL_IOC << 16) | 0x6)
+#define ATHR_JUMBO_FRAME                  ((ATHR_GMAC_CTRL_IOC << 16) | 0x7)
+#define ATHR_FRAME_SIZE_CTL               ((ATHR_GMAC_CTRL_IOC << 16) | 0x8)
+#define ATHR_GMAC_FLOW_CTRL               ((ATHR_GMAC_CTRL_IOC << 16) | 0x9)                   /* GMAC FLOW CTRL*/
+
+#define ATHR_DBG_CONFIG                   ((ATHR_GMAC_CTRL_IOC << 16) | 0xa)   /* To config debug markers */
+#define ATHR_DBG_RESTART                  ((ATHR_GMAC_CTRL_IOC << 16) | 0xb)   /* To restart ethdebug */
+#define ATHR_DBG_STATS                    ((ATHR_GMAC_CTRL_IOC << 16) | 0xc)   /* For checking current stats */
+#define ATHR_DBG_ENABLE                   ((ATHR_GMAC_CTRL_IOC << 16) | 0xd)   /* To enabled and disabled ethdebug */
+
+/*
+ *PHY_CTRL_COMMANDS
+ */
+#define ATHR_PHY_FORCE           ((ATHR_PHY_CTRL_IOC << 16) | 0x1)
+#define ATHR_PHY_RD              ((ATHR_PHY_CTRL_IOC << 16) | 0x2)
+#define ATHR_PHY_WR              ((ATHR_PHY_CTRL_IOC << 16) | 0x3)
+#define ATHR_PHY_MIB             ((ATHR_PHY_CTRL_IOC << 16) | 0X4)
+#define ATHR_PHY_STATS           ((ATHR_PHY_CTRL_IOC << 16) | 0X5)
+#define ATHR_PORT_STATS          ((ATHR_PHY_CTRL_IOC << 16) | 0X6)
+#define ATHR_PORT_LINK           ((ATHR_PHY_CTRL_IOC << 16) | 0x7)
+#define ATHR_FLOW_LINK_EN        ((ATHR_PHY_CTRL_IOC << 16) | 0x8)
+#define ATHR_PHY_RXFCTL          ((ATHR_PHY_CTRL_IOC << 16) | 0x9)
+#define ATHR_PHY_TXFCTL          ((ATHR_PHY_CTRL_IOC << 16) | 0x10)
+#define ATHR_PHY_FLOW_CTRL       ((ATHR_PHY_CTRL_IOC << 16) | 0x11)
+
+
+#define ATHR_PACKET_FLAG         ((ATHR_VLAN_IGMP_IOC << 16) | 0x1)
+#define ATHR_VLAN_ADDPORTS       ((ATHR_VLAN_IGMP_IOC << 16) | 0x2)
+#define ATHR_VLAN_DELPORTS       ((ATHR_VLAN_IGMP_IOC << 16) | 0x3)
+#define ATHR_VLAN_SETTAGMODE     ((ATHR_VLAN_IGMP_IOC << 16) | 0x4)
+#define ATHR_VLAN_SETDEFAULTID   ((ATHR_VLAN_IGMP_IOC << 16) | 0x5)
+#define ATHR_VLAN_ENABLE         ((ATHR_VLAN_IGMP_IOC << 16) | 0x6)
+#define ATHR_VLAN_DISABLE        ((ATHR_VLAN_IGMP_IOC << 16) | 0x7)
+#define ATHR_IGMP_ON_OFF         ((ATHR_VLAN_IGMP_IOC << 16) | 0x8)
+#define ATHR_LINK_GETSTAT        ((ATHR_VLAN_IGMP_IOC << 16) | 0x9)
+#define ATHR_ARL_ADD             ((ATHR_VLAN_IGMP_IOC << 16) | 0xa)
+#define ATHR_ARL_DEL             ((ATHR_VLAN_IGMP_IOC << 16) | 0xb)
+#define ATHR_MCAST_CLR           ((ATHR_VLAN_IGMP_IOC << 16) | 0xc)
+/*
+ * GMC_QOS_COMMANDS
+ */
+#define ATHR_QOS_ETH_SOFT_CLASS   ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x1)
+#define ATHR_QOS_ETH_PORT         ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x2)
+#define ATHR_QOS_ETH_VLAN         ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x3)
+#define ATHR_QOS_ETH_DA           ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x4)
+#define ATHR_QOS_ETH_IP           ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x5)
+#define ATHR_QOS_PORT_ILIMIT      ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x6)
+#define ATHR_QOS_PORT_ELIMIT      ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x7)
+#define ATHR_QOS_PORT_EQLIMIT     ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x8)
+#define MAX_QOS_COMMAND           ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x9)
+
+/*
+ * ACL COMMANDS
+ */
+#define ATHR_ACL_COMMIT ((ATHR_HW_ACL_IOC << 16) | 0x1)
+#define ATHR_ACL_FLUSH  ((ATHR_HW_ACL_IOC << 16) | 0x2)
+
+
+struct rx_stats{
+        int rx_broad;
+        int rx_pause;
+        int rx_multi;
+        int rx_fcserr;
+        int rx_allignerr;
+        int rx_runt;
+        int rx_frag;
+        int rx_64b;
+        int rx_128b;
+        int rx_256b;
+        int rx_512b;
+        int rx_1024b;
+        int rx_1518b;
+        int rx_maxb;
+        int rx_tool;
+        int rx_goodbl;
+        int rx_goodbh;
+        int rx_overflow;
+        int rx_badbl;
+        int rx_badbu;
+};
+
+struct tx_stats{
+        int tx_broad;
+        int tx_pause;
+        int tx_multi;
+        int tx_underrun;
+        int tx_64b;
+        int tx_128b;
+        int tx_256b;
+        int tx_512b;
+        int tx_1024b;
+        int tx_1518b;
+        int tx_maxb;
+        int tx_oversiz;
+        int tx_bytel;
+        int tx_byteh;
+        int tx_collision;
+        int tx_abortcol;
+        int tx_multicol;
+        int tx_singalcol;
+        int tx_execdefer;
+        int tx_defer;
+        int tx_latecol;
+};
+
+struct tx_mac_stats {
+
+        int pkt_cntr;
+        int byte_cntr;
+        int mcast_cntr;
+        int bcast_cntr;
+        int pctrlframe_cntr;
+        int deferal_cntr;
+        int excess_deferal_cntr;
+        int single_col_cntr;
+        int multi_col_cntr;
+        int late_col_cntr;
+        int excess_col_cntr;
+        int total_col_cntr;
+        int honored_cntr;
+        int dropframe_cntr;
+        int jabberframe_cntr;
+        int fcserr_cntr;
+        int ctrlframe_cntr;
+        int oz_frame_cntr;
+        int us_frame_cntr;
+        int frag_frame_cntr;
+
+};
+
+struct rx_mac_stats {
+
+        int byte_cntr;
+        int pkt_cntr;
+        int fcserr_cntr;
+        int mcast_cntr;
+        int bcast_cntr;
+        int ctrlframe_cntr;
+        int pausefr_cntr;
+        int unknownop_cntr;
+        int allignerr_cntr;
+        int framelerr_cntr;
+        int codeerr_cntr;
+        int carriersenseerr_cntr;
+        int underszpkt_cntr;
+        int ozpkt_cntr;
+        int fragment_cntr;
+        int jabber_cntr;
+        int rcvdrop_cntr;
+        u_int32_t rxoverfl; 
+};
+
+
+typedef struct {
+        u_int32_t link       :1;
+        u_int32_t speed      :2;
+        u_int32_t duplex     :1;
+        u_int32_t rxflctrl   :1;
+        u_int32_t txflctrl   :1;
+}phystats;
+
+#endif       //ATHR_CTRL_H
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/include/usage.h apps_1.2/busybox-1.01/include/usage.h
--- apps/busybox-1.01/include/usage.h	2014-05-30 03:41:18.059246093 -0700
+++ apps_1.2/busybox-1.01/include/usage.h	2014-05-30 03:43:44.040943050 -0700
@@ -1,3 +1,22 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
 #ifndef __BB_USAGE_H__
 #define __BB_USAGE_H__
 
@@ -562,6 +581,16 @@
 	"\t-, -i\tstart with an empty environment\n" \
 	"\t-u\tremove variable from the environment"
 
+#define ethreg_trivial_usage \
+        "[-i ifname] [-p portnum] offset[=value]\n" \
+        "[-f]  portnum=10/100/0 [-d duplex]\n"
+#define ethreg_full_usage \
+        " Can be used to read/write both MAC and PHY registers\n" \
+        ", to change the mode and speed settings for individual PHYs\n" \
+	"Options:\n" \
+        "\t[-i ifname] [-p portnum] offset[=value]\n" \
+        "\t[-f]  portnum=10/100/0 [-d duplex]\n"
+
 #define expr_trivial_usage \
 	"EXPRESSION"
 #define expr_full_usage \
@@ -596,6 +625,16 @@
 	"\\( and \\) or null; if \\( and \\) are not used, they return the number \n" \
 	"of characters matched or 0."
 
+#define factoryreset_trivial_usage \
+	"fr device path "
+#define factoryreset_full_usage \
+	"Waits for the factory reset event from the kernel \n" \
+        "and restores the factory default configuration once \n" \
+        "user holds the jumpstart button for more \n" \
+        "than 3 seconds\n" \
+	"Options:\n" \
+	"\t<dev> -\tpath to the factory reset device \n"
+
 #define false_trivial_usage \
 	""
 #define false_full_usage \
@@ -1105,6 +1144,7 @@
   #define USAGE_IPV6(a)
 #endif
 
+#ifdef CONFIG_FEATURE_IFCONFIG_VLAN_IGMP
 #define ifconfig_trivial_usage \
 	USAGE_IFCONFIG_OPT_A("[-a]") " <interface> [<address>]"
 #define ifconfig_full_usage \
@@ -1120,7 +1160,34 @@
 	"\t[[-]trailers]  [[-]arp]  [[-]allmulti]\n" \
 	"\t[multicast]  [[-]promisc]  [txqueuelen <NN>]  [[-]dynamic]\n" \
 	USAGE_IFCONFIG_MII("\t[mem_start <NN>]  [io_addr <NN>]  [irq <NN>]\n") \
-	"\t[up|down] ..."
+	"\t[up|down] \n" \ 
+	"\t[addports|delports] <vlan-id> <ports> -----add/del ports to/from the given vlan-id.\n" \
+	"\t[igmpon|igmpoff] <vlan-id> -----turn on/off the igmp snoop for the given vlan-id.\n" \
+	"\t[setid|setmode] <vlan-id> <portno> -----set an default vlan-id (egress mode) for the given port\n" \
+	"\t[getstat] <portno> ---- get the status of the link for the given port.\n" \
+	"\t[startvlan |stopvlan]---- please start vlan before you want to start a vlan.\n" \
+	"\tports: bit0->port0,bit1->port1 ... \n" \
+	"\tmode: 0->unmodified,1->untagged,2->tagged \n" \
+	"\tgetstat: portno [1-5];return 0--> down,1-->up \n"
+
+#else
+#define ifconfig_trivial_usage \
+	USAGE_IFCONFIG_OPT_A("[-a]") " <interface> [<address>]"
+#define ifconfig_full_usage \
+	"configure a network interface\n\n" \
+	"Options:\n" \
+	USAGE_IPV6("[add <address>[/<prefixlen>]]\n") \
+	USAGE_IPV6("[del <address>[/<prefixlen>]]\n") \
+	"\t[[-]broadcast [<address>]]  [[-]pointopoint [<address>]]\n" \
+	"\t[netmask <address>]  [dstaddr <address>]\n" \
+	USAGE_SIOCSKEEPALIVE("\t[outfill <NN>] [keepalive <NN>]\n") \
+	"\t" USAGE_IFCONFIG_HW("[hw ether <address>]  ") \
+    "[metric <NN>]  [mtu <NN>]\n" \
+	"\t[[-]trailers]  [[-]arp]  [[-]allmulti]\n" \
+	"\t[multicast]  [[-]promisc]  [txqueuelen <NN>]  [[-]dynamic]\n" \
+	USAGE_IFCONFIG_MII("\t[mem_start <NN>]  [io_addr <NN>]  [irq <NN>]\n") \
+	"\t[up|down] \n"
+#endif
 
 #define ifup_trivial_usage \
 	"<-ahinv> <ifaces...>"
@@ -2905,4 +2972,18 @@
 #define zcat_full_usage \
 	"Uncompress to stdout."
 
+
+#define peek_trivial_usage "peek <addr> <len>\n"
+#define peek_full_usage "peek <addr> <len>\n"
+
+#define sw_reset_trivial_usage "reset board\n"
+
+#define sw_reset_full_usage \
+	"resets board if pressed for less than 4\n" \
+	"If pressed for more than 4 seconds reinstalls default configuration\n"
+
+
+#define flash_mac_trivial_usage "flash_mac sets MAC addr\n"
+#define flash_mac_full_usage "flash_mac sets MAC addr\n"
+
 #endif /* __BB_USAGE_H__ */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/init/init.c apps_1.2/busybox-1.01/init/init.c
--- apps/busybox-1.01/init/init.c	2014-05-30 03:41:18.059246093 -0700
+++ apps_1.2/busybox-1.01/init/init.c	2014-05-30 03:43:44.040943050 -0700
@@ -5,6 +5,7 @@
  * Copyright (C) 1995, 1996 by Bruce Perens <bruce@pixar.com>.
  * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
  * Adjusted by so many folks, it's impossible to keep track.
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -734,7 +735,9 @@
 	for (a = init_action_list; a; a = tmp) {
 		tmp = a->next;
 		if (a->action & RESTART) {
+			message(CONSOLE | LOG, "Restart! -- shutdown now.");
 			shutdown_system();
+			message(CONSOLE | LOG, "Restart! -- shutdown done.");
 
 			/* unblock all signals, blocked in shutdown_system() */
 			sigemptyset(&unblock_signals);
@@ -772,7 +775,7 @@
 			dup(0);
 			dup(0);
 
-			messageD(CONSOLE | LOG, "Trying to re-exec %s", a->command);
+			message(CONSOLE | LOG, "Trying to re-exec %s", a->command);
 			execl(a->command, a->command, NULL);
 
 			message(CONSOLE | LOG, "exec of '%s' failed: %m",
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/libbb/procps.c apps_1.2/busybox-1.01/libbb/procps.c
--- apps/busybox-1.01/libbb/procps.c	2014-05-30 03:41:18.075246279 -0700
+++ apps_1.2/busybox-1.01/libbb/procps.c	2014-05-30 03:43:44.048943144 -0700
@@ -4,6 +4,7 @@
  *
  * Copyright 1998 by Albert Cahalan; all rights reserved.
  * Copyright (C) 2002 by Vladimir Oleynik <dzo@simtreas.ru>
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  * GNU Library General Public License Version 2, or any later version
  *
  */
@@ -12,7 +13,6 @@
 #include <string.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <asm/page.h>
 
 #include "libbb.h"
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/loginutils/getty.c apps_1.2/busybox-1.01/loginutils/getty.c
--- apps/busybox-1.01/loginutils/getty.c	2014-05-30 03:41:18.091246464 -0700
+++ apps_1.2/busybox-1.01/loginutils/getty.c	2014-05-30 03:43:44.036943004 -0700
@@ -1,3 +1,5 @@
+/** Copyright (c) 2013 Qualcomm Atheros, Inc. */
+
 /* vi: set sw=4 ts=4: */
 /* agetty.c - another getty program for Linux. By W. Z. Venema 1989
    Ported to Linux by Peter Orbaek <poe@daimi.aau.dk>
@@ -483,8 +485,17 @@
 
 	debug("entered parse_speeds\n");
 	for (cp = strtok(arg, ","); cp != 0; cp = strtok((char *) 0, ",")) {
-		if ((op->speeds[op->numspeed++] = bcode(cp)) <= 0)
+		op->speeds[op->numspeed] = bcode(cp);
+		if (op->speeds[op->numspeed] < 0)
 			error("bad speed: %s", cp);
+ 		if (op->speeds[op->numspeed] == 0) {
+ 			struct termios tio;
+ 			if (tcgetattr(1, &tio) != 0) {
+ 				bb_error_msg_and_die("getty.c: tcgetattr(1, &tio) failed\n");
+ 			}
+ 			op->speeds[op->numspeed] = cfgetospeed(&tio);
+ 		}
+		op->numspeed ++;
 		if (op->numspeed > MAX_SPEED)
 			error("too many alternate speeds");
 	}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/Makefile apps_1.2/busybox-1.01/Makefile
--- apps/busybox-1.01/Makefile	2014-05-30 03:41:17.855243727 -0700
+++ apps_1.2/busybox-1.01/Makefile	2014-05-30 03:43:44.044943097 -0700
@@ -1,6 +1,7 @@
 # Makefile for busybox
 #
 # Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -44,6 +45,14 @@
 	networking/libiproute networking/libbridge networking/udhcp procps loginutils shell \
 	sysklogd util-linux libpwdgrp coreutils/libcoreutils libbb
 
+ifeq ($(BOARD_TYPE), ap71)
+DIRS:=$(DIRS) ../ap71/flash_mac ../ap71/peek ../ap71/sw_reset
+else
+ifeq ($(BOARD_TYPE), ob42)
+DIRS:=$(DIRS) ../ap71/flash_mac
+endif
+endif
+
 SRC_DIRS:=$(patsubst %,$(top_srcdir)/%,$(DIRS))
 
 ifeq ($(strip $(CONFIG_SELINUX)),y)
@@ -51,7 +60,15 @@
 LIBRARIES += -lsecure
 endif
 
+ifeq ($(BOARD_TYPE), ap71)
+CONFIG_CONFIG_IN = $(top_srcdir)/sysdeps/$(TARGET_OS)/Config.ap71.in
+else
+ifeq ($(BOARD_TYPE), ob42)
+CONFIG_CONFIG_IN = $(top_srcdir)/sysdeps/$(TARGET_OS)/Config.ob42.in
+else
 CONFIG_CONFIG_IN = $(top_srcdir)/sysdeps/$(TARGET_OS)/Config.in
+endif
+endif
 CONFIG_DEFCONFIG = $(top_srcdir)/sysdeps/$(TARGET_OS)/defconfig
 
 ALL_DIRS:= $(DIRS) scripts/config
@@ -125,7 +142,6 @@
 
 busybox: $(ALL_MAKEFILES) .depend include/config.h $(libraries-y)
 	$(CC) $(LDFLAGS) -o $@ -Wl,--start-group $(libraries-y) $(LIBRARIES) -Wl,--end-group
-	$(STRIPCMD) $@
 
 busybox.links: $(top_srcdir)/applets/busybox.mkll include/config.h $(top_srcdir)/include/applets.h
 	- $(SHELL) $^ >$@
@@ -267,6 +283,7 @@
 	@./scripts/config/conf -d $(CONFIG_CONFIG_IN)
 
 clean:
+	- rm -f .config
 	- rm -f docs/busybox.dvi docs/busybox.ps \
 	    docs/busybox.pod docs/busybox.net/busybox.html \
 	    docs/busybox pod2htm* *.gdb *.elf *~ core .*config.log \
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/miscutils/Config.in apps_1.2/busybox-1.01/miscutils/Config.in
--- apps/busybox-1.01/miscutils/Config.in	2014-05-30 03:41:18.091246464 -0700
+++ apps_1.2/busybox-1.01/miscutils/Config.in	2014-05-30 03:43:44.052943190 -0700
@@ -1,4 +1,22 @@
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+#
+
+#
 # For a description of the syntax of this configuration file,
 # see scripts/kbuild/config-language.txt.
 #
@@ -198,5 +216,33 @@
 	  certain amount of time, the watchdog device assumes the system has
 	  hung, and will cause the hardware to reboot.
 
+config CONFIG_FACTORYRESET
+	bool "Factory reset"
+	default n
+	help
+	  The factory reset utility will restore the configuration files to
+	  the default factory settings and will reboot the board if the factory
+	  reset/jumpstart button is held for more than 3 seconds.
+
+config CONFIG_ETHREG
+	bool "Ethreg Utility"
+	default n
+	help
+	  The ethreg utility can be used to read/write MAC and PHY registers
+	  to change the duplex and speed setting for individual PHYS.
+
+config CONFIG_MDMM
+	bool "MDMM Utility"
+	default n
+	help
+	  The md/mm utility can be used to read/write memory and memory 
+	  mapped registers.
+
+config CONFIG_ETHDEBUG
+	bool "Ethdebug Utility"
+	default n
+	help
+	  The ethdebug utility can be used to debug ethernet rx drops.
+
 endmenu
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/miscutils/ethdebug.c apps_1.2/busybox-1.01/miscutils/ethdebug.c
--- apps/busybox-1.01/miscutils/ethdebug.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/miscutils/ethdebug.c	2014-05-30 03:43:44.052943190 -0700
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <getopt.h>
+#include <errno.h>
+#include <err.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <net/if.h>
+#include <fcntl.h>
+#include "ethdebug.h"
+#include "athrs_ctrl.h"
+
+struct eth_cfg_params {
+     int  cmd;
+    struct eth_dbg_params eth_vi_dbg_params;
+};
+
+struct eth_params {
+     int  cmd;
+     int val;
+};
+
+void dumpdbgconfig(void);
+int  loadconfig(void);
+static void usage(void);
+
+struct ifreq ifrequest;
+struct eth_cfg_params etd;
+struct eth_params ep;
+int sockfd;
+const char *prog;
+char filename[40];
+
+
+void dumpdbgconfig(void)
+{
+   int i=i,j=0;
+   printf("\n Rxseqnumber offset : %04x and size: %d bytes", etd.eth_vi_dbg_params.vi_dbg.rxseq_offset, etd.eth_vi_dbg_params.vi_dbg.rxseq_num_bytes);
+   printf("\n Numbers of streams: %d", etd.eth_vi_dbg_params.vi_num_streams);
+   printf("\n Numbers of markers: %d", etd.eth_vi_dbg_params.vi_num_markers);
+   for (i=0;i<etd.eth_vi_dbg_params.vi_num_streams;i++)	
+   {
+     printf("\n -- Stream %d configuration -- ", i+1);  
+     for (j=0;j<etd.eth_vi_dbg_params.vi_num_markers;j++)	
+       printf("\nmarker%d: Offset: %04x Size: %d Match: %08x",  j+1, etd.eth_vi_dbg_params.vi_dbg.markers[i][j].offset, etd.eth_vi_dbg_params.vi_dbg.markers[i][j].num_bytes
+                                                             , etd.eth_vi_dbg_params.vi_dbg.markers[i][j].match);
+   }
+   printf("\n Max Seq number: %08x", etd.eth_vi_dbg_params.vi_rx_seq_max);
+   printf("\n Debug cfg: %d \n", etd.eth_vi_dbg_params.vi_dbg_cfg);
+}
+
+int loadconfig(void)
+{
+   int ch;
+   char line[100];
+   FILE *fp;
+   unsigned int temp=0, offset, num_bytes, match;
+   int markers=0, streams=0, i, j;
+   fp = fopen (filename, "rt");
+   if (fp == NULL)
+   {
+       fprintf(stderr, "File Not Found !!!\n");
+       return -1;
+   }
+
+   do
+   {
+     ch = fgetc(fp);
+   } while(('$'!=ch) && (EOF != ch));
+
+   if (EOF ==fscanf(fp,"%x",&temp))
+       return -1;
+   fgets(line,100,fp);
+   etd.eth_vi_dbg_params.vi_rxseq_offset_size = temp;
+   etd.eth_vi_dbg_params.vi_dbg.rxseq_num_bytes =temp & 0x0000FFFF;
+   etd.eth_vi_dbg_params.vi_dbg.rxseq_offset =(temp >> 16);
+
+
+   if (EOF == fscanf(fp,"%d",&streams))
+       return -1;
+   fgets(line,100,fp);
+   etd.eth_vi_dbg_params.vi_num_streams = streams;
+
+   if (EOF == fscanf(fp,"%d",&markers))
+       return -1;
+   fgets(line,100,fp);    
+   etd.eth_vi_dbg_params.vi_num_markers = markers;
+
+
+   for(i=0;i<streams;i++) 
+   {
+      for(j=0;j<markers;j++)		
+      {
+
+	   if (EOF == fscanf(fp,"%x",&temp))
+           return -1;
+   	   fgets(line,100,fp);
+	   offset = temp >> 16;
+	   num_bytes = temp & 0x0000FFFF;
+	   if (EOF == fscanf(fp,"%x",&temp))
+           return -1;
+   	   fgets(line,100,fp);
+	   match = temp;
+
+	   etd.eth_vi_dbg_params.vi_dbg.markers[i][j].offset    = offset;
+       etd.eth_vi_dbg_params.vi_dbg.markers[i][j].num_bytes = num_bytes;
+	   etd.eth_vi_dbg_params.vi_dbg.markers[i][j].match     = match;
+
+
+      }
+   }
+
+   if(EOF == fscanf(fp,"%x",&temp))
+       return -1;
+   fgets(line,100,fp);
+   etd.eth_vi_dbg_params.vi_rx_seq_max = temp;
+
+   etd.eth_vi_dbg_params.vi_dbg_cfg = 0;
+   dumpdbgconfig();
+   fclose(fp);
+   return 0;
+}
+
+static void
+usage(void)
+{
+	fprintf(stderr, "usage: %s [-x configfilename] \n", prog);
+	fprintf(stderr, "usage: %s [-e <value>] enable/disable\n", prog);
+	fprintf(stderr, "usage: %s [-r]to restart debug \n", prog);
+	fprintf(stderr, "usage: %s [-s]to get eth rx drop stats \n", prog);
+	exit(-1);
+}
+
+int
+ethdebug_main(int argc, char *argv[])
+{
+	const char *ifname = "eth0";
+    char *fname=NULL;
+	int c,do_dbg=0,do_stats=0,do_restart=0,do_enable=0,enable=0;
+	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
+	if (sockfd < 0)
+		err(1, "socket");
+
+	prog = argv[0];
+
+	while ((c = getopt(argc, argv, "irsx:e:")) != -1) { 
+	    switch (c) {
+		case 'i':
+			ifname = optarg;
+			break;
+        case 'r':
+			do_restart = 1;
+            break;
+        case 's':
+			do_stats = 1;
+            break;
+        case 'e':
+			do_enable = 1;
+            enable = atoi(optarg);
+            break;
+        case 'x':
+            fname = optarg;
+            strcpy(filename, fname);
+			do_dbg=1;
+			break;
+		
+        default:
+			usage();
+			/*NOTREACHED*/
+		}
+    }
+
+    if (do_enable)
+    {
+        printf("Enable Debug ...\n");
+     	strncpy(ifrequest.ifr_name, ifname, IFNAMSIZ);
+        ifrequest.ifr_data = (void *) &ep;
+	    ep.cmd     = ATHR_DBG_ENABLE;
+	    ep.val     = enable;
+		if (ioctl(sockfd, ATHR_GMAC_CTRL_IOC, &ifrequest) < 0)
+			err(1, "Error in ioctl");
+        return 0;
+    }
+
+    if(do_stats)
+    {
+     	strncpy(ifrequest.ifr_name, ifname, IFNAMSIZ);
+        ifrequest.ifr_data = (void *) &ep;
+	    ep.cmd     = ATHR_DBG_STATS;
+		if (ioctl(sockfd, ATHR_GMAC_CTRL_IOC, &ifrequest) < 0)
+			err(1, "Error in ioctl");
+        printf("Drops from Application : %d \n", ep.val);
+        return 0;
+    }
+
+    if(do_restart)
+    {
+        printf("Restarting Debug ...\n");
+     	strncpy(ifrequest.ifr_name, ifname, IFNAMSIZ);
+        ifrequest.ifr_data = (void *) &ep;
+	    ep.cmd     = ATHR_DBG_RESTART;
+		if (ioctl(sockfd, ATHR_GMAC_CTRL_IOC, &ifrequest) < 0)
+			err(1, "Error in ioctl");
+        return 0;
+    }
+
+	if (do_dbg)        
+	{
+		//add debug configuration here
+	    strncpy(ifrequest.ifr_name, ifname, IFNAMSIZ);
+        if (-1 == loadconfig())
+        {
+           fprintf(stderr, "Error in configuration\n");
+           return -1;
+        }
+        ifrequest.ifr_data = (void *) &etd;
+	    etd.cmd     = ATHR_DBG_CONFIG;
+		if (ioctl(sockfd, ATHR_GMAC_CTRL_IOC, &ifrequest) < 0)
+			err(1, "Error in ioctl");
+        return 0;
+
+	}
+    return 0;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/miscutils/ethdebug.h apps_1.2/busybox-1.01/miscutils/ethdebug.h
--- apps/busybox-1.01/miscutils/ethdebug.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/miscutils/ethdebug.h	2014-05-30 03:43:44.052943190 -0700
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+#ifndef _ETH_RX_DBG_H_
+#define _ETH_RX_DBG_H_
+
+#define  MAX_NUM_MARKERS  4
+#define  MAX_NUM_STREAMS  4
+
+/* Structure to hold marker information
+ */
+struct marker_info {
+    u_int16_t  offset;     /* Marker offset in bytes wrt start of the wbuf     */
+	u_int16_t  num_bytes;  /* Width of the marker field in bytes - max 4 bytes */
+    u_int32_t  match;      /* Marker pattern match value- used as packet filter */
+};
+
+/* Video debug structure 
+ * Used to hold marker, rx sequence number & timestamp information
+ */ 
+struct eth_dbg {
+	/* Marker information per stream */                       
+    struct     marker_info markers[MAX_NUM_STREAMS][MAX_NUM_MARKERS];
+	u_int16_t  rxseq_offset;    /* Pkt seq number offset in bytes wrt wbuf start        */
+	u_int16_t  rxseq_num_bytes; /* Number of bytes that make up the pkt seq num field   */
+	u_int16_t  time_offset;     /* Pkt timestamp offset in bytes wrt wbuf start         */   
+	u_int16_t  time_num_bytes;	/* Number of bytes that make up the pkt timestamp field */
+};
+
+/* Video debug parameters - set using ethdebug program 
+ * These parameters are used to provide the user with an interface to set markers for filtering
+ * received packets & finding the locations of the rxsequence numbers/timestamps within the wbuf
+ * The markers can be used to look for signatures of pkts generated by standard test tools like
+ * chariot/iperf. These marker fields can be extracted from the wbuf by looking at the offset wrt
+ * the start of the wbuf & extracting the number of bytes that correspond to this marker. The
+ * extracted marker can then be compared with a matching pattern & filtered appropriately.
+ * The rx sequence number & timetamp can also be extracted from the wbuf by looking at the offset 
+ * wrt the start of the wbuf & extracting the number of bytes that correspond to the rx seq num &
+ * timestamp respectively. These can be used to detect pkt losses and for jitter measurements
+ */ 
+struct eth_dbg_params {
+	u_int32_t vi_dbg_cfg;            /* Video debug configuration - Bit0- enable dbg */
+	u_int8_t  vi_num_streams;        /* Number of streams */
+	u_int8_t  vi_stream_num;         /* the stream number whose markers are being set */
+    u_int8_t  vi_num_markers;        /* total number of markers used to filter pkts */   
+    u_int8_t  vi_marker_num;         /* the marker number whose parameters (offset, size & match) are being set */
+    u_int32_t vi_marker_offset_size; /* byte offset from skb start (upper 16 bits) & size in bytes(lower 16 bits) */
+    u_int32_t vi_marker_match;       /* marker pattern match used in filtering */
+    u_int32_t vi_rxseq_offset_size;  /* Rx Seq num offset skb start (upper 16 bits) & size in bytes(lower 16 bits) */
+	u_int32_t vi_rx_seq_rshift;      /* right-shift value in case field is not word aligned */
+	u_int32_t vi_rx_seq_max;         /* Max Rx seq number */ 
+	u_int32_t vi_rx_seq_drop;        /* Indicator to the debug app that a particular seq num has been dropped */ 
+	u_int32_t vi_time_offset_size;   /* Timestamp offset skb start (upper 16 bits) & size in bytes(lower 16 bits) */
+    u_int32_t vi_dbg_restart;        /* set to 1 to re-initialize counters/parameters */   
+    struct eth_dbg vi_dbg;
+};
+
+#endif
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/miscutils/ethreg.c apps_1.2/busybox-1.01/miscutils/ethreg.c
--- apps/busybox-1.01/miscutils/ethreg.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/miscutils/ethreg.c	2014-05-30 03:43:44.052943190 -0700
@@ -0,0 +1,795 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <getopt.h>
+#include <errno.h>
+#include <err.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <net/if.h>
+#include <fcntl.h>
+#include "busybox.h"
+#include "athrs_ctrl.h"
+#define MAX_SIZ 10
+
+struct eth_cfg_params {
+     int  cmd;
+     char    ad_name[IFNAMSIZ];      /* if name, e.g. "eth0" */
+     uint16_t vlanid;
+     uint16_t portnum;
+     uint32_t phy_reg;
+     uint32_t tos;
+     uint32_t val;
+     uint8_t duplex;
+     uint8_t  mac_addr[6];
+     struct rx_stats rxcntr;
+     struct tx_stats txcntr;
+     struct tx_mac_stats txmac;
+     struct rx_mac_stats rxmac;
+     phystats phy_st;
+
+};
+
+struct ifreq ifr;
+struct eth_cfg_params etd;
+int s,opt_force = 0,duplex = 1;
+const char *progname;
+static void rx_stats(void)
+{
+        //printf ("\n\n%s\n", __func__);
+        printf ("\t%d\t port%d :Rx bcast cntr\n", etd.rxcntr.rx_broad, etd.portnum);
+        printf ("\t%d\t port%d :Rx pause cntr\n", etd.rxcntr.rx_pause, etd.portnum);
+        printf ("\t%d\t port%d :Rx multi frames rcvd\n", etd.rxcntr.rx_multi, etd.portnum);
+        printf ("\t%d\t port%d :Rx fcs err cntr\n", etd.rxcntr.rx_fcserr,  etd.portnum);
+        printf ("\t%d\t port%d :Rx allign err cntr\n", etd.rxcntr.rx_allignerr, etd.portnum);
+        printf ("\t%d\t port%d :Rx runt cntr \n", etd.rxcntr.rx_runt, etd.portnum);
+        printf ("\t%d\t port%d :Rx fragment cntr\n", etd.rxcntr.rx_frag, etd.portnum);
+        printf ("\t%d\t port%d :Rx 64b byte cntr\n", etd.rxcntr.rx_64b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 128b byte cntr\n", etd.rxcntr.rx_128b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 256b byte cntr\n", etd.rxcntr.rx_256b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 512b byte cntr\n", etd.rxcntr.rx_512b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 1024b byte cntr\n", etd.rxcntr.rx_1024b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 1518b byte cntr\n ", etd.rxcntr.rx_1518b, etd.portnum);
+        printf ("\t%d\t port%d :Rx total pkt rcvd\n", (etd.rxcntr.rx_64b + etd.rxcntr.rx_128b + etd.rxcntr.rx_256b +
+                                etd.rxcntr.rx_512b + etd.rxcntr.rx_1024b + etd.rxcntr.rx_1518b), etd.portnum);
+        printf ("\t%d\t port%d :Rx maxb cntr\n", etd.rxcntr.rx_maxb, etd.portnum);
+        printf ("\t%d\t port%d :Rx too long cntr\n", etd.rxcntr.rx_tool, etd.portnum);
+        printf ("\t%d\t port%d :Rx byte_l\n", etd.rxcntr.rx_goodbl, etd.portnum);
+        printf ("\t%d\t port%d :Rx byte_h\n", etd.rxcntr.rx_goodbh, etd.portnum);
+        printf ("\t%d\t port%d :Rx overflow cntr\n", etd.rxcntr.rx_overflow, etd.portnum);
+        printf ("\t%d\t port%d :Rx bad byte_l cntr\n", etd.rxcntr.rx_badbl, etd.portnum);
+        printf ("\t%d\t port%d :Rx bad byte_u cntr\n", etd.rxcntr.rx_badbu, etd.portnum);
+}
+
+static void tx_stats(void)
+{
+        printf ("\n\n%s\n", __func__);
+        printf ("\t%d\t port%d : Tx bcast cntr \n", etd.txcntr.tx_broad, etd.portnum);
+        printf ("\t%d\t port%d : Tx pause cntr\n", etd.txcntr.tx_pause, etd.portnum);
+        printf ("\t%d\t port%d : Tx multi cntr\n", etd.txcntr.tx_multi, etd.portnum);
+        printf ("\t%d\t port%d : Tx under run cntr\n", etd.txcntr.tx_underrun, etd.portnum);
+        printf ("\t%d\t port%d : Tx 64b byte cntr\n", etd.txcntr.tx_64b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 128b byte cntr\n", etd.txcntr.tx_128b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 256b byte cntr\n", etd.txcntr.tx_256b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 512b byte cntr\n", etd.txcntr.tx_512b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 1024b byte cntr\n", etd.txcntr.tx_1024b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 1518b byte cntr\n", etd.txcntr.tx_1518b, etd.portnum);
+        printf ("\t%d\t port%d : Tx total pkt txmtd cntr\n", (etd.txcntr.tx_64b + etd.txcntr.tx_128b
+                                      + etd.txcntr.tx_256b+ etd.txcntr.tx_512b + etd.txcntr.tx_1024b
+                                      + etd.txcntr.tx_1518b), etd.portnum);
+        printf ("\t%d\t port%d : Tx max byte cntr\n", etd.txcntr.tx_maxb, etd.portnum);
+        printf ("\t%d\t port%d : Tx oversize \n", etd.txcntr.tx_oversiz, etd.portnum);
+        printf ("\t%d\t port%d : Tx byte _l \n", etd.txcntr.tx_bytel, etd.portnum);
+        printf ("\t%d\t port%d : Tx byte _h \n", etd.txcntr.tx_byteh, etd.portnum);
+        printf ("\t%d\t port%d : Tx collision err cntr\n", etd.txcntr.tx_collision, etd.portnum);
+        printf ("\t%d\t port%d : Tx abort collision err cntr\n", etd.txcntr.tx_abortcol, etd.portnum);
+        printf ("\t%d\t port%d : Tx multi collision err cntr\n", etd.txcntr.tx_multicol, etd.portnum);
+        printf ("\t%d\t port%d : Tx single collision err cntr\n", etd.txcntr.tx_singalcol, etd.portnum);
+        printf ("\t%d\t port%d : Tx exec deffer err cntr\n", etd.txcntr.tx_execdefer, etd.portnum);
+        printf ("\t%d\t port%d : Tx defer err cntr\n", etd.txcntr.tx_defer, etd.portnum);
+        printf ("\t%d\t port%d : Tx late collision err cntr\n", etd.txcntr.tx_latecol, etd.portnum);
+
+}
+static void tx_mac_stats(void)
+{
+        printf ("\n\n%s\n", __func__);
+        printf ("\t%d\t : Tx pkt cntr\n", etd.txmac.pkt_cntr);
+        printf ("\t%d\t : Tx byte cntr\n", etd.txmac.byte_cntr);
+        printf ("\t%d\t : Tx mcast pkt cntr\n", etd.txmac.mcast_cntr);
+        printf ("\t%d\t : Tx bcast pkt cntr\n", etd.txmac.bcast_cntr);
+        printf ("\t%d\t : Tx pause frame pkt cntr\n", etd.txmac.pctrlframe_cntr);
+        printf ("\t%d\t : Tx deferal pkt cntr\n", etd.txmac.deferal_cntr);
+        printf ("\t%d\t : Tx excessive deferal pkt cntr\n", etd.txmac.excess_deferal_cntr);
+        printf ("\t%d\t : Tx single collision pkt cntr\n", etd.txmac.single_col_cntr);
+        printf ("\t%d\t : Tx multiple collision pkt cntr\n", etd.txmac.multi_col_cntr);
+        printf ("\t%d\t : Tx late collision pkt cntr\n", etd.txmac.late_col_cntr);
+        printf ("\t%d\t : Tx excessive collison pkt cntr\n", etd.txmac.excess_col_cntr);
+        printf ("\t%d\t : Tx total collison pkt cntr\n", etd.txmac.total_col_cntr);
+        printf ("\t%d\t : Tx drop frame cntr\n", etd.txmac.dropframe_cntr);
+        printf ("\t%d\t : Tx jabber frame cntr\n", etd.txmac.jabberframe_cntr);
+        printf ("\t%d\t : Tx fcs err cntr\n", etd.txmac.fcserr_cntr);
+        printf ("\t%d\t : Tx control frame cntr\n", etd.txmac.ctrlframe_cntr);
+        printf ("\t%d\t : Tx oversize frame cntr\n", etd.txmac.oz_frame_cntr);
+        printf ("\t%d\t : Tx undersize frame cntr\n", etd.txmac.us_frame_cntr);
+        printf ("\t%d\t : Tx fragments frame cntr\n", etd.txmac.frag_frame_cntr);
+
+}
+static void rx_mac_stats (void)
+{
+        printf ("\n\n%s\n", __func__);
+        printf ("\t%d\t: Rx byte cntr\n", etd.rxmac.byte_cntr);
+        printf ("\t%d\t: Rx pkt cntr\n", etd.rxmac.pkt_cntr);
+        printf ("\t%d\t: Rx fcs err cntr\n", etd.rxmac.fcserr_cntr);
+        printf ("\t%d\t: Rx mcast pkt cntr\n", etd.rxmac.mcast_cntr);
+        printf ("\t%d\t: Rx bcast pkt cntr\n", etd.rxmac.bcast_cntr);
+        printf ("\t%d\t: Rx ctrl frame cntr\n", etd.rxmac.ctrlframe_cntr);
+        printf ("\t%d\t: Rx pause frame pkt cntr\n", etd.rxmac.pausefr_cntr);
+        printf ("\t%d\t: Rx unknown opcode cntr\n", etd.rxmac.unknownop_cntr);
+        printf ("\t%d\t: Rx alignment err cntr\n", etd.rxmac.allignerr_cntr);
+        printf ("\t%d\t: Rx frame length err cntr\n", etd.rxmac.framelerr_cntr);
+        printf ("\t%d\t: Rx code err cntr\n", etd.rxmac.codeerr_cntr);
+        printf ("\t%d\t: Rx carrier sense err cntr\n", etd.rxmac.carriersenseerr_cntr);
+        printf ("\t%d\t: Rx under sz pkt cntr\n", etd.rxmac.underszpkt_cntr);
+        printf ("\t%d\t: Rx over sz pkt cntr\n", etd.rxmac.ozpkt_cntr);
+        printf ("\t%d\t: Rx fragment cntr\n", etd.rxmac.fragment_cntr);
+        printf ("\t%d\t: Rx jabber cntr\n", etd.rxmac.jabber_cntr);
+        printf ("\t%d\t: RX drop cntr\n",etd.rxmac.rcvdrop_cntr);
+        printf ("\t%u\t: Rx overfl cntr\n",etd.rxmac.rxoverfl);
+
+}
+
+
+
+u_int32_t
+regread(u_int32_t phy_reg,u_int16_t portno)
+{
+
+	etd.phy_reg = phy_reg;
+	etd.cmd     = ATHR_PHY_RD;
+	etd.portnum = portno;
+	if (ioctl(s,ATHR_PHY_CTRL_IOC, &ifr) < 0)
+        	err(1, etd.ad_name);
+    	return etd.val;
+}
+static void athr_en_jumboframe(int value)
+{
+	etd.cmd = ATHR_JUMBO_FRAME;
+	etd.val=value;
+	if (ioctl(s,ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+        	err(1,etd.ad_name);
+}
+static void athr_set_framesize(int sz)
+{
+	etd.cmd = ATHR_FRAME_SIZE_CTL;
+    	etd.val = sz;
+    	if (ioctl(s,ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+        	err(1,etd.ad_name);
+  
+}
+static void athr_commit_acl_rules(void)
+{
+	etd.cmd = ATHR_ACL_COMMIT;
+    	if (ioctl(s,ATHR_HW_ACL_IOC,&ifr) < 0)
+        	 err(1,etd.ad_name);
+  
+}
+static void athr_flush_acl_rules(void)
+{
+	etd.cmd = ATHR_ACL_FLUSH;
+    	if (ioctl(s,ATHR_HW_ACL_IOC,&ifr) < 0)
+        	err(1,etd.ad_name);
+}
+static void athr_flow_link (int portno, int val)
+{
+	etd.cmd = ATHR_FLOW_LINK_EN;
+	etd.val = val;
+	etd.portnum = portno;
+	if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+	       	err(1,etd.ad_name);
+}
+static void athr_txflctrl (int portno, int val)
+{
+	if (portno == 0x3f) {
+		etd.val = val; 
+        	etd.cmd = ATHR_GMAC_TX_FLOW_CTRL; 
+        if (ioctl (s, ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+        	printf("%s ioctl error\n",__func__);
+            
+    	} else { 
+        	etd.cmd		= ATHR_PHY_TXFCTL;
+        	etd.portnum 	= portno;
+		etd.val		= val; 
+        if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+            printf("%s ioctl error\n",__func__);
+              
+    	}
+    
+       
+}
+static void athr_gmac_flow_ctrl(int val)
+{
+	etd.val = val;
+        etd.cmd = ATHR_GMAC_FLOW_CTRL;
+        if (ioctl (s, ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+             printf("%s ioctl error\n",__func__);
+	
+}
+static void athr_phy_flow_ctrl(int val, int portno)
+{
+	etd.val = val;
+        etd.cmd = ATHR_PHY_FLOW_CTRL;
+   	etd.portnum = portno;
+        if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+             printf("%s ioctl error\n",__func__);
+}
+static void athr_rxflctrl (int portno, int val)
+{
+	if (portno == 0x3f) {
+		etd.val = val; 
+        	etd.cmd = ATHR_GMAC_RX_FLOW_CTRL; 
+        	if (ioctl (s, ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+            		printf("%s ioctl error\n",__func__);
+            
+    	} else { 
+        	etd.cmd	    = ATHR_PHY_RXFCTL;
+        	etd.portnum = portno;
+		etd.val	    = val; 
+        if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+            printf("%s ioctl error\n",__func__);
+              
+    }
+    
+       
+}
+static void athr_set_mib(int val)
+{
+	etd.cmd       = ATHR_PHY_MIB;
+        etd.portnum = 0x3f;
+	etd.val       = val;
+	if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+        	err(1, etd.ad_name);
+}
+static void athr_disp_stats(int portno)
+{
+	if (portno == 0x3f) {
+		etd.cmd = ATHR_GMAC_STATS;
+       		if (ioctl (s, ATHR_GMAC_CTRL_IOC, &ifr) < 0){
+           	err(1, etd.ad_name);
+		} else {
+			rx_mac_stats ();
+           		tx_mac_stats ();
+
+	}
+       
+   	} else {
+       		etd.cmd = ATHR_PHY_STATS;
+       		etd.portnum = portno;
+       		if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+           		err(1, etd.ad_name);
+        	else{
+            		rx_stats ();
+            		tx_stats ();
+
+       		}
+   	}
+	
+}
+static void athr_dma_check(int val)
+{
+	etd.cmd = ATHR_GMAC_DMA_CHECK;
+	etd.val = val;
+    	if (ioctl (s, ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+		err(1, etd.ad_name);
+    
+}
+
+static void athr_set_qos(int val)
+{
+	etd.cmd = ATHR_QOS_ETH_SOFT_CLASS;
+	etd.val = val;
+	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+}
+static void athr_set_port_pri(int portno, int val)
+{
+	etd.cmd     = ATHR_QOS_ETH_PORT;
+   	etd.portnum = portno;
+   	etd.val     = val;
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+      
+}
+static void athr_ip_qos (int tos, int val)
+{
+	etd.cmd = ATHR_QOS_ETH_IP;
+   	etd.val = val;
+   	etd.tos = tos;
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+        	err (1, etd.ad_name);
+       
+}
+static void athr_vlan_qos (int vlan_id, int val)
+{
+	etd.cmd    = ATHR_QOS_ETH_VLAN;
+   	etd.val    = val;
+   	etd.vlanid = vlan_id;
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+      
+}
+static void athr_mac_qos(int portno, int val, char *mac_addr)
+{
+	etd.cmd     = ATHR_QOS_ETH_DA;
+   	etd.val     = val;
+   	etd.portnum = portno;
+   	sscanf (mac_addr, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+              &etd.mac_addr[0], &etd.mac_addr[1],
+              &etd.mac_addr[2], &etd.mac_addr[3],
+              &etd.mac_addr[4], &etd.mac_addr[5]);
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+       
+}
+
+static int athr_port_st(int portno)
+{
+        char str[][MAX_SIZ] = {"10Mbps","100Mbps","1000Mbps"};
+
+	etd.cmd     = ATHR_PORT_STATS;
+   	etd.portnum = portno;
+   	if (etd.portnum > 5){
+       		printf ("port usage <0-5>");
+       		return -EINVAL;
+   	}
+   	if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+        printf("\t\t\t____phy%d stats____\n",etd.portnum);
+        printf("Link:\t\t%s\n",etd.phy_st.link ? "alive":"Not alive");
+        printf("Speed:\t\t%s\n",str[etd.phy_st.speed]);
+        printf("Duplex:\t\t%s\n",etd.phy_st.duplex ? "Full duplex":"Half-duplex");
+        printf("Rx flowctrl:\t%s\n",etd.phy_st.rxflctrl ? "Enabled": "Disabled");
+        printf("Tx flowctrl:\t%s\n",etd.phy_st.txflctrl ? "Enabled": "Disabled");
+   	return 0;
+   
+}
+static void athr_process_egress(int portno, int val)
+{
+	etd.cmd =  ATHR_QOS_PORT_ELIMIT;
+	etd.val = val;
+	etd. portnum  = portno;
+	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+		err (1, etd.ad_name);
+       
+}
+static void athr_process_igress(int portno, int val)
+{
+	etd.cmd =  ATHR_QOS_PORT_ILIMIT;
+   	etd.val = val;
+   	etd. portnum  = portno;
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       	     	err (1, etd.ad_name);
+       
+}
+
+
+static void regwrite(u_int32_t phy_reg,u_int32_t val,u_int16_t portno)
+{
+        
+	etd.val     = val;
+	etd.phy_reg = phy_reg;
+        etd.portnum = portno;
+        if(opt_force)  {
+             etd.duplex   = duplex;
+             etd.cmd      = ATHR_PHY_FORCE;
+	    if (ioctl(s,ATHR_PHY_CTRL_IOC, &ifr) < 0)
+		err(1, etd.ad_name);
+            opt_force = 0;
+        }
+        else {
+            etd.cmd = ATHR_PHY_WR;
+	    if (ioctl(s,ATHR_PHY_CTRL_IOC, &ifr) < 0)
+		err(1, etd.ad_name);
+        }
+}
+
+static void usage(void)
+{
+	fprintf(stderr, "usage: %s [-i ifname] [-p portnum] offset[=value]\n", progname);
+	fprintf(stderr, "usage: %s [-f]  -p portnum =10/100/0 [-d duplex]\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-x]\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-c]\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-s value]\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-j 0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--txfctl] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--txfctl] [-i ifname] -v [0|1] -p <portno>\n", progname);
+        fprintf(stderr, "usage: %s [--rxfctl] [-i ifname] -v [0|1]\n",progname);
+        fprintf(stderr, "usage: %s [--rxfctl] [-i ifname] -v [0|1] -p <portno>\n", progname);
+        fprintf(stderr, "usage: %s [--macfl] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--swfl] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--dma] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--f_link] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--mib] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--stats] [-i ifname]\n", progname);
+        fprintf(stderr, "usage: %s [--stats] [-i ifname] -p <portno>\n", progname);
+        fprintf(stderr, "usage: %s [--qos] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--ipqos] [-i ifname] -t <tos> -v <val>\n", progname);
+        fprintf(stderr, "usage: %s [--vqos] [-i ifname] -l <vlanid> -v <val>\n", progname);
+        fprintf(stderr, "usage: %s [--mqos [-i ifname] -v <val> -p <portnum> -m <macaddr>\n", progname);
+        fprintf(stderr, "usage: %s [--p_st] [-i ifname] -p <portno>\n", progname);
+        fprintf(stderr, "usage: %s [--igrl] [-i ifname] -p <portno> -v <val>\n", progname);
+        fprintf(stderr, "usage: %s [--egrl] [-i ifname] -p <portno> -v <val>\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-s value]\n",progname);
+        fprintf(stderr, "usage: %s [-i ifname][-j 0|1]\n",progname);
+        exit(-1);
+}
+
+
+int
+ethreg_main(int argc, char *argv[])
+{
+	const char *ifname = "eth0";
+	int c,portnum = 0x3f,cmd = 0,value = -1;
+        int optionindex = 0;
+        int vlanid = 0;
+        char *mac = NULL;
+        int tos = -1;
+        char *opt = "xfhci:d:s:j:v:t:p:m:l:";
+
+	s = socket(AF_INET, SOCK_DGRAM, 0);
+	if (s < 0)
+		err(1, "socket");
+
+        opt_force = 0;
+	progname = argv[0];
+        
+
+	struct option long_options[] =
+        {
+            { "f_link", no_argument, 0, ATHR_FLOW_LINK_EN},
+            { "txfctl", no_argument, 0, ATHR_PHY_TXFCTL},
+            { "rxfctl", no_argument, 0, ATHR_PHY_RXFCTL},
+            { "stats" , no_argument, 0, ATHR_GMAC_STATS},
+            { "mib"   , no_argument, 0, ATHR_PHY_MIB},
+            { "dma"   , no_argument, 0, ATHR_GMAC_DMA_CHECK},
+            { "qos"   , no_argument, 0, ATHR_QOS_ETH_SOFT_CLASS},
+            { "ppri"  , no_argument, 0, ATHR_QOS_ETH_PORT},
+            { "ipqos" , no_argument, 0, ATHR_QOS_ETH_IP},
+            { "vqos"  , no_argument, 0, ATHR_QOS_ETH_VLAN},
+            { "mqos"  , no_argument, 0, ATHR_QOS_ETH_DA},
+            { "igrl"  , no_argument, 0, ATHR_QOS_PORT_ELIMIT},
+            { "egrl"  , no_argument, 0, ATHR_QOS_PORT_ILIMIT},
+            { "p_st"  , no_argument, 0, ATHR_PORT_STATS},
+            { "macfl" , no_argument, 0, ATHR_GMAC_FLOW_CTRL},
+            { "swfl"  , no_argument, 0, ATHR_PHY_FLOW_CTRL},
+            { 0,0,0,0}
+       	};
+          
+           
+	while ((c = getopt_long(argc, argv,
+                    opt, long_options, &optionindex)) != -1) { 
+	switch (c) {
+        	case ATHR_FLOW_LINK_EN:
+                	cmd = ATHR_FLOW_LINK_EN;
+                        break;
+        	case ATHR_PHY_TXFCTL:
+                        cmd = ATHR_PHY_TXFCTL;
+                        break;
+                case ATHR_PHY_RXFCTL:
+                        cmd = ATHR_PHY_RXFCTL;
+                        break;
+                case ATHR_PHY_MIB:
+                        cmd = ATHR_PHY_MIB;
+                        break;
+                case ATHR_GMAC_STATS:
+                        cmd = ATHR_GMAC_STATS;
+                        break;
+                case ATHR_GMAC_DMA_CHECK:
+                        cmd = ATHR_GMAC_DMA_CHECK;
+                        break;
+                case ATHR_QOS_ETH_SOFT_CLASS:
+                        cmd = ATHR_QOS_ETH_SOFT_CLASS;
+                        break;
+                case ATHR_QOS_ETH_PORT:
+                        cmd = ATHR_QOS_ETH_PORT;
+                        break;
+                case ATHR_QOS_ETH_VLAN:
+                        cmd = ATHR_QOS_ETH_VLAN;
+                        break;
+                case ATHR_QOS_ETH_IP:
+                        cmd = ATHR_QOS_ETH_IP;
+                        break;
+                case ATHR_QOS_ETH_DA:
+                        cmd = ATHR_QOS_ETH_DA;
+                        break; 
+                case ATHR_PORT_STATS:
+                        cmd = ATHR_PORT_STATS;
+                        break;
+                case ATHR_QOS_PORT_ELIMIT:
+                        cmd = ATHR_QOS_PORT_ELIMIT;
+                        break;
+                case ATHR_QOS_PORT_ILIMIT:
+                        cmd = ATHR_QOS_PORT_ILIMIT;
+                        break;
+                case ATHR_GMAC_FLOW_CTRL:
+                        cmd = ATHR_GMAC_FLOW_CTRL;
+                        break;
+                case ATHR_PHY_FLOW_CTRL:
+                        cmd = ATHR_PHY_FLOW_CTRL;
+                        break;
+                case 'm':
+                        mac = optarg;
+                        break;
+                case 'v':
+                        value = strtoul(optarg, 0, 0);
+                        break;
+		case 'i':
+			ifname = optarg;
+			break;
+                case 't':
+                        tos = strtoul(optarg, 0, 0);
+                        break;
+		case 'p':
+                        portnum = strtoul(optarg, 0, 0);
+			break;
+		case 'f':
+			opt_force = 1;
+			break;
+                case 'd':
+			duplex = strtoul(optarg, 0, 0);
+			break;
+                case 'c':
+			cmd = ATHR_ACL_COMMIT;
+                        break;
+                case 'x':
+			cmd = ATHR_ACL_FLUSH;
+                        break;
+                case 's':
+                        cmd = ATHR_FRAME_SIZE_CTL;
+                        value = strtoul(optarg, 0, 0);
+                        break;
+		case 'j':
+                        cmd = ATHR_JUMBO_FRAME;
+                        value = strtoul(optarg, 0, 0);
+                        break;
+                case 'l':
+                        vlanid = strtoul (optarg, 0, 0);
+                        break;
+                case 'h':
+                        usage();
+                        break;
+		default:
+			usage();
+			/*NOTREACHED*/
+		}
+
+        }
+
+	argc -= optind;
+	argv += optind;
+	strncpy(etd.ad_name, ifname, sizeof (etd.ad_name));
+        strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+        ifr.ifr_data = (void *) &etd;
+
+        if (cmd == ATHR_ACL_COMMIT) {
+        	athr_commit_acl_rules();
+              	return 0;
+        }
+        else if (cmd == ATHR_ACL_FLUSH) {
+              	athr_flush_acl_rules();
+              	return 0;
+        }
+        else if(cmd == ATHR_FRAME_SIZE_CTL) {
+        	if (value == -1) {
+                	printf ("usage:ethreg -i <if_name> -s <val>\n");
+                  	return -1; 
+              	} else {
+	          	athr_set_framesize(value);
+              	}
+              	return 0;
+        }
+        else if (cmd == ATHR_JUMBO_FRAME) {
+        	if (value == -1) {
+                	printf ("usage: ethreg -i <if_name> -j <0|1>\n");
+                	return -1;
+             	} else {
+	        	athr_en_jumboframe(value);
+             	}
+             return 0;
+	}
+        else if (cmd == ATHR_FLOW_LINK_EN) {
+        	if (value == -1 || portnum == 0x3f) {
+                	printf ("usage: ethreg --f_link -i <ifname> -p <portnum> -v 1\n");
+                 	return -1;
+             	} else {
+                	athr_flow_link(portnum, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_PHY_RXFCTL) {
+        	if (value == -1) {
+                	printf ("usage: ethreg --rxfctl -i <ifname> -p <portnum> -v [0|1]\n");
+                	printf ("usage: ethreg --rxfctl -i <ifname> -v [0|1]\n");
+                 	return -1;
+             	} else {
+                 	athr_rxflctrl(portnum, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_PHY_TXFCTL) {
+        	if (value == -1) {
+                	printf ("usage: ethreg --txfctl -i <ifname> -p <portnum> -v [0|1]\n");
+                	printf ("usage: ethreg --txfctl -i <ifname> -v [0|1]\n");
+                 	return -1;
+             	} else {
+                	 athr_txflctrl(portnum, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_PHY_MIB) {
+        	if (value == -1) {
+        		printf ("usage: ethreg --mib -i <ifname> -v 1\n");
+		 	return -1;
+             	} else {
+                	athr_set_mib(value);
+             	}
+             	return 0;
+        }
+	else if (cmd == ATHR_GMAC_STATS) {
+        	athr_disp_stats(portnum);
+	     	return 0;
+	}
+	else if (cmd == ATHR_GMAC_DMA_CHECK) {
+                if (value == -1) {
+                	printf ("usage: ethreg --dma -i <ifname> -v [0|1]\n");
+                        return -1;
+                } else {
+        		athr_dma_check(value);
+                }
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_ETH_SOFT_CLASS) {
+        	if (value == -1) {
+                	printf ("usage: ethreg --qos -i <ifname> -v [0|1]\n");
+                	return -1;
+             	} else {
+                	athr_set_qos(value);
+             	}
+             	return 0;
+               
+        }
+        else if (cmd == ATHR_QOS_ETH_PORT) {
+        	if (value == -1) {
+                	printf("usage: ethreg --ppri -i <ifname> -p <portno> -v <val>\n");
+                	return -1;
+             	} else {
+                 	athr_set_port_pri(portnum, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_ETH_IP) {
+        	if (tos == -1 || value == -1) {
+                 	printf ("usage: ethreg --ipqos -i <ifname> -v <val> -t <tos>\n");
+                 	return -1;
+             	} else {
+                 	athr_ip_qos(tos, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_ETH_VLAN) {
+        	if (value == -1 || vlanid == -1) {
+                	printf ("usage: ethreg --vqos -i <ifname> -v <val> -l <vlanid>\n");
+                 	return -1;
+             	} else {
+                	athr_vlan_qos(vlanid, value);
+                 
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_ETH_DA) {
+        	if (portnum == 0x3f || value == -1 || mac == NULL) {
+                	printf ("usage: ethreg --mqos -i <ifname> -v <val> -p <portnum> -m <macaddr>\n");
+                 	return -1;
+             	} else {
+                	athr_mac_qos(portnum, value, mac);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_PORT_STATS) {
+        	if (portnum == 0x3f) {
+                	printf ("usage: ethreg --port_st -i <ifname> -p <portno>\n");
+			return -1;
+             	} else {
+                	athr_port_st(portnum);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_PORT_ELIMIT) {
+        	if (portnum == 0x3f || value == -1 ) {
+                	printf("usage: ethreg --egrl -i <ifname> -p <portnum> -v <val>\n");
+                 	return -1;
+             	} else {
+                	athr_process_egress(portnum, value);
+             	}
+             	return 0;
+       	}
+       	else if (cmd == ATHR_QOS_PORT_ILIMIT) {
+       		if (portnum == 0x3f || value == -1 ) {
+                	printf("usage: ethreg --igrl -i <ifname> -p <portnum> -v <val>\n");
+                 	return -1;
+             	} else {
+                 	athr_process_igress(portnum, value);
+             	}
+             	return 0;
+	}
+        else if (cmd == ATHR_GMAC_FLOW_CTRL){
+        	athr_gmac_flow_ctrl(value);
+                return 0;
+        }
+        else if (cmd == ATHR_PHY_FLOW_CTRL){
+        	athr_phy_flow_ctrl(value, portnum);
+                return 0;
+        }
+
+	for (; argc > 0; argc--, argv++) {
+		u_int32_t   off;
+                u_int32_t  val, oval;
+                char *cp;
+
+                cp = strchr(argv[0], '=');
+
+                if (cp != NULL)
+                        *cp = '\0';
+
+                off = (u_int) strtoul(argv[0], 0, 0);
+
+                if (off == 0 && errno == EINVAL)
+               		errx(1, "%s: invalid reg offset %s",
+                              progname, argv[0]);
+
+                if (cp == NULL) {
+                	val = regread(off,portnum);
+                    	printf("Read Reg: 0x%08x = 0x%08x\n",off, val);
+                    	return 0;
+                } else {
+                	val = (u_int32_t) strtoul(cp+1, 0, 0);
+                    	if (val == 0 && errno == EINVAL) {
+                        	errx(1, "%s: invalid reg value %s",
+                                        progname, cp+1);
+                    	}
+                     	else {
+                        	oval = regread(off,portnum);
+				if(opt_force == 0) {
+                            		printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", off, oval, val);
+
+                        	} else if(opt_force == 1 && portnum == 0x3f) {
+                            		fprintf(stderr, "usage: %s [-f]  -p portnum =10/100/0 [-d duplex]\n", progname);
+                            		return -1;
+                        	}
+                            	regwrite(off,val,portnum);
+                     	}	
+                }
+        }
+        return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/miscutils/factoryreset.c apps_1.2/busybox-1.01/miscutils/factoryreset.c
--- apps/busybox-1.01/miscutils/factoryreset.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/miscutils/factoryreset.c	2014-05-30 03:43:44.052943190 -0700
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <sys/reboot.h>
+#include "busybox.h"
+
+/* Ioctl used inside the driver */
+#define ATH_FACTORY_RESET               0x89ABCDEF
+
+static volatile int fd = 0;
+
+static void siginthnd(int signo)
+{
+    printf("signal caught. closing fr device\n");
+    if (fd != 0)
+        close(fd);
+    exit(0);
+}
+
+extern int factoryreset_main(int argc, char **argv)
+{
+	if (daemon(0, 1) < 0)
+		bb_perror_msg_and_die("Failed forking factory reset daemon");
+
+	signal(SIGHUP, siginthnd);
+	signal(SIGINT, siginthnd);
+
+	fd = bb_xopen(argv[argc - 1], O_WRONLY);
+
+        if (fd < 0)
+		bb_perror_msg_and_die("Failed to open factory reset device");
+
+        ioctl(fd, ATH_FACTORY_RESET, 0);
+
+	close(fd);
+
+        printf("\nRestoring the factory default configuration ....\n");
+        fflush(stdout);
+
+        /* Restore the factory default settings */
+        system("cfg -x");
+        sleep(1);
+
+        system("apdown");
+
+        reboot(RB_AUTOBOOT);
+	return EXIT_SUCCESS;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/miscutils/Makefile.in apps_1.2/busybox-1.01/miscutils/Makefile.in
--- apps/busybox-1.01/miscutils/Makefile.in	2014-05-30 03:41:18.091246464 -0700
+++ apps_1.2/busybox-1.01/miscutils/Makefile.in	2014-05-30 03:43:44.052943190 -0700
@@ -1,6 +1,7 @@
 # Makefile for busybox
 #
 # Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -37,6 +38,10 @@
 MISCUTILS-$(CONFIG_STRINGS)		+= strings.o
 MISCUTILS-$(CONFIG_TIME)		+= time.o
 MISCUTILS-$(CONFIG_WATCHDOG)		+= watchdog.o
+MISCUTILS-$(CONFIG_FACTORYRESET)	+= factoryreset.o
+MISCUTILS-$(CONFIG_ETHREG)	        += ethreg.o
+MISCUTILS-$(CONFIG_MDMM)	        += mdmm.o
+MISCUTILS-$(CONFIG_ETHDEBUG)        += ethdebug.o
 
 libraries-y+=$(MISCUTILS_DIR)$(MISCUTILS_AR)
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/miscutils/mdmm.c apps_1.2/busybox-1.01/miscutils/mdmm.c
--- apps/busybox-1.01/miscutils/mdmm.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.01/miscutils/mdmm.c	2014-05-30 03:43:44.052943190 -0700
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+/*
+ * Simple Atheros-specific tool to inspect and monitor network traffic
+ * statistics.
+ *	athstats [-i interface] [interval]
+ * (default interface is ath0).  If interval is specified a rolling output
+ * a la netstat -i is displayed every interval seconds.
+ *
+ * To build: cc -o athstats athstats.c -lkvm
+ */
+#include <sys/types.h>
+#include <sys/file.h>
+#include <sys/ioctl.h>
+//#include <sys/sockio.h>
+#include <sys/socket.h>
+#include <net/if.h>
+//#include <net/if_media.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/signal.h>
+#include <string.h>
+#include <limits.h>
+#include <err.h>
+#include <errno.h>
+#include <unistd.h>
+
+void usage(void);
+int opendev(int);
+int md_main(int, char *[]);
+int mm_main(int, char *[]);
+int main(int, char *[]);
+
+void
+usage(void)
+{
+	fprintf(stderr, "Usage:\n"
+			"md address [count]\n"
+			"mm address value\n");
+	exit(1);
+}
+
+int
+opendev(int mode)
+{
+	int		fd;
+	extern int	errno;
+#define AR_MEM_DEV_NAME	"/dev/armem"
+	fd = open(AR_MEM_DEV_NAME, mode);
+
+	if (fd < 0) {
+		perror("open: " AR_MEM_DEV_NAME);
+		fprintf(stderr, "Create using: mknod " AR_MEM_DEV_NAME " c 1 13\n");
+	}
+
+	return fd;
+}
+
+int
+closedev(int fd)
+{
+	return close(fd);
+}
+
+int
+md_main(int argc, char *argv[])
+{
+	int		i, fd, count;
+	unsigned	val;
+	loff_t		addr;
+	off_t	 	ret;
+
+	if (argc < 2 || argc > 3) {
+		usage();
+		return EINVAL;
+	}
+
+	if ((fd = opendev(O_RDONLY)) < 0) {
+		return fd;
+	}
+
+	if (argc == 2) {
+		count = 1;
+	} else {
+		count = atoi(argv[2]);
+	}
+
+	addr = strtoul(argv[1], NULL, 16) & 0xffffffff;
+
+	lseek(fd, addr, SEEK_SET);
+	for (i = 0; i < count; i++, addr += sizeof(val)) {
+		if (read(fd, &val, sizeof(val)) != sizeof(val)) {
+			perror("read");
+			closedev(fd);
+			return -1;
+		}
+                printf("%08llx : 0x%08x %12d\n", addr, val, val);
+	}
+
+	closedev(fd);
+	return 0;
+}
+
+int
+mm_main(int argc, char *argv[])
+{
+	int		fd;
+	unsigned	new;
+	loff_t		addr;
+
+	if (argc != 3) {
+		usage();
+		return EINVAL;
+	}
+
+	if ((fd = opendev(O_RDWR)) < 0) {
+		return fd;
+	}
+
+	addr = strtoul(argv[1], NULL, 16) & 0xffffffff;
+	new = strtoul(argv[2], NULL, 16);
+
+	lseek(fd, addr, SEEK_SET);
+	if (write(fd, &new, sizeof(new)) != sizeof(new)) {
+		perror("write");
+		closedev(fd);
+		return -1;
+	}
+
+	closedev(fd);
+	return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/miscutils/watchdog.c apps_1.2/busybox-1.01/miscutils/watchdog.c
--- apps/busybox-1.01/miscutils/watchdog.c	2014-05-30 03:41:18.095246511 -0700
+++ apps_1.2/busybox-1.01/miscutils/watchdog.c	2014-05-30 03:43:44.052943190 -0700
@@ -3,6 +3,7 @@
  * Mini watchdog implementation for busybox
  *
  * Copyright (C) 2003  Paul Mundt <lethal@linux-sh.org>
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -63,6 +64,8 @@
 
 	signal(SIGHUP, watchdog_shutdown);
 	signal(SIGINT, watchdog_shutdown);
+	signal(SIGTERM, watchdog_shutdown);
+	signal(SIGKILL, watchdog_shutdown);
 
 	fd = bb_xopen(argv[argc - 1], O_WRONLY);
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/networking/brctl.c apps_1.2/busybox-1.01/networking/brctl.c
--- apps/busybox-1.01/networking/brctl.c	2014-05-30 03:41:18.107246650 -0700
+++ apps_1.2/busybox-1.01/networking/brctl.c	2014-05-30 03:43:44.036943004 -0700
@@ -41,6 +41,11 @@
 {
 	char ifname[IFNAMSIZ];
 	struct port *p;
+#ifdef CONFIG_ATH_WRAP
+	struct port_info *pi;
+
+	pi = &p->info;
+#endif
 
 	p = br->firstport;
 	if (p != NULL) {
@@ -193,6 +198,9 @@
 {
 	int err;
 	int ifindex;
+#ifdef CONFIG_ATH_WRAP
+	int ptype=0;
+#endif
 
 	ifindex = if_nametoindex(ifname);
 	if (!ifindex) {
@@ -200,8 +208,16 @@
 		return;
 	}
 
+#ifdef CONFIG_ATH_WRAP
+	if(arg1)
+		sscanf(arg1, "%i", &ptype);
+
+	if ((err = br_add_interface(br, ifindex,ptype)) == 0)
+		return;
+#else
 	if ((err = br_add_interface(br, ifindex)) == 0)
 		return;
+#endif
 
 	switch (err) {
 	case EBUSY:
@@ -491,8 +507,12 @@
 
 		argindex++;
 	}
-
-	if (argc - argindex != cmd->num_string_arguments) {
+#ifdef CONFIG_ATH_WRAP
+	if (argc - argindex < cmd->num_string_arguments) 
+#else
+	if (argc - argindex != cmd->num_string_arguments) 
+#endif
+    {
 		fprintf(stderr, "incorrect number of arguments for command\n");
 		return 1;
 	}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/networking/Config.in apps_1.2/busybox-1.01/networking/Config.in
--- apps/busybox-1.01/networking/Config.in	2014-05-30 03:41:18.107246650 -0700
+++ apps_1.2/busybox-1.01/networking/Config.in	2014-05-30 03:43:44.036943004 -0700
@@ -1,4 +1,22 @@
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+#
+
+#
 # For a description of the syntax of this configuration file,
 # see scripts/kbuild/config-language.txt.
 #
@@ -133,6 +151,20 @@
 	help
 	  Ifconfig is used to configure the kernel-resident network interfaces.
 
+config CONFIG_FEATURE_IFCONFIG_S26QOS
+        bool "  Enable s26 qos commands in ifconfig "
+        default n
+        depends on CONFIG_IFCONFIG
+        help
+          Use ifconfig to control s26 qos of AR7240 S26 switch.
+
+config CONFIG_FEATURE_IFCONFIG_VLAN_IGMP
+	bool "  Enable vlan and igmp commands in ifconfig "
+	default n
+	depends on CONFIG_IFCONFIG
+	help
+	  Use ifconfig to control vlan and igmp of AR7240 S26 switch.
+
 config CONFIG_FEATURE_IFCONFIG_STATUS
 	bool "  Enable status reporting output (+7k)"
 	default y
@@ -546,6 +578,13 @@
 	  Selecting this will make telnetd only callable from inetd,
 	  removing the standalone support.
 
+config CONFIG_FEATURE_TELNETD_NO_DAEMONIZE
+	bool "  Disable daemonized feature"
+	default n
+	depends on CONFIG_TELNETD
+	help
+	  Selecting this will make telnetd run in foreground (no daemonize).
+
 config CONFIG_TFTP
 	bool "tftp"
 	default n
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/networking/ifconfig.c apps_1.2/busybox-1.01/networking/ifconfig.c
--- apps/busybox-1.01/networking/ifconfig.c	2014-05-30 03:41:18.107246650 -0700
+++ apps_1.2/busybox-1.01/networking/ifconfig.c	2014-05-30 03:43:44.036943004 -0700
@@ -1,3 +1,5 @@
+/** Copyright (c) 2013 Qualcomm Atheros, Inc. */
+
 /* ifconfig
  *
  * Similar to the standard Unix ifconfig, but with only the necessary
@@ -153,6 +155,61 @@
 /*
  * Define the bit masks signifying which operations to perform for each arg.
  */
+#ifdef CONFIG_FEATURE_IFCONFIG_VLAN_IGMP
+#define ARG_PORT         (A_ARG_REQ | A_MAP_ULONG)
+
+typedef struct {
+    u_int8_t uc[6];
+} mac_addr_t;
+
+struct arl_struct {
+	mac_addr_t mac_addr;
+	int port_map;
+	int sa_drop; 
+};
+
+#endif
+
+#ifdef CONFIG_FEATURE_IFCONFIG_S26QOS
+#define ETH_SOFT_CLASS   (SIOCDEVPRIVATE | 0x4)
+#define ETH_PORT_QOS     (SIOCDEVPRIVATE | 0x5)
+#define ETH_VLAN_QOS     (SIOCDEVPRIVATE | 0x6)
+#define ETH_DA_QOS       (SIOCDEVPRIVATE | 0x7)
+#define ETH_IP_QOS		 (SIOCDEVPRIVATE | 0x8)
+#define ETH_PORT_ILIMIT  (SIOCDEVPRIVATE | 0x9)
+#define ETH_PORT_ELIMIT  (SIOCDEVPRIVATE | 0xa)
+#define ETH_PORT_EQLIMIT (SIOCDEVPRIVATE | 0xb)
+struct qosoption {
+	const char *name;
+	const unsigned int selector;
+	const unsigned int paranum;
+};
+
+static const struct qosoption qosOptArray[] = {
+	{"enable", ETH_SOFT_CLASS, 1},
+	{"disable", ETH_SOFT_CLASS, 1},
+	{"portqos", ETH_PORT_QOS, 3},
+	{"vlanqos", ETH_VLAN_QOS, 3},
+	{"ipqos", ETH_IP_QOS, 1},
+    {"macqos", ETH_DA_QOS, 4},
+    {"portin", ETH_PORT_ILIMIT, 3},
+    {"portout", ETH_PORT_ELIMIT, 3},
+    {"portqout",ETH_PORT_EQLIMIT, 4},
+	{NULL, 0}
+};
+#endif
+struct eth_cfg_params {
+    uint16_t cmd;
+    char    ad_name[IFNAMSIZ];      /* if name, e.g. "eth0" */
+	uint16_t vlanid;
+    uint16_t portnum;           /* pack to fit, yech */
+    uint32_t phy_reg;
+	uint32_t tos;
+    uint32_t val;
+    uint8_t duplex;
+    uint8_t  mac_addr[6];
+};
+
 
 #define ARG_METRIC       (A_ARG_REQ /*| A_CAST_INT*/)
 #define ARG_MTU          (A_ARG_REQ /*| A_CAST_INT*/)
@@ -222,7 +279,25 @@
 	{"SIOCSIFADDR",    SIOCSIFADDR,    ifreq_offsetof(ifr_addr)}, /* IPv6 version ignores the offset */
 	{"SIOCDIFADDR",    SIOCDIFADDR,    ifreq_offsetof(ifr_addr)}, /* IPv6 version ignores the offset */
 #endif
+#ifdef CONFIG_FEATURE_IFCONFIG_S26QOS
+	{"S26_QOS_CTL",    (SIOCDEVPRIVATE|0x9),    ifreq_offsetof(ifr_data)},
+#endif
+#ifdef CONFIG_FEATURE_IFCONFIG_VLAN_IGMP
+	{"S26_VLAN_ADDPORTS",    (SIOCDEVPRIVATE|0x4),    ifreq_offsetof(ifr_metric)},
+	{"S26_VLAN_DELPORTS",    (SIOCDEVPRIVATE|0x5),    ifreq_offsetof(ifr_metric)},
+	{"S26_VLAN_SETTAGMODE",    (SIOCDEVPRIVATE|0x6),    ifreq_offsetof(ifr_metric)},
+	{"S26_VLAN_SETDEFAULTID",    (SIOCDEVPRIVATE|0x7),    ifreq_offsetof(ifr_metric)},
+	{"S26_IGMP_ON_OFF",     (SIOCDEVPRIVATE|0x8),    ifreq_offsetof(ifr_data)},
+	{"S26_LINK_GETSTAT",    (SIOCDEVPRIVATE|0xA),    ifreq_offsetof(ifr_data)},
+	{"S26_VLAN_ENABLE",    (SIOCDEVPRIVATE|0xB),    ifreq_offsetof(ifr_data)},
+	{"S26_VLAN_DISABLE",    (SIOCDEVPRIVATE|0xC),    ifreq_offsetof(ifr_data)},
+	{"S26_ARL_ADD",    (SIOCDEVPRIVATE|0xD),    ifreq_offsetof(ifr_data)},
+	{"S26_ARL_DEL",    (SIOCDEVPRIVATE|0xE),    ifreq_offsetof(ifr_data)},
+	{"S26_MCAST_CLR",    (SIOCDEVPRIVATE|0xF),    ifreq_offsetof(ifr_data)},
+	{"S26_PACKET_FLAG",    (SIOCDEVPRIVATE|0x0),    ifreq_offsetof(ifr_data)},
+#endif
 	{"SIOCSIFADDR",    SIOCSIFADDR,    ifreq_offsetof(ifr_addr)},
+
 };
 
 static const struct options OptArray[] = {
@@ -251,6 +326,23 @@
 	{"add",         N_ARG,         ARG_ADD_DEL,     0},
 	{"del",         N_ARG,         ARG_ADD_DEL,     0},
 #endif
+#ifdef CONFIG_FEATURE_IFCONFIG_S26QOS
+	{"s26qos",     N_ARG,         0,            0},
+#endif
+#ifdef CONFIG_FEATURE_IFCONFIG_VLAN_IGMP
+	{"addports",     N_ARG,         ARG_PORT,               0},
+	{"delports",     N_ARG,         ARG_PORT,               0},
+	{"setmode",     N_ARG,         ARG_PORT,               0},
+	{"setid",     N_ARG,         ARG_PORT,               0},
+	{"igmpon",      N_ARG,         0,           0},
+	{"getstat",     N_ARG,         0,            0},
+	{"startvlan",     N_ARG,         0,            0},
+	{"stopvlan",     N_ARG,         0,            0},
+	{"addarl",     N_ARG,         0,            0},
+	{"delarl",     N_ARG,         0,            0},
+	{"setcast",     N_ARG,         0,            0},
+	{"setpacketflag", N_ARG,         0,            0},
+#endif
 	{"arp",         N_CLR | M_SET, 0,               IFF_NOARP},
 	{"trailers",    N_CLR | M_SET, 0,               IFF_NOTRAILERS},
 	{"promisc",     N_SET | M_CLR, 0,               IFF_PROMISC},
@@ -367,12 +459,305 @@
 		goto HOSTNAME;
 
 	  FOUND_ARG:
-		if (mask & ARG_MASK) {
+		if (mask & ARG_MASK) 
+			{
 			mask = op->arg_flags;
 			a1op = Arg1Opt + (op - OptArray);
 			if (mask & A_NETMASK & did_flags) {
 				bb_show_usage();
 			}
+#ifdef CONFIG_FEATURE_IFCONFIG_VLAN_IGMP
+			struct arl_struct arl;
+			// Note: the argv has been added by 2; the argc has been substrated by one.
+			if(!strcmp("igmpon",op->name)||!strcmp("igmpoff",op->name))
+			{
+				if(argc!=4) goto VLAN_ERR;
+				unsigned int i = strtoul(argv[1], NULL, 0);
+				unsigned int j = strtoul(argv[2], NULL, 0);
+				ifr.ifr_ifru.ifru_ivalue = i&0x1f;
+				if(j != 0)
+					j = 1;
+				ifr.ifr_ifru.ifru_ivalue |= j << 7;
+
+				//printf("[%s] vlanid %x.\n",op->name,ifr.ifr_ifru.ifru_ivalue);
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			// bit0-->port0,bit1-->port1,so it can be added or deleted many ports at the same time.
+			if(!strcmp("addports",op->name)||!strcmp("delports",op->name)||!strcmp("setid",op->name))
+			{
+				if(argc!=4) goto VLAN_ERR;
+				unsigned int data1 = strtoul(argv[1], NULL, 0);
+				unsigned int data2 = strtoul(argv[2], NULL, 0);
+
+				data1 &=0xfff; //vlan-id
+				data2 &=0x1f;  //ports
+
+				ifr.ifr_ifru.ifru_ivalue = (data1 << 16) | (data2);
+
+				//printf("[%s] vlanid-ports %x.\n",op->name,ifr.ifr_ifru.ifru_ivalue);
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			if(!strcmp("startvlan",op->name)||!strcmp("stopvlan",op->name))
+			{
+				if(argc!=2) goto VLAN_ERR;
+
+				//No arguments needed.
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			if(!strcmp("setmode",op->name))
+			{
+
+				if(argc!=4) goto VLAN_ERR;
+				unsigned int data1 = strtoul(argv[1], NULL, 0);
+				unsigned int data2 = strtoul(argv[2], NULL, 0);
+
+				data1 &=0xf;   //mode:0-2 (0->unmodified,1->untagged,2->tagged)
+				data2 &=0x7;   //port:0-5 (cpu:port0)
+
+				ifr.ifr_ifru.ifru_ivalue = (data1 << 16) | (data2);
+
+				//printf("[%s] vlanid-ports %x.\n",op->name,ifr.ifr_ifru.ifru_ivalue);
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			if(!strcmp("getstat",op->name))
+			{
+				if(argc!=3) goto VLAN_ERR;
+				unsigned int data1 = strtoul(argv[1], NULL, 0);
+
+				data1 &=0x7;  //port: 1-5
+				
+				ifr.ifr_ifru.ifru_ivalue = data1;
+
+				//printf("[%s] port: %x.\n",op->name,ifr.ifr_ifru.ifru_ivalue);
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				printf("phy port:%d--status %d.\n",data1,ifr.ifr_ifru.ifru_ivalue);//1--->up,0---->down
+				return 0;
+
+			}
+
+			if(!strcmp("setcast",op->name))
+			{
+				if(argc!=3) goto VLAN_ERR;
+				unsigned int data1 = strtoul(argv[1], NULL, 0);
+
+				data1 &=0x7;  //port: 1-5
+				
+				ifr.ifr_ifru.ifru_ivalue = data1;
+
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+
+				//1--->enable,0---->disable
+				printf("Enable or disable unknow multicast packets over vlans %d.\n",data1);
+				return 0;
+
+			}
+
+			if(!strcmp("addarl",op->name))
+			{
+
+				if(argc!=5) goto VLAN_ERR;
+
+				safe_strncpy(host, argv[1], (sizeof host));
+
+				if (in_ether(host, &sa)) {
+					bb_error_msg("invalid hw-addr %s", host);
+					++goterr;
+					continue;
+				}
+
+				memcpy(&arl.mac_addr,&sa.sa_data,6);
+				arl.port_map = strtoul(argv[2], NULL, 0);
+				arl.sa_drop = strtoul(argv[3], NULL, 0);
+
+
+				memcpy(&ifr.ifr_ifru.ifru_mtu,&arl,sizeof(arl));
+
+				//printf("[%s] vlanid-ports %x.\n",op->name,ifr.ifr_ifru.ifru_ivalue);
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			if(!strcmp("delarl",op->name))
+			{
+
+				if(argc!=3) goto VLAN_ERR;
+
+				safe_strncpy(host, argv[1], (sizeof host));
+
+				if (in_ether(host, &sa)) {
+					bb_error_msg("invalid hw-addr %s", host);
+					++goterr;
+					continue;
+				}
+
+				memcpy(&arl.mac_addr,&sa.sa_data,6);
+				memcpy(&ifr.ifr_ifru.ifru_mtu,&arl,sizeof(arl));
+
+				//printf("[%s] vlanid-ports %x.\n",op->name,ifr.ifr_ifru.ifru_ivalue);
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+#endif
+#ifdef CONFIG_FEATURE_IFCONFIG_S26QOS
+			if(!strcmp("s26qos",op->name))
+			{
+				if (ioctl(sockfd, SIOCGIFFLAGS, &ifr) < 0) {
+					printf("ioctl sockfd error.\n");
+					return 0;
+				}
+				if((ifr.ifr_flags&IFF_UP) == 0){
+					printf("Please up the %s first.\n", ifr.ifr_name);
+					return 0;
+				}
+				--argc;
+				if(argc < 2) goto QOS_ERR;
+				const struct qosoption *qosop;
+				unsigned int data0, data1;
+				struct eth_cfg_params qos_para;
+				++argv;
+				--argc;
+		        for (qosop = qosOptArray; qosop->name; qosop++) {   /* Find table entry. */
+        		    if (strcmp(*argv, qosop->name) == 0) { /* If name matches... */
+           				break; 
+					}
+       			 }
+				if((qosop->name == NULL) || ((argc != qosop->paranum)&&(qosop->selector != ETH_IP_QOS)))  
+					goto QOS_ERR;
+				memset((unsigned char *)&qos_para, 0x0, sizeof(struct eth_cfg_params));
+				switch(qosop->selector){
+					case ETH_SOFT_CLASS:
+						if (strcmp("enable", qosop->name) == 0)
+							qos_para.val = 1;
+						else
+							qos_para.val = 0;
+						break;
+					case ETH_PORT_QOS:
+						qos_para.portnum = strtoul(argv[1], NULL, 0);
+						qos_para.val = strtoul(argv[2], NULL, 0);
+						break;
+					case ETH_VLAN_QOS:
+						qos_para.vlanid = strtoul(argv[1], NULL, 0);
+						qos_para.val = strtoul(argv[2], NULL, 0);
+						break;
+					case ETH_IP_QOS:
+						if(argc == 3){
+							qos_para.tos = strtoul(argv[1], NULL, 16);
+							qos_para.val = strtoul(argv[2], NULL, 0);
+						}
+						break;
+					case ETH_DA_QOS:
+						{
+							int i,j,k;
+							char tmp[3];
+							tmp[2] = '\0';
+							k = 0;
+							for(i=0; i<6; i++){
+								for(j=0; j<2; j++)
+									tmp[j]=argv[1][k++];
+								qos_para.mac_addr[i] = strtoul(tmp, NULL, 16);
+								k++;
+							}
+				//			printf("%x:%x:%x:%x:%x:%x\n", qos_para.mac_addr[0],qos_para.mac_addr[1],
+				//				qos_para.mac_addr[2],qos_para.mac_addr[3],qos_para.mac_addr[4],qos_para.mac_addr[5]);
+							qos_para.val = strtoul(argv[2], NULL, 0);
+							qos_para.portnum=strtoul(argv[3],NULL,0);
+						}
+						break;
+                    case ETH_PORT_ILIMIT:
+                    case ETH_PORT_ELIMIT:
+                        {
+                            qos_para.portnum = strtoul(argv[1], NULL, 0);
+                            qos_para.val = strtoul(argv[2], NULL, 16);
+                        }
+                        break;
+                    case ETH_PORT_EQLIMIT:
+                        {
+                            qos_para.portnum = strtoul(argv[1], NULL, 0);
+                            qos_para.phy_reg = strtoul(argv[2], NULL, 0);
+                            qos_para.val = strtoul(argv[3], NULL, 16);
+                        }
+                        break;
+				}
+
+				strcpy(qos_para.ad_name, ifr.ifr_name);
+				qos_para.cmd = qosop->selector;
+				
+				ifr.ifr_ifru.ifru_data = &qos_para;
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+#endif
+#ifdef CONFIG_FEATURE_IFCONFIG_VLAN_IGMP
+			if(!strcmp("setpacketflag",op->name))
+			{
+				if(argc!=3) goto VLAN_ERR;
+				unsigned int data1 = strtoul(argv[1], NULL, 0);
+
+				ifr.ifr_ifru.ifru_ivalue = data1;
+
+				//printf("[%s] port: %x.\n",op->name,ifr.ifr_ifru.ifru_ivalue);
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				printf("Set  packet ignoring flag in eth1 to %d.\n",data1);//1--->up,0---->down
+				return 0;
+
+			}
+
+#endif
 			if (*++argv == NULL) {
 				if (mask & A_ARG_REQ) {
 					bb_show_usage();
@@ -538,7 +923,6 @@
 			}
 			mask = N_SET;
 		}
-
 		if (ioctl(sockfd, SIOCGIFFLAGS, &ifr) < 0) {
 			perror("SIOCGIFFLAGS");
 			++goterr;
@@ -559,6 +943,16 @@
 	}					/* end of while-loop */
 
 	return goterr;
+#ifdef CONFIG_FEATURE_IFCONFIG_VLAN_IGMP
+VLAN_ERR:
+	bb_show_usage();
+#endif
+#ifdef CONFIG_FEATURE_IFCONFIG_S26QOS
+QOS_ERR:
+	printf("Here we need to show the usage of QosCtl\n");
+#endif
+	return -1;
+
 }
 
 #ifdef CONFIG_FEATURE_IFCONFIG_HW
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/networking/libbridge/libbridge_devif.c apps_1.2/busybox-1.01/networking/libbridge/libbridge_devif.c
--- apps/busybox-1.01/networking/libbridge/libbridge_devif.c	2014-05-30 03:41:18.111246697 -0700
+++ apps_1.2/busybox-1.01/networking/libbridge/libbridge_devif.c	2014-05-30 03:43:44.036943004 -0700
@@ -76,10 +76,20 @@
 	return br_device_ioctl32(br, arg0, arg1, arg2, arg3);
 }
 
+#ifdef CONFIG_ATH_WRAP
+int br_add_interface(struct bridge *br, int ifindex, int ptype)
+#else
 int br_add_interface(struct bridge *br, int ifindex)
+#endif
 {
+#ifdef CONFIG_ATH_WRAP
+    printf("%s ptype %d\n",__func__,ptype);
+	if (br_device_ioctl(br, BRCTL_ADD_IF, ifindex, 0, ptype) < 0)
+		return errno;
+#else
 	if (br_device_ioctl(br, BRCTL_ADD_IF, ifindex, 0, 0) < 0)
 		return errno;
+#endif
 
 	return 0;
 }
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/networking/libbridge/libbridge.h apps_1.2/busybox-1.01/networking/libbridge/libbridge.h
--- apps/busybox-1.01/networking/libbridge/libbridge.h	2014-05-30 03:41:18.111246697 -0700
+++ apps_1.2/busybox-1.01/networking/libbridge/libbridge.h	2014-05-30 03:43:44.036943004 -0700
@@ -80,6 +80,9 @@
 	int path_cost;
 	int designated_cost;
 	int state;
+#ifdef CONFIG_ATH_WRAP
+	int type;
+#endif
 	unsigned top_change_ack:1;
 	unsigned config_pending:1;
 	struct timeval message_age_timer_value;
@@ -106,7 +109,11 @@
 
 int br_add_bridge(char *brname);
 int br_del_bridge(char *brname);
+#ifdef CONFIG_ATH_WRAP
+int br_add_interface(struct bridge *br, int ifindex,int ptype);
+#else
 int br_add_interface(struct bridge *br, int ifindex);
+#endif
 int br_del_interface(struct bridge *br, int ifindex);
 int br_set_bridge_forward_delay(struct bridge *br, struct timeval *tv);
 int br_set_bridge_hello_time(struct bridge *br, struct timeval *tv);
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/networking/telnetd.c apps_1.2/busybox-1.01/networking/telnetd.c
--- apps/busybox-1.01/networking/telnetd.c	2014-05-30 03:41:18.123246836 -0700
+++ apps_1.2/busybox-1.01/networking/telnetd.c	2014-05-30 03:43:44.036943004 -0700
@@ -10,6 +10,8 @@
  * (C) Copyright 2000, Axis Communications AB, LUND, SWEDEN
  ****************************************************************************
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * The telnetd manpage says it all:
  *
  *   Telnetd operates by allocating a pseudo-terminal device (see pty(4))  for
@@ -464,10 +466,10 @@
 	if (listen(master_fd, 1) < 0) {
 		bb_perror_msg_and_die("listen");
 	}
-
+#ifndef CONFIG_FEATURE_TELNETD_NO_DAEMONIZE
 	if (daemon(0, 0) < 0)
 		bb_perror_msg_and_die("daemon");
-
+#endif
 
 	maxfd = master_fd;
 #endif /* CONFIG_FEATURE_TELNETD_INETD */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/networking/tftp.c apps_1.2/busybox-1.01/networking/tftp.c
--- apps/busybox-1.01/networking/tftp.c	2014-05-30 03:41:18.131246928 -0700
+++ apps_1.2/busybox-1.01/networking/tftp.c	2014-05-30 03:43:44.036943004 -0700
@@ -15,6 +15,8 @@
 /*                                                                           */
 /* utftp:  Copyright (C) 1999 Uwe Ohse <uwe@ohse.de>                         */
 /*                                                                           */
+/* Copyright (c) 2013 Qualcomm Atheros, Inc.                                 */
+/*                                                                           */
 /* This program is free software; you can redistribute it and/or modify      */
 /* it under the terms of the GNU General Public License as published by      */
 /* the Free Software Foundation; either version 2 of the License, or         */
@@ -165,6 +167,7 @@
 	/* Can't use RESERVE_CONFIG_BUFFER here since the allocation
 	 * size varies meaning BUFFERS_GO_ON_STACK would fail */
 	char *buf=xmalloc(tftp_bufsize + 4);
+	char *rxbuf=xmalloc(tftp_bufsize + 4);
 
 	tftp_bufsize += 4;
 
@@ -322,7 +325,7 @@
 
 			switch (select(socketfd + 1, &rfds, NULL, NULL, &tv)) {
 			case 1:
-				len = recvfrom(socketfd, buf, tftp_bufsize, 0,
+				len = recvfrom(socketfd, rxbuf, tftp_bufsize, 0,
 						(struct sockaddr *) &from, &fromlen);
 
 				if (len < 0) {
@@ -336,7 +339,16 @@
 					sa.sin_port = from.sin_port;
 				}
 				if (sa.sin_port == from.sin_port) {
-					break;
+					opcode = ntohs(*((unsigned short *) rxbuf));
+					tmp = ntohs(*((unsigned short *) &rxbuf[2]));
+					if (cmd_put && (opcode == TFTP_ACK)) {
+						if  (tmp == (unsigned short)(block_nr - 1)) {
+							break;
+						}
+						else{
+							printf ("%s.. WRONG  ack recd  expected %d recd %d \n", __func__, block_nr -1  , tmp);
+						}
+		 			} else break;
 				}
 
 				/* fall-through for bad packets! */
@@ -357,7 +369,9 @@
 				bb_perror_msg("select");
 				len = -1;
 			}
-
+			 
+			if ((len >= 0) &&(timeout)) 
+				printf("%s.. retransmit %d\n", __func__,  block_nr -1);
 		} while (timeout && (len >= 0));
 
 		if ((finished) || (len < 0)) {
@@ -367,8 +381,8 @@
 		/* process received packet */
 
 
-		opcode = ntohs(*((unsigned short *) buf));
-		tmp = ntohs(*((unsigned short *) &buf[2]));
+		opcode = ntohs(*((unsigned short *) rxbuf));
+		tmp = ntohs(*((unsigned short *) &rxbuf[2]));
 
 #ifdef CONFIG_FEATURE_TFTP_DEBUG
 		fprintf(stderr, "received %d bytes: %04x %04x\n", len, opcode, tmp);
@@ -377,9 +391,9 @@
 		if (opcode == TFTP_ERROR) {
 			char *msg = NULL;
 
-			if (buf[4] != '\0') {
-				msg = &buf[4];
-				buf[tftp_bufsize - 1] = '\0';
+			if (rxbuf[4] != '\0') {
+				msg = &rxbuf[4];
+				rxbuf[tftp_bufsize - 1] = '\0';
 			} else if (tmp < (sizeof(tftp_bb_error_msg)
 					  / sizeof(char *))) {
 
@@ -404,12 +418,12 @@
 
 			         char *res;
 
-				 res = tftp_option_get(&buf[2], len-2,
+				 res = tftp_option_get(&rxbuf[2], len-2,
 						       "blksize");
 
 				 if (res) {
 				         int blksize = atoi(res);
-			
+
 					 if (tftp_blocksize_check(blksize,
 							   tftp_bufsize - 4)) {
 
@@ -443,8 +457,8 @@
 		if (cmd_get && (opcode == TFTP_DATA)) {
 
 			if (tmp == block_nr) {
-			
-				len = bb_full_write(localfd, &buf[4], len - 4);
+
+				len = bb_full_write(localfd, &rxbuf[4], len - 4);
 
 				if (len < 0) {
 					bb_perror_msg("write");
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/networking/udhcp/arpping.c apps_1.2/busybox-1.01/networking/udhcp/arpping.c
--- apps/busybox-1.01/networking/udhcp/arpping.c	2014-05-30 03:41:18.135246975 -0700
+++ apps_1.2/busybox-1.01/networking/udhcp/arpping.c	2014-05-30 03:43:44.036943004 -0700
@@ -1,4 +1,23 @@
 /*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+/*
  * arpping.c
  *
  * Mostly stolen from: dhcpcd - DHCP client daemon
@@ -90,7 +109,7 @@
 		} else if (FD_ISSET(s, &fdset)) {
 			if (recv(s, &arp, sizeof(arp), 0) < 0 ) rv = 0;
 			if (arp.operation == htons(ARPOP_REPLY) &&
-			    bcmp(arp.tHaddr, mac, 6) == 0 &&
+			    memcmp(arp.tHaddr, mac, 6) == 0 &&
 			    *((uint32_t *) arp.sInaddr) == yiaddr) {
 				DEBUG(LOG_INFO, "Valid arp reply receved for this address");
 				rv = 0;
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.01/sysklogd/syslogd.c apps_1.2/busybox-1.01/sysklogd/syslogd.c
--- apps/busybox-1.01/sysklogd/syslogd.c	2014-05-30 03:41:18.199247717 -0700
+++ apps_1.2/busybox-1.01/sysklogd/syslogd.c	2014-05-30 03:43:44.052943190 -0700
@@ -2,6 +2,8 @@
 /*
  * Mini syslogd implementation for busybox
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
  *
  * Copyright (C) 2000 by Karl M. Hegbloom <karlheg@debian.org>
@@ -44,6 +46,7 @@
 #include <sys/types.h>
 #include <sys/un.h>
 #include <sys/param.h>
+#include <string.h>
 
 #include "busybox.h"
 
@@ -52,9 +55,21 @@
 #include <sys/syslog.h>
 #include <sys/uio.h>
 
+const char *log_severities[] = {
+	"Emergency",
+	"Alert",
+	"Critical",
+	"Error",
+	"Warning",
+	"Notice",
+	"Informational",
+	"Debug",
+};
+
 /* Path for the file where all log messages are written */
-#define __LOG_FILE "/var/log/messages"
+#define __LOG_FILE "/var/log/messages.txt"
 
+static int log_level = LOG_INFO;
 /* Path to the unix socket */
 static char lfile[MAXPATHLEN];
 
@@ -62,7 +77,7 @@
 
 #ifdef CONFIG_FEATURE_ROTATE_LOGFILE
 /* max size of message file before being rotated */
-static int logFileSize = 200 * 1024;
+static int logFileSize = 100 * 1024;
 
 /* number of rotated message files */
 static int logFileRotate = 1;
@@ -106,6 +121,8 @@
 #error Please check CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE
 #endif
 
+
+
 #include <sys/ipc.h>
 #include <sys/sem.h>
 #include <sys/shm.h>
@@ -396,10 +413,32 @@
 }
 #endif
 
+static void add_bracket_for_ident(char *string)
+{
+        char *strp = NULL;
+        char temp[1024];
+        char *msg = string;
+
+        if(string == NULL)
+            return;
+
+        if((strp = strsep(&msg, ":")) == NULL)
+            return;
+        strcpy(temp, "[");
+        strcat(temp, strp);
+        strcat(temp, "]");
+        if(msg != NULL)
+            strcat(temp, msg);
+
+        strcpy(string, temp);
+}
+
 static void logMessage(int pri, char *msg)
 {
 	time_t now;
-	char *timestamp;
+    char timestamp[40]; 
+    struct tm *stm = NULL;
+    char messages[1024];
 	static char res[20] = "";
 #ifdef CONFIG_FEATURE_REMOTE_LOG	
 	static char line[MAXLINE + 1];
@@ -418,16 +457,30 @@
 		}
 	}
 
+    if(log_level < LOG_PRI(pri))
+        return;
+    /* modify by Miaoqing Pan */
+    bzero(timestamp, sizeof timestamp);
+    time(&now);
+    stm = localtime(&now);
+    sprintf(timestamp, "%04u-%02u-%02u %02u:%02u:%02u [%s]",
+                stm->tm_year + 1900,
+                stm->tm_mon + 1,
+                stm->tm_mday,
+                stm->tm_hour,
+                stm->tm_min,
+                stm->tm_sec,
+				log_severities[LOG_PRI(pri)]);
+
 	if (strlen(msg) < 16 || msg[3] != ' ' || msg[6] != ' ' ||
 		msg[9] != ':' || msg[12] != ':' || msg[15] != ' ') {
-		time(&now);
-		timestamp = ctime(&now) + 4;
-		timestamp[15] = '\0';
-	} else {
-		timestamp = msg;
-		timestamp[15] = '\0';
-		msg += 16;
-	}
+        strncpy(messages, msg, strlen(msg));
+    } else {
+        strcpy(messages, msg+16);
+    }
+
+    /*add by Miaoqing Pan for adding []*/
+    /*add_bracket_for_ident(messages);*/
 
 	/* todo: supress duplicates */
 
@@ -438,13 +491,13 @@
 			init_RemoteLog();
 		}
 
-		/* if we have a valid socket, send the message */
+		/* if we have a valid socket, send the messages */
 		if (-1 != remotefd) {
 			now = 1;
-			snprintf(line, sizeof(line), "<%d>%s", pri, msg);
+			snprintf(line, sizeof(line), "<%d>%s", pri, messages);
 
 		retry:
-			/* send message to remote logger */
+			/* send messages to remote logger */
 			if(( -1 == sendto(remotefd, line, strlen(line), 0,
 							(struct sockaddr *) &remoteaddr,
 							sizeof(remoteaddr))) && (errno == EINTR)) {
@@ -459,17 +512,19 @@
 	if (local_logging == TRUE)
 #endif
 	{
-		/* now spew out the message to wherever it is supposed to go */
-		if (small)
-			message("%s %s\n", timestamp, msg);
-		else
-			message("%s %s %s %s\n", timestamp, LocalHostName, res, msg);
+		/* now spew out the messages to wherever it is supposed to go */
+        /* modify by Miaoqing Pan*/
+		//if (small)
+		//	message("%s %s\n", timestamp, messages);
+		//else
+		//	message("%s %s %s %s\n", timestamp, LocalHostName, res, messages);
+			message("%s %s\n", timestamp, messages);
 	}
 }
 
 static void quit_signal(int sig)
 {
-	logMessage(LOG_SYSLOG | LOG_INFO, "System log daemon exiting.");
+	logMessage(LOG_SYSLOG | LOG_INFO, "syslogd: System log daemon exiting.");
 	unlink(lfile);
 #ifdef CONFIG_FEATURE_IPC_SYSLOG
 	ipcsyslog_cleanup();
@@ -583,7 +638,7 @@
 	}
 #endif
 
-	logMessage(LOG_SYSLOG | LOG_INFO, "syslogd started: " BB_BANNER);
+	logMessage(LOG_SYSLOG | LOG_INFO, "syslogd: syslogd started: " BB_BANNER);
 
 	for (;;) {
 
@@ -638,9 +693,12 @@
 		case 's':
 			logFileSize = atoi(optarg) * 1024;
 			break;
-		case 'b':
-			logFileRotate = atoi(optarg);
-			if( logFileRotate > 99 ) logFileRotate = 99;
+		case 'b':   /* modify for configuing log_level*/
+			//logFileRotate = atoi(optarg);
+			//if( logFileRotate > 99 ) logFileRotate = 99;
+            log_level = atoi(optarg);
+            if(log_level > LOG_DEBUG)
+                log_level = LOG_DEBUG;
 			break;
 #endif
 #ifdef CONFIG_FEATURE_REMOTE_LOG
@@ -670,6 +728,11 @@
 		case 'S':
 			small = true;
 			break;
+       // case 'l':
+       //     log_level = atoi(optarg);
+       //     if(log_level > LOG_DEBUG)
+       //         log_level = LOG_DEBUG;
+       //     break;
 		default:
 			bb_show_usage();
 		}
@@ -689,7 +752,7 @@
 	}
 
 	umask(0);
-
+#if 0
 	if (doFork == TRUE) {
 #if defined(__uClinux__)
 		vfork_daemon_rexec(0, 1, argc, argv, "-n");
@@ -698,6 +761,7 @@
 			bb_perror_msg_and_die("daemon");
 #endif /* __uClinux__ */
 	}
+#endif    
 	doSyslogd();
 
 	return EXIT_SUCCESS;
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/defconfig-ap135 apps_1.2/busybox-1.15.0/defconfig-ap135
--- apps/busybox-1.15.0/defconfig-ap135	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.15.0/defconfig-ap135	2014-05-30 03:43:44.084943563 -0700
@@ -0,0 +1,914 @@
+#
+# Automatically generated make config: don't edit
+# Busybox version: 1.15.0
+# Mon Dec 27 10:32:44 2010
+#
+CONFIG_HAVE_DOT_CONFIG=y
+
+#
+# Busybox Settings
+#
+
+#
+# General Configuration
+#
+# CONFIG_DESKTOP is not set
+# CONFIG_EXTRA_COMPAT is not set
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_SHOW_USAGE=y
+CONFIG_FEATURE_VERBOSE_USAGE=y
+CONFIG_FEATURE_COMPRESS_USAGE=y
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_ASSUME_UNICODE is not set
+# CONFIG_FEATURE_CHECK_UNICODE_IN_ENV is not set
+# CONFIG_LONG_OPTS is not set
+CONFIG_FEATURE_DEVPTS=y
+# CONFIG_FEATURE_CLEAN_UP is not set
+# CONFIG_FEATURE_PIDFILE is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_FEATURE_SUID_CONFIG_QUIET is not set
+# CONFIG_SELINUX is not set
+# CONFIG_FEATURE_PREFER_APPLETS is not set
+CONFIG_BUSYBOX_EXEC_PATH="/proc/self/exe"
+CONFIG_FEATURE_SYSLOG=y
+# CONFIG_FEATURE_HAVE_RPC is not set
+
+#
+# Build Options
+#
+# CONFIG_STATIC is not set
+# CONFIG_PIE is not set
+# CONFIG_NOMMU is not set
+# CONFIG_BUILD_LIBBUSYBOX is not set
+# CONFIG_FEATURE_INDIVIDUAL is not set
+# CONFIG_FEATURE_SHARED_BUSYBOX is not set
+CONFIG_LFS=y
+CONFIG_CROSS_COMPILER_PREFIX="mips-linux-uclibc-"
+CONFIG_EXTRA_CFLAGS=""
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
+# CONFIG_DEBUG_PESSIMIZE is not set
+# CONFIG_WERROR is not set
+CONFIG_NO_DEBUG_LIB=y
+# CONFIG_DMALLOC is not set
+# CONFIG_EFENCE is not set
+# CONFIG_INCLUDE_SUSv2 is not set
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+CONFIG_INSTALL_APPLET_SYMLINKS=y
+# CONFIG_INSTALL_APPLET_HARDLINKS is not set
+# CONFIG_INSTALL_APPLET_SCRIPT_WRAPPERS is not set
+# CONFIG_INSTALL_APPLET_DONT is not set
+# CONFIG_INSTALL_SH_APPLET_SYMLINK is not set
+# CONFIG_INSTALL_SH_APPLET_HARDLINK is not set
+# CONFIG_INSTALL_SH_APPLET_SCRIPT_WRAPPER is not set
+CONFIG_PREFIX="../../rootfs-${BOARD_TYPE}${BUILD_CONFIG}${BUILD_EXT}.build"
+
+#
+# Busybox Library Tuning
+#
+CONFIG_PASSWORD_MINLEN=6
+CONFIG_MD5_SIZE_VS_SPEED=2
+# CONFIG_FEATURE_FAST_TOP is not set
+# CONFIG_FEATURE_ETC_NETWORKS is not set
+CONFIG_FEATURE_EDITING=y
+CONFIG_FEATURE_EDITING_MAX_LEN=1024
+CONFIG_FEATURE_EDITING_VI=y
+CONFIG_FEATURE_EDITING_HISTORY=15
+CONFIG_FEATURE_EDITING_SAVEHISTORY=y
+CONFIG_FEATURE_TAB_COMPLETION=y
+# CONFIG_FEATURE_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_EDITING_FANCY_PROMPT=y
+# CONFIG_FEATURE_EDITING_ASK_TERMINAL is not set
+CONFIG_FEATURE_NON_POSIX_CP=y
+# CONFIG_FEATURE_VERBOSE_CP_MESSAGE is not set
+CONFIG_FEATURE_COPYBUF_KB=4
+# CONFIG_MONOTONIC_SYSCALL is not set
+# CONFIG_IOCTL_HEX2STR_ERROR is not set
+# CONFIG_FEATURE_HWIB is not set
+
+#
+# Applets
+#
+
+#
+# Archival Utilities
+#
+# CONFIG_FEATURE_SEAMLESS_LZMA is not set
+# CONFIG_FEATURE_SEAMLESS_BZ2 is not set
+CONFIG_FEATURE_SEAMLESS_GZ=y 
+# CONFIG_FEATURE_SEAMLESS_Z is not set
+# CONFIG_AR is not set
+# CONFIG_FEATURE_AR_LONG_FILENAMES is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_BZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_FEATURE_CPIO_O is not set
+# CONFIG_FEATURE_CPIO_P is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_FEATURE_DPKG_DEB_EXTRACT_ONLY is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_LZOP is not set
+# CONFIG_LZOP_COMPR_HIGH is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+# CONFIG_FEATURE_TAR_CREATE is not set
+# CONFIG_FEATURE_TAR_AUTODETECT is not set
+# CONFIG_FEATURE_TAR_FROM is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATIBILITY is not set
+# CONFIG_FEATURE_TAR_OLDSUN_COMPATIBILITY is not set
+# CONFIG_FEATURE_TAR_GNU_EXTENSIONS is not set
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_FEATURE_TAR_UNAME_GNAME is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNLZMA is not set
+# CONFIG_FEATURE_LZMA_FAST is not set
+# CONFIG_UNZIP is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+# CONFIG_CATV is not set
+# CONFIG_CHGRP is not set
+CONFIG_CHMOD=y
+# CONFIG_CHOWN is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CKSUM is not set
+# CONFIG_COMM is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+# CONFIG_FEATURE_DATE_ISOFMT is not set
+# CONFIG_DD is not set
+# CONFIG_FEATURE_DD_SIGNAL_HANDLING is not set
+# CONFIG_FEATURE_DD_IBS_OBS is not set
+# CONFIG_DF is not set
+# CONFIG_FEATURE_DF_FANCY is not set
+# CONFIG_DIRNAME is not set
+# CONFIG_DOS2UNIX is not set
+# CONFIG_UNIX2DOS is not set
+# CONFIG_DU is not set
+# CONFIG_FEATURE_DU_DEFAULT_BLOCKSIZE_1K is not set
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+# CONFIG_FEATURE_ENV_LONG_OPTIONS is not set
+# CONFIG_EXPAND is not set
+# CONFIG_FEATURE_EXPAND_LONG_OPTIONS is not set
+CONFIG_EXPR=y
+# CONFIG_EXPR_MATH_SUPPORT_64 is not set
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+# CONFIG_FSYNC is not set
+# CONFIG_HEAD is not set
+# CONFIG_FEATURE_FANCY_HEAD is not set
+# CONFIG_HOSTID is not set
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_FEATURE_INSTALL_LONG_OPTIONS is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+# CONFIG_FEATURE_LS_SORTFILES is not set
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+# CONFIG_FEATURE_LS_USERNAME is not set
+# CONFIG_FEATURE_LS_COLOR is not set
+# CONFIG_FEATURE_LS_COLOR_IS_DEFAULT is not set
+# CONFIG_MD5SUM is not set
+CONFIG_MKDIR=y
+# CONFIG_FEATURE_MKDIR_LONG_OPTIONS is not set
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_FEATURE_MV_LONG_OPTIONS is not set
+# CONFIG_NICE is not set
+# CONFIG_NOHUP is not set
+# CONFIG_OD is not set
+# CONFIG_PRINTENV is not set
+# CONFIG_PRINTF is not set
+CONFIG_PWD=y
+# CONFIG_READLINK is not set
+# CONFIG_FEATURE_READLINK_FOLLOW is not set
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+# CONFIG_RMDIR is not set
+# CONFIG_FEATURE_RMDIR_LONG_OPTIONS is not set
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+# CONFIG_SHA256SUM is not set
+# CONFIG_SHA512SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_FEATURE_FLOAT_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_FEATURE_SORT_BIG is not set
+# CONFIG_SPLIT is not set
+# CONFIG_FEATURE_SPLIT_FANCY is not set
+# CONFIG_STAT is not set
+# CONFIG_FEATURE_STAT_FORMAT is not set
+# CONFIG_STTY is not set
+# CONFIG_SUM is not set
+CONFIG_SYNC=y
+# CONFIG_TAC is not set
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+# CONFIG_TEE is not set
+# CONFIG_FEATURE_TEE_USE_BLOCK_IO is not set
+CONFIG_TEST=y
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+# CONFIG_TR is not set
+# CONFIG_FEATURE_TR_CLASSES is not set
+# CONFIG_FEATURE_TR_EQUIV is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNEXPAND is not set
+# CONFIG_FEATURE_UNEXPAND_LONG_OPTIONS is not set
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WC is not set
+# CONFIG_FEATURE_WC_LARGE is not set
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls, more and telnet
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+# CONFIG_FEATURE_HUMAN_READABLE is not set
+# CONFIG_FEATURE_MD5_SHA1_SUM_CHECK is not set
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_KBD_MODE is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_RESIZE is not set
+# CONFIG_FEATURE_RESIZE_PRINT is not set
+# CONFIG_SETCONSOLE is not set
+# CONFIG_FEATURE_SETCONSOLE_LONG_OPTIONS is not set
+# CONFIG_SETFONT is not set
+# CONFIG_FEATURE_SETFONT_TEXTUAL_MAP is not set
+CONFIG_DEFAULT_SETFONT_DIR=""
+# CONFIG_SETKEYCODES is not set
+# CONFIG_SETLOGCONS is not set
+# CONFIG_SHOWKEY is not set
+
+#
+# Debian Utilities
+#
+# CONFIG_MKTEMP is not set
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_FEATURE_RUN_PARTS_LONG_OPTIONS is not set
+# CONFIG_FEATURE_RUN_PARTS_FANCY is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_FEATURE_START_STOP_DAEMON_FANCY is not set
+# CONFIG_FEATURE_START_STOP_DAEMON_LONG_OPTIONS is not set
+CONFIG_WHICH=y
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_FEATURE_AWK_LIBM is not set
+# CONFIG_CMP is not set
+# CONFIG_DIFF is not set
+# CONFIG_FEATURE_DIFF_BINARY is not set
+# CONFIG_FEATURE_DIFF_DIR is not set
+# CONFIG_FEATURE_DIFF_MINIMAL is not set
+# CONFIG_ED is not set
+# CONFIG_PATCH is not set
+# CONFIG_SED is not set
+CONFIG_VI=y
+CONFIG_FEATURE_VI_MAX_LEN=4096
+# CONFIG_FEATURE_VI_8BIT is not set
+# CONFIG_FEATURE_VI_COLON is not set
+# CONFIG_FEATURE_VI_YANKMARK is not set
+# CONFIG_FEATURE_VI_SEARCH is not set
+# CONFIG_FEATURE_VI_USE_SIGNALS is not set
+# CONFIG_FEATURE_VI_DOT_CMD is not set
+# CONFIG_FEATURE_VI_READONLY is not set
+# CONFIG_FEATURE_VI_SETOPTS is not set
+# CONFIG_FEATURE_VI_SET is not set
+# CONFIG_FEATURE_VI_WIN_RESIZE is not set
+# CONFIG_FEATURE_VI_OPTIMIZE_CURSOR is not set
+# CONFIG_FEATURE_ALLOW_EXEC is not set
+
+#
+# Finding Utilities
+#
+# CONFIG_FIND is not set
+# CONFIG_FEATURE_FIND_PRINT0 is not set
+# CONFIG_FEATURE_FIND_MTIME is not set
+# CONFIG_FEATURE_FIND_MMIN is not set
+# CONFIG_FEATURE_FIND_PERM is not set
+# CONFIG_FEATURE_FIND_TYPE is not set
+# CONFIG_FEATURE_FIND_XDEV is not set
+# CONFIG_FEATURE_FIND_MAXDEPTH is not set
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+# CONFIG_FEATURE_FIND_EXEC is not set
+# CONFIG_FEATURE_FIND_USER is not set
+# CONFIG_FEATURE_FIND_GROUP is not set
+# CONFIG_FEATURE_FIND_NOT is not set
+# CONFIG_FEATURE_FIND_DEPTH is not set
+# CONFIG_FEATURE_FIND_PAREN is not set
+# CONFIG_FEATURE_FIND_SIZE is not set
+# CONFIG_FEATURE_FIND_PRUNE is not set
+# CONFIG_FEATURE_FIND_DELETE is not set
+# CONFIG_FEATURE_FIND_PATH is not set
+# CONFIG_FEATURE_FIND_REGEX is not set
+# CONFIG_FEATURE_FIND_CONTEXT is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+# CONFIG_XARGS is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_QUOTES is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM is not set
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_KILL_REMOVED=y
+CONFIG_FEATURE_KILL_DELAY=0
+# CONFIG_FEATURE_INIT_SCTTY is not set
+# CONFIG_FEATURE_INIT_SYSLOG is not set
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+# CONFIG_FEATURE_INITRD is not set
+CONFIG_HALT=y
+# CONFIG_FEATURE_CALL_TELINIT is not set
+CONFIG_TELINIT_PATH=""
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+CONFIG_FEATURE_SHADOWPASSWDS=y
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_USE_BB_SHADOW is not set
+CONFIG_USE_BB_CRYPT=y
+# CONFIG_USE_BB_CRYPT_SHA is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_FEATURE_ADDGROUP_LONG_OPTIONS is not set
+# CONFIG_FEATURE_ADDUSER_TO_GROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_FEATURE_DEL_USER_FROM_GROUP is not set
+# CONFIG_FEATURE_CHECK_NAMES is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_FEATURE_ADDUSER_LONG_OPTIONS is not set
+CONFIG_FIRST_SYSTEM_ID=0
+CONFIG_LAST_SYSTEM_ID=0
+# CONFIG_DELUSER is not set
+CONFIG_GETTY=y
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+CONFIG_LOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_SU=y
+# CONFIG_PAM is not set
+CONFIG_LOGIN_SCRIPTS=y
+CONFIG_REMOTE_LOGIN_RESTRICT=n
+# CONFIG_FEATURE_NOLOGIN is not set
+# CONFIG_FEATURE_SECURETTY is not set
+# CONFIG_FEATURE_PASSWD_WEAK_CHECK is not set
+# CONFIG_CRYPTPW is not set
+# CONFIG_CHPASSWD is not set
+# CONFIG_FEATURE_SU_SYSLOG is not set
+# CONFIG_FEATURE_SU_CHECKS_SHELLS is not set
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Linux Ext2 FS Progs
+#
+# CONFIG_CHATTR is not set
+# CONFIG_FSCK is not set
+# CONFIG_LSATTR is not set
+
+#
+# Linux Module Utilities
+#
+# CONFIG_MODPROBE_SMALL is not set
+# CONFIG_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE is not set
+# CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED is not set
+CONFIG_INSMOD=y
+CONFIG_RMMOD=y
+CONFIG_LSMOD=y
+# CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT is not set
+# CONFIG_MODPROBE is not set
+# CONFIG_FEATURE_MODPROBE_BLACKLIST is not set
+# CONFIG_DEPMOD is not set
+
+#
+# Options common to multiple modutils
+#
+# CONFIG_FEATURE_2_4_MODULES is not set
+# CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
+# CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
+# CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+# CONFIG_FEATURE_MODUTILS_ALIAS is not set
+# CONFIG_FEATURE_MODUTILS_SYMBOLS is not set
+CONFIG_DEFAULT_MODULES_DIR=""
+CONFIG_DEFAULT_DEPMOD_FILE=""
+
+#
+# Linux System Utilities
+#
+# CONFIG_ACPID is not set
+# CONFIG_FEATURE_ACPID_COMPAT is not set
+# CONFIG_BLKID is not set
+CONFIG_DMESG=y
+# CONFIG_FEATURE_DMESG_PRETTY is not set
+# CONFIG_FBSET is not set
+# CONFIG_FEATURE_FBSET_FANCY is not set
+# CONFIG_FEATURE_FBSET_READMODE is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+CONFIG_FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FEATURE_FDISK_WRITABLE is not set
+# CONFIG_FEATURE_AIX_LABEL is not set
+# CONFIG_FEATURE_SGI_LABEL is not set
+# CONFIG_FEATURE_SUN_LABEL is not set
+# CONFIG_FEATURE_OSF_LABEL is not set
+# CONFIG_FEATURE_FDISK_ADVANCED is not set
+# CONFIG_FINDFS is not set
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_FEATURE_MINIX2 is not set
+# CONFIG_MKFS_VFAT is not set
+# CONFIG_GETOPT is not set
+# CONFIG_FEATURE_GETOPT_LONG is not set
+CONFIG_HEXDUMP=y
+# CONFIG_FEATURE_HEXDUMP_REVERSE is not set
+# CONFIG_HD is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_FEATURE_HWCLOCK_LONG_OPTIONS is not set
+# CONFIG_FEATURE_HWCLOCK_ADJTIME_FHS is not set
+# CONFIG_IPCRM is not set
+# CONFIG_IPCS is not set
+# CONFIG_LOSETUP is not set
+CONFIG_MDEV=y
+CONFIG_FEATURE_MDEV_CONF=y
+CONFIG_FEATURE_MDEV_RENAME=y
+CONFIG_FEATURE_MDEV_RENAME_REGEXP=y
+CONFIG_FEATURE_MDEV_EXEC=y
+CONFIG_FEATURE_MDEV_LOAD_FIRMWARE=y
+# CONFIG_MKSWAP is not set
+# CONFIG_FEATURE_MKSWAP_UUID is not set
+# CONFIG_MORE is not set
+# CONFIG_FEATURE_USE_TERMIOS is not set
+# CONFIG_VOLUMEID is not set
+# CONFIG_FEATURE_VOLUMEID_EXT is not set
+# CONFIG_FEATURE_VOLUMEID_REISERFS is not set
+# CONFIG_FEATURE_VOLUMEID_FAT is not set
+# CONFIG_FEATURE_VOLUMEID_HFS is not set
+# CONFIG_FEATURE_VOLUMEID_JFS is not set
+# CONFIG_FEATURE_VOLUMEID_XFS is not set
+# CONFIG_FEATURE_VOLUMEID_NTFS is not set
+# CONFIG_FEATURE_VOLUMEID_ISO9660 is not set
+# CONFIG_FEATURE_VOLUMEID_UDF is not set
+# CONFIG_FEATURE_VOLUMEID_LUKS is not set
+# CONFIG_FEATURE_VOLUMEID_LINUXSWAP is not set
+# CONFIG_FEATURE_VOLUMEID_CRAMFS is not set
+# CONFIG_FEATURE_VOLUMEID_ROMFS is not set
+# CONFIG_FEATURE_VOLUMEID_SYSV is not set
+# CONFIG_FEATURE_VOLUMEID_OCFS2 is not set
+# CONFIG_FEATURE_VOLUMEID_LINUXRAID is not set
+CONFIG_MOUNT=y
+# CONFIG_FEATURE_MOUNT_FAKE is not set
+# CONFIG_FEATURE_MOUNT_VERBOSE is not set
+# CONFIG_FEATURE_MOUNT_HELPERS is not set
+# CONFIG_FEATURE_MOUNT_LABEL is not set
+# CONFIG_FEATURE_MOUNT_NFS is not set
+# CONFIG_FEATURE_MOUNT_CIFS is not set
+# CONFIG_FEATURE_MOUNT_FLAGS is not set
+# CONFIG_FEATURE_MOUNT_FSTAB is not set
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_RDEV is not set
+# CONFIG_READPROFILE is not set
+# CONFIG_RTCWAKE is not set
+# CONFIG_SCRIPT is not set
+# CONFIG_SCRIPTREPLAY is not set
+# CONFIG_SETARCH is not set
+# CONFIG_SWAPONOFF is not set
+# CONFIG_FEATURE_SWAPON_PRI is not set
+# CONFIG_SWITCH_ROOT is not set
+CONFIG_UMOUNT=y
+# CONFIG_FEATURE_UMOUNT_ALL is not set
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_BBCONFIG is not set
+# CONFIG_BEEP is not set
+CONFIG_FEATURE_BEEP_FREQ=0
+CONFIG_FEATURE_BEEP_LENGTH_MS=0
+# CONFIG_CHAT is not set
+# CONFIG_FEATURE_CHAT_NOFAIL is not set
+# CONFIG_FEATURE_CHAT_TTY_HIFI is not set
+# CONFIG_FEATURE_CHAT_IMPLICIT_CR is not set
+# CONFIG_FEATURE_CHAT_SWALLOW_OPTS is not set
+# CONFIG_FEATURE_CHAT_SEND_ESCAPES is not set
+# CONFIG_FEATURE_CHAT_VAR_ABORT_LEN is not set
+# CONFIG_FEATURE_CHAT_CLR_ABORT is not set
+# CONFIG_CHRT is not set
+# CONFIG_CROND is not set
+# CONFIG_FEATURE_CROND_D is not set
+# CONFIG_FEATURE_CROND_CALL_SENDMAIL is not set
+CONFIG_FEATURE_CROND_DIR=""
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_FEATURE_DC_LIBM is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_DEVFSD_MODLOAD is not set
+# CONFIG_DEVFSD_FG_NP is not set
+# CONFIG_DEVFSD_VERBOSE is not set
+# CONFIG_FEATURE_DEVFS is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_EJECT is not set
+# CONFIG_FEATURE_EJECT_SCSI is not set
+# CONFIG_FBSPLASH is not set
+# CONFIG_FLASH_LOCK is not set
+# CONFIG_FLASH_UNLOCK is not set
+# CONFIG_FLASH_ERASEALL is not set
+# CONFIG_IONICE is not set
+# CONFIG_INOTIFYD is not set
+# CONFIG_LAST is not set
+# CONFIG_FEATURE_LAST_SMALL is not set
+# CONFIG_FEATURE_LAST_FANCY is not set
+# CONFIG_LESS is not set
+CONFIG_FEATURE_LESS_MAXLINES=0
+# CONFIG_FEATURE_LESS_BRACKETS is not set
+# CONFIG_FEATURE_LESS_FLAGS is not set
+# CONFIG_FEATURE_LESS_MARKS is not set
+# CONFIG_FEATURE_LESS_REGEXP is not set
+# CONFIG_FEATURE_LESS_WINCH is not set
+# CONFIG_FEATURE_LESS_DASHCMD is not set
+# CONFIG_FEATURE_LESS_LINENUMS is not set
+# CONFIG_HDPARM is not set
+# CONFIG_FEATURE_HDPARM_GET_IDENTITY is not set
+# CONFIG_FEATURE_HDPARM_HDIO_SCAN_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_DRIVE_RESET is not set
+# CONFIG_FEATURE_HDPARM_HDIO_TRISTATE_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_GETSET_DMA is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_FEATURE_MAKEDEVS_LEAF is not set
+# CONFIG_FEATURE_MAKEDEVS_TABLE is not set
+# CONFIG_MAN is not set
+# CONFIG_MICROCOM is not set
+# CONFIG_MOUNTPOINT is not set
+# CONFIG_MT is not set
+# CONFIG_RAIDAUTORUN is not set
+# CONFIG_READAHEAD is not set
+# CONFIG_RUNLEVEL is not set
+# CONFIG_RX is not set
+# CONFIG_SETSID is not set
+# CONFIG_STRINGS is not set
+# CONFIG_TASKSET is not set
+# CONFIG_FEATURE_TASKSET_FANCY is not set
+# CONFIG_TIME is not set
+# CONFIG_TIMEOUT is not set
+# CONFIG_TTYSIZE is not set
+# CONFIG_VOLNAME is not set
+CONFIG_WATCHDOG=y
+CONFIG_FACTORYRESET=y
+CONFIG_ETHREG=y
+CONFIG_MDMM=y
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+# CONFIG_FEATURE_UNIX_LOCAL is not set
+# CONFIG_FEATURE_PREFER_IPV4_ADDRESS is not set
+# CONFIG_VERBOSE_RESOLUTION_ERRORS is not set
+# CONFIG_ARP is not set
+# CONFIG_ARPING is not set
+CONFIG_BRCTL=y
+CONFIG_FEATURE_BRCTL_FANCY=y
+CONFIG_FEATURE_BRCTL_SHOW=y
+# CONFIG_DNSD is not set
+# CONFIG_ETHER_WAKE is not set
+# CONFIG_FAKEIDENTD is not set
+# CONFIG_FTPD is not set
+# CONFIG_FEATURE_FTP_WRITE is not set
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_FEATURE_FTPGETPUT_LONG_OPTIONS is not set
+CONFIG_HOSTNAME=y
+
+CONFIG_HTTPD=y
+CONFIG_FEATURE_HTTPD_RANGES=n
+CONFIG_FEATURE_HTTPD_USE_SENDFILE=n
+# CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR=n
+CONFIG_FEATURE_HTTPD_CGI=y
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+CONFIG_FEATURE_HTTPD_ERROR_PAGES=n
+CONFIG_FEATURE_HTTPD_PROXY=n
+CONFIG_IFCONFIG=y
+# CONFIG_FEATURE_IFCONFIG_S26QOS is not set
+# CONFIG_FEATURE_IFCONFIG_VLAN_IGMP is not set
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_S26QOS=y
+CONFIG_FEATURE_IFCONFIG_VLAN_IGMP=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFENSLAVE is not set
+# CONFIG_IFPLUGD is not set
+# CONFIG_IFUPDOWN is not set
+CONFIG_IFUPDOWN_IFSTATE_PATH=""
+# CONFIG_FEATURE_IFUPDOWN_IP is not set
+# CONFIG_FEATURE_IFUPDOWN_IP_BUILTIN is not set
+# CONFIG_FEATURE_IFUPDOWN_IFCONFIG_BUILTIN is not set
+# CONFIG_FEATURE_IFUPDOWN_IPV4 is not set
+# CONFIG_FEATURE_IFUPDOWN_IPV6 is not set
+# CONFIG_FEATURE_IFUPDOWN_MAPPING is not set
+# CONFIG_FEATURE_IFUPDOWN_EXTERNAL_DHCP is not set
+# CONFIG_INETD is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN is not set
+# CONFIG_FEATURE_INETD_RPC is not set
+# CONFIG_IP is not set
+# CONFIG_FEATURE_IP_ADDRESS is not set
+# CONFIG_FEATURE_IP_LINK is not set
+# CONFIG_FEATURE_IP_ROUTE is not set
+# CONFIG_FEATURE_IP_TUNNEL is not set
+# CONFIG_FEATURE_IP_RULE is not set
+# CONFIG_FEATURE_IP_SHORT_FORMS is not set
+# CONFIG_FEATURE_IP_RARE_PROTOCOLS is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+CONFIG_IPROUTE=y
+# CONFIG_IPTUNNEL is not set
+# CONFIG_IPRULE is not set
+# CONFIG_IPCALC is not set
+# CONFIG_FEATURE_IPCALC_FANCY is not set
+# CONFIG_FEATURE_IPCALC_LONG_OPTIONS is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_FEATURE_NAMEIF_EXTENDED is not set
+# CONFIG_NC is not set
+# CONFIG_NC_SERVER is not set
+# CONFIG_NC_EXTRA is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_FEATURE_NETSTAT_WIDE is not set
+# CONFIG_FEATURE_NETSTAT_PRG is not set
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+# CONFIG_PING6 is not set
+CONFIG_FEATURE_FANCY_PING=y
+# CONFIG_PSCAN is not set
+CONFIG_ROUTE=y
+# CONFIG_SLATTACH is not set
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_TELNETD=y
+CONFIG_FEATURE_TELNETD_STANDALONE=y
+CONFIG_FEATURE_TELNETD_NO_DAEMONIZE=y
+CONFIG_TFTP=y
+# CONFIG_TFTPD is not set
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+# CONFIG_FEATURE_TRACEROUTE_VERBOSE is not set
+# CONFIG_FEATURE_TRACEROUTE_SOURCE_ROUTE is not set
+# CONFIG_FEATURE_TRACEROUTE_USE_ICMP is not set
+# CONFIG_APP_UDHCPD is not set
+# CONFIG_APP_DHCPRELAY is not set
+# CONFIG_APP_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCPD_WRITE_LEASES_EARLY is not set
+CONFIG_DHCPD_LEASES_FILE=""
+CONFIG_APP_UDHCPC=y
+CONFIG_FEATURE_UDHCPC_ARPING=y
+CONFIG_FEATURE_UDHCP_PORT=y
+CONFIG_UDHCP_DEBUG=9
+CONFIG_FEATURE_UDHCP_RFC3397=y
+CONFIG_UDHCPC_DEFAULT_SCRIPT="/usr/share/udhcpc/default.script"
+CONFIG_UDHCPC_SLACK_FOR_BUGGY_SERVERS=80
+CONFIG_IFUPDOWN_UDHCPC_CMD_OPTIONS=""
+CONFIG_VCONFIG=y
+CONFIG_WGET=y
+# CONFIG_FEATURE_WGET_STATUSBAR is not set
+# CONFIG_FEATURE_WGET_AUTHENTICATION is not set
+# CONFIG_FEATURE_WGET_LONG_OPTIONS is not set
+# CONFIG_ZCIP is not set
+# CONFIG_TCPSVD is not set
+# CONFIG_TUNCTL is not set
+# CONFIG_FEATURE_TUNCTL_UG is not set
+# CONFIG_UDPSVD is not set
+
+#
+# Print Utilities
+#
+# CONFIG_LPD is not set
+# CONFIG_LPR is not set
+# CONFIG_LPQ is not set
+
+#
+# Mail Utilities
+#
+# CONFIG_MAKEMIME is not set
+CONFIG_FEATURE_MIME_CHARSET=""
+# CONFIG_POPMAILDIR is not set
+# CONFIG_FEATURE_POPMAILDIR_DELIVERY is not set
+# CONFIG_REFORMIME is not set
+# CONFIG_FEATURE_REFORMIME_COMPAT is not set
+# CONFIG_SENDMAIL is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+# CONFIG_FUSER is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_KILLALL5 is not set
+# CONFIG_NMETER is not set
+# CONFIG_PGREP is not set
+# CONFIG_PIDOF is not set
+# CONFIG_FEATURE_PIDOF_SINGLE is not set
+# CONFIG_FEATURE_PIDOF_OMIT is not set
+# CONFIG_PKILL is not set
+CONFIG_PS=y
+# CONFIG_FEATURE_PS_WIDE is not set
+# CONFIG_FEATURE_PS_TIME is not set
+# CONFIG_FEATURE_PS_ADDITIONAL_COLUMNS is not set
+# CONFIG_FEATURE_PS_UNUSUAL_SYSTEMS is not set
+# CONFIG_RENICE is not set
+# CONFIG_BB_SYSCTL is not set
+CONFIG_TOP=y
+CONFIG_FEATURE_TOP_CPU_USAGE_PERCENTAGE=y
+CONFIG_FEATURE_TOP_CPU_GLOBAL_PERCENTS=y
+# CONFIG_FEATURE_TOP_SMP_CPU is not set
+# CONFIG_FEATURE_TOP_DECIMALS is not set
+# CONFIG_FEATURE_TOP_SMP_PROCESS is not set
+# CONFIG_FEATURE_TOPMEM is not set
+# CONFIG_UPTIME is not set
+# CONFIG_WATCH is not set
+
+#
+# Runit Utilities
+#
+# CONFIG_RUNSV is not set
+# CONFIG_RUNSVDIR is not set
+# CONFIG_FEATURE_RUNSVDIR_LOG is not set
+# CONFIG_SV is not set
+CONFIG_SV_DEFAULT_SERVICE_DIR=""
+# CONFIG_SVLOGD is not set
+# CONFIG_CHPST is not set
+# CONFIG_SETUIDGID is not set
+# CONFIG_ENVUIDGID is not set
+# CONFIG_ENVDIR is not set
+# CONFIG_SOFTLIMIT is not set
+# CONFIG_CHCON is not set
+# CONFIG_FEATURE_CHCON_LONG_OPTIONS is not set
+# CONFIG_GETENFORCE is not set
+# CONFIG_GETSEBOOL is not set
+# CONFIG_LOAD_POLICY is not set
+# CONFIG_MATCHPATHCON is not set
+# CONFIG_RESTORECON is not set
+# CONFIG_RUNCON is not set
+# CONFIG_FEATURE_RUNCON_LONG_OPTIONS is not set
+# CONFIG_SELINUXENABLED is not set
+# CONFIG_SETENFORCE is not set
+# CONFIG_SETFILES is not set
+# CONFIG_FEATURE_SETFILES_CHECK_OPTION is not set
+# CONFIG_SETSEBOOL is not set
+# CONFIG_SESTATUS is not set
+
+#
+# Shells
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+CONFIG_ASH_BASH_COMPAT=y
+CONFIG_ASH_JOB_CONTROL=y
+# CONFIG_ASH_READ_NCHARS is not set
+# CONFIG_ASH_READ_TIMEOUT is not set
+# CONFIG_ASH_ALIAS is not set
+# CONFIG_ASH_GETOPTS is not set
+CONFIG_ASH_BUILTIN_ECHO=y
+# CONFIG_ASH_BUILTIN_PRINTF is not set
+# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_ASH_EXPAND_PRMT is not set
+# CONFIG_HUSH is not set
+# CONFIG_HUSH_BASH_COMPAT is not set
+# CONFIG_HUSH_HELP is not set
+# CONFIG_HUSH_INTERACTIVE is not set
+# CONFIG_HUSH_JOB is not set
+# CONFIG_HUSH_TICK is not set
+# CONFIG_HUSH_IF is not set
+# CONFIG_HUSH_LOOPS is not set
+# CONFIG_HUSH_CASE is not set
+# CONFIG_HUSH_FUNCTIONS is not set
+# CONFIG_HUSH_LOCAL is not set
+# CONFIG_HUSH_EXPORT_N is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+CONFIG_SH_MATH_SUPPORT=y
+CONFIG_SH_MATH_SUPPORT_64=y
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE is not set
+# CONFIG_FEATURE_SH_NOFORK is not set
+# CONFIG_CTTYHACK is not set
+
+#
+# System Logging Utilities
+#
+CONFIG_SYSLOGD=y
+CONFIG_FEATURE_ROTATE_LOGFILE=y
+# CONFIG_FEATURE_REMOTE_LOG is not set
+# CONFIG_FEATURE_SYSLOGD_DUP is not set
+# CONFIG_FEATURE_IPC_SYSLOG is not set
+CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE=0
+# CONFIG_LOGREAD is not set
+# CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING is not set
+# CONFIG_KLOGD is not set
+# CONFIG_LOGGER is not set
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/defconfig-board955x apps_1.2/busybox-1.15.0/defconfig-board955x
--- apps/busybox-1.15.0/defconfig-board955x	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.15.0/defconfig-board955x	2014-05-30 03:43:44.100943749 -0700
@@ -0,0 +1,914 @@
+#
+# Automatically generated make config: don't edit
+# Busybox version: 1.15.0
+# Mon Dec 27 10:32:44 2010
+#
+CONFIG_HAVE_DOT_CONFIG=y
+
+#
+# Busybox Settings
+#
+
+#
+# General Configuration
+#
+# CONFIG_DESKTOP is not set
+# CONFIG_EXTRA_COMPAT is not set
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_SHOW_USAGE=y
+CONFIG_FEATURE_VERBOSE_USAGE=y
+CONFIG_FEATURE_COMPRESS_USAGE=y
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_FEATURE_ASSUME_UNICODE is not set
+# CONFIG_FEATURE_CHECK_UNICODE_IN_ENV is not set
+# CONFIG_LONG_OPTS is not set
+CONFIG_FEATURE_DEVPTS=y
+# CONFIG_FEATURE_CLEAN_UP is not set
+# CONFIG_FEATURE_PIDFILE is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_FEATURE_SUID_CONFIG_QUIET is not set
+# CONFIG_SELINUX is not set
+# CONFIG_FEATURE_PREFER_APPLETS is not set
+CONFIG_BUSYBOX_EXEC_PATH="/proc/self/exe"
+CONFIG_FEATURE_SYSLOG=y
+# CONFIG_FEATURE_HAVE_RPC is not set
+
+#
+# Build Options
+#
+# CONFIG_STATIC is not set
+# CONFIG_PIE is not set
+# CONFIG_NOMMU is not set
+# CONFIG_BUILD_LIBBUSYBOX is not set
+# CONFIG_FEATURE_INDIVIDUAL is not set
+# CONFIG_FEATURE_SHARED_BUSYBOX is not set
+CONFIG_LFS=y
+CONFIG_CROSS_COMPILER_PREFIX="mips-linux-uclibc-"
+CONFIG_EXTRA_CFLAGS=""
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
+# CONFIG_DEBUG_PESSIMIZE is not set
+# CONFIG_WERROR is not set
+CONFIG_NO_DEBUG_LIB=y
+# CONFIG_DMALLOC is not set
+# CONFIG_EFENCE is not set
+# CONFIG_INCLUDE_SUSv2 is not set
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+CONFIG_INSTALL_APPLET_SYMLINKS=y
+# CONFIG_INSTALL_APPLET_HARDLINKS is not set
+# CONFIG_INSTALL_APPLET_SCRIPT_WRAPPERS is not set
+# CONFIG_INSTALL_APPLET_DONT is not set
+# CONFIG_INSTALL_SH_APPLET_SYMLINK is not set
+# CONFIG_INSTALL_SH_APPLET_HARDLINK is not set
+# CONFIG_INSTALL_SH_APPLET_SCRIPT_WRAPPER is not set
+CONFIG_PREFIX="../../rootfs-${BOARD_TYPE}${BUILD_CONFIG}${BUILD_EXT}.build"
+
+#
+# Busybox Library Tuning
+#
+CONFIG_PASSWORD_MINLEN=6
+CONFIG_MD5_SIZE_VS_SPEED=2
+# CONFIG_FEATURE_FAST_TOP is not set
+# CONFIG_FEATURE_ETC_NETWORKS is not set
+CONFIG_FEATURE_EDITING=y
+CONFIG_FEATURE_EDITING_MAX_LEN=1024
+CONFIG_FEATURE_EDITING_VI=y
+CONFIG_FEATURE_EDITING_HISTORY=15
+CONFIG_FEATURE_EDITING_SAVEHISTORY=y
+CONFIG_FEATURE_TAB_COMPLETION=y
+# CONFIG_FEATURE_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_EDITING_FANCY_PROMPT=y
+# CONFIG_FEATURE_EDITING_ASK_TERMINAL is not set
+CONFIG_FEATURE_NON_POSIX_CP=y
+# CONFIG_FEATURE_VERBOSE_CP_MESSAGE is not set
+CONFIG_FEATURE_COPYBUF_KB=4
+# CONFIG_MONOTONIC_SYSCALL is not set
+# CONFIG_IOCTL_HEX2STR_ERROR is not set
+# CONFIG_FEATURE_HWIB is not set
+
+#
+# Applets
+#
+
+#
+# Archival Utilities
+#
+# CONFIG_FEATURE_SEAMLESS_LZMA is not set
+# CONFIG_FEATURE_SEAMLESS_BZ2 is not set
+CONFIG_FEATURE_SEAMLESS_GZ=y 
+# CONFIG_FEATURE_SEAMLESS_Z is not set
+# CONFIG_AR is not set
+# CONFIG_FEATURE_AR_LONG_FILENAMES is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_BZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_FEATURE_CPIO_O is not set
+# CONFIG_FEATURE_CPIO_P is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_FEATURE_DPKG_DEB_EXTRACT_ONLY is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_LZOP is not set
+# CONFIG_LZOP_COMPR_HIGH is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+# CONFIG_FEATURE_TAR_CREATE is not set
+# CONFIG_FEATURE_TAR_AUTODETECT is not set
+# CONFIG_FEATURE_TAR_FROM is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATIBILITY is not set
+# CONFIG_FEATURE_TAR_OLDSUN_COMPATIBILITY is not set
+# CONFIG_FEATURE_TAR_GNU_EXTENSIONS is not set
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_FEATURE_TAR_UNAME_GNAME is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNLZMA is not set
+# CONFIG_FEATURE_LZMA_FAST is not set
+# CONFIG_UNZIP is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+# CONFIG_CATV is not set
+# CONFIG_CHGRP is not set
+CONFIG_CHMOD=y
+# CONFIG_CHOWN is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CKSUM is not set
+# CONFIG_COMM is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+# CONFIG_FEATURE_DATE_ISOFMT is not set
+# CONFIG_DD is not set
+# CONFIG_FEATURE_DD_SIGNAL_HANDLING is not set
+# CONFIG_FEATURE_DD_IBS_OBS is not set
+# CONFIG_DF is not set
+# CONFIG_FEATURE_DF_FANCY is not set
+# CONFIG_DIRNAME is not set
+# CONFIG_DOS2UNIX is not set
+# CONFIG_UNIX2DOS is not set
+# CONFIG_DU is not set
+# CONFIG_FEATURE_DU_DEFAULT_BLOCKSIZE_1K is not set
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+# CONFIG_FEATURE_ENV_LONG_OPTIONS is not set
+# CONFIG_EXPAND is not set
+# CONFIG_FEATURE_EXPAND_LONG_OPTIONS is not set
+CONFIG_EXPR=y
+# CONFIG_EXPR_MATH_SUPPORT_64 is not set
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+# CONFIG_FSYNC is not set
+# CONFIG_HEAD is not set
+# CONFIG_FEATURE_FANCY_HEAD is not set
+# CONFIG_HOSTID is not set
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_FEATURE_INSTALL_LONG_OPTIONS is not set
+# CONFIG_LENGTH is not set
+CONFIG_LN=y
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+# CONFIG_FEATURE_LS_SORTFILES is not set
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+# CONFIG_FEATURE_LS_USERNAME is not set
+# CONFIG_FEATURE_LS_COLOR is not set
+# CONFIG_FEATURE_LS_COLOR_IS_DEFAULT is not set
+# CONFIG_MD5SUM is not set
+CONFIG_MKDIR=y
+# CONFIG_FEATURE_MKDIR_LONG_OPTIONS is not set
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MV=y
+# CONFIG_FEATURE_MV_LONG_OPTIONS is not set
+# CONFIG_NICE is not set
+# CONFIG_NOHUP is not set
+# CONFIG_OD is not set
+# CONFIG_PRINTENV is not set
+# CONFIG_PRINTF is not set
+CONFIG_PWD=y
+# CONFIG_READLINK is not set
+# CONFIG_FEATURE_READLINK_FOLLOW is not set
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+# CONFIG_RMDIR is not set
+# CONFIG_FEATURE_RMDIR_LONG_OPTIONS is not set
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+# CONFIG_SHA256SUM is not set
+# CONFIG_SHA512SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_FEATURE_FLOAT_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_FEATURE_SORT_BIG is not set
+# CONFIG_SPLIT is not set
+# CONFIG_FEATURE_SPLIT_FANCY is not set
+# CONFIG_STAT is not set
+# CONFIG_FEATURE_STAT_FORMAT is not set
+# CONFIG_STTY is not set
+# CONFIG_SUM is not set
+CONFIG_SYNC=y
+# CONFIG_TAC is not set
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+# CONFIG_TEE is not set
+# CONFIG_FEATURE_TEE_USE_BLOCK_IO is not set
+CONFIG_TEST=y
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+# CONFIG_TR is not set
+# CONFIG_FEATURE_TR_CLASSES is not set
+# CONFIG_FEATURE_TR_EQUIV is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNEXPAND is not set
+# CONFIG_FEATURE_UNEXPAND_LONG_OPTIONS is not set
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WC is not set
+# CONFIG_FEATURE_WC_LARGE is not set
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls, more and telnet
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+# CONFIG_FEATURE_HUMAN_READABLE is not set
+# CONFIG_FEATURE_MD5_SHA1_SUM_CHECK is not set
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_KBD_MODE is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_RESIZE is not set
+# CONFIG_FEATURE_RESIZE_PRINT is not set
+# CONFIG_SETCONSOLE is not set
+# CONFIG_FEATURE_SETCONSOLE_LONG_OPTIONS is not set
+# CONFIG_SETFONT is not set
+# CONFIG_FEATURE_SETFONT_TEXTUAL_MAP is not set
+CONFIG_DEFAULT_SETFONT_DIR=""
+# CONFIG_SETKEYCODES is not set
+# CONFIG_SETLOGCONS is not set
+# CONFIG_SHOWKEY is not set
+
+#
+# Debian Utilities
+#
+# CONFIG_MKTEMP is not set
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_FEATURE_RUN_PARTS_LONG_OPTIONS is not set
+# CONFIG_FEATURE_RUN_PARTS_FANCY is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_FEATURE_START_STOP_DAEMON_FANCY is not set
+# CONFIG_FEATURE_START_STOP_DAEMON_LONG_OPTIONS is not set
+CONFIG_WHICH=y
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_FEATURE_AWK_LIBM is not set
+# CONFIG_CMP is not set
+# CONFIG_DIFF is not set
+# CONFIG_FEATURE_DIFF_BINARY is not set
+# CONFIG_FEATURE_DIFF_DIR is not set
+# CONFIG_FEATURE_DIFF_MINIMAL is not set
+# CONFIG_ED is not set
+# CONFIG_PATCH is not set
+# CONFIG_SED is not set
+CONFIG_VI=y
+CONFIG_FEATURE_VI_MAX_LEN=4096
+# CONFIG_FEATURE_VI_8BIT is not set
+# CONFIG_FEATURE_VI_COLON is not set
+# CONFIG_FEATURE_VI_YANKMARK is not set
+# CONFIG_FEATURE_VI_SEARCH is not set
+# CONFIG_FEATURE_VI_USE_SIGNALS is not set
+# CONFIG_FEATURE_VI_DOT_CMD is not set
+# CONFIG_FEATURE_VI_READONLY is not set
+# CONFIG_FEATURE_VI_SETOPTS is not set
+# CONFIG_FEATURE_VI_SET is not set
+# CONFIG_FEATURE_VI_WIN_RESIZE is not set
+# CONFIG_FEATURE_VI_OPTIMIZE_CURSOR is not set
+# CONFIG_FEATURE_ALLOW_EXEC is not set
+
+#
+# Finding Utilities
+#
+# CONFIG_FIND is not set
+# CONFIG_FEATURE_FIND_PRINT0 is not set
+# CONFIG_FEATURE_FIND_MTIME is not set
+# CONFIG_FEATURE_FIND_MMIN is not set
+# CONFIG_FEATURE_FIND_PERM is not set
+# CONFIG_FEATURE_FIND_TYPE is not set
+# CONFIG_FEATURE_FIND_XDEV is not set
+# CONFIG_FEATURE_FIND_MAXDEPTH is not set
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+# CONFIG_FEATURE_FIND_EXEC is not set
+# CONFIG_FEATURE_FIND_USER is not set
+# CONFIG_FEATURE_FIND_GROUP is not set
+# CONFIG_FEATURE_FIND_NOT is not set
+# CONFIG_FEATURE_FIND_DEPTH is not set
+# CONFIG_FEATURE_FIND_PAREN is not set
+# CONFIG_FEATURE_FIND_SIZE is not set
+# CONFIG_FEATURE_FIND_PRUNE is not set
+# CONFIG_FEATURE_FIND_DELETE is not set
+# CONFIG_FEATURE_FIND_PATH is not set
+# CONFIG_FEATURE_FIND_REGEX is not set
+# CONFIG_FEATURE_FIND_CONTEXT is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+# CONFIG_XARGS is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_QUOTES is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM is not set
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_KILL_REMOVED=y
+CONFIG_FEATURE_KILL_DELAY=0
+# CONFIG_FEATURE_INIT_SCTTY is not set
+# CONFIG_FEATURE_INIT_SYSLOG is not set
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+# CONFIG_FEATURE_INITRD is not set
+CONFIG_HALT=y
+# CONFIG_FEATURE_CALL_TELINIT is not set
+CONFIG_TELINIT_PATH=""
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+CONFIG_FEATURE_SHADOWPASSWDS=y
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_USE_BB_SHADOW is not set
+CONFIG_USE_BB_CRYPT=y
+# CONFIG_USE_BB_CRYPT_SHA is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_FEATURE_ADDGROUP_LONG_OPTIONS is not set
+# CONFIG_FEATURE_ADDUSER_TO_GROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_FEATURE_DEL_USER_FROM_GROUP is not set
+# CONFIG_FEATURE_CHECK_NAMES is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_FEATURE_ADDUSER_LONG_OPTIONS is not set
+CONFIG_FIRST_SYSTEM_ID=0
+CONFIG_LAST_SYSTEM_ID=0
+# CONFIG_DELUSER is not set
+CONFIG_GETTY=y
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+CONFIG_LOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_SU=y
+# CONFIG_PAM is not set
+CONFIG_LOGIN_SCRIPTS=y
+CONFIG_REMOTE_LOGIN_RESTRICT=n
+# CONFIG_FEATURE_NOLOGIN is not set
+# CONFIG_FEATURE_SECURETTY is not set
+# CONFIG_FEATURE_PASSWD_WEAK_CHECK is not set
+# CONFIG_CRYPTPW is not set
+# CONFIG_CHPASSWD is not set
+# CONFIG_FEATURE_SU_SYSLOG is not set
+# CONFIG_FEATURE_SU_CHECKS_SHELLS is not set
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Linux Ext2 FS Progs
+#
+# CONFIG_CHATTR is not set
+# CONFIG_FSCK is not set
+# CONFIG_LSATTR is not set
+
+#
+# Linux Module Utilities
+#
+# CONFIG_MODPROBE_SMALL is not set
+# CONFIG_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE is not set
+# CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED is not set
+CONFIG_INSMOD=y
+CONFIG_RMMOD=y
+CONFIG_LSMOD=y
+# CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT is not set
+# CONFIG_MODPROBE is not set
+# CONFIG_FEATURE_MODPROBE_BLACKLIST is not set
+# CONFIG_DEPMOD is not set
+
+#
+# Options common to multiple modutils
+#
+# CONFIG_FEATURE_2_4_MODULES is not set
+# CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
+# CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
+# CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+# CONFIG_FEATURE_MODUTILS_ALIAS is not set
+# CONFIG_FEATURE_MODUTILS_SYMBOLS is not set
+CONFIG_DEFAULT_MODULES_DIR=""
+CONFIG_DEFAULT_DEPMOD_FILE=""
+
+#
+# Linux System Utilities
+#
+# CONFIG_ACPID is not set
+# CONFIG_FEATURE_ACPID_COMPAT is not set
+# CONFIG_BLKID is not set
+CONFIG_DMESG=y
+# CONFIG_FEATURE_DMESG_PRETTY is not set
+# CONFIG_FBSET is not set
+# CONFIG_FEATURE_FBSET_FANCY is not set
+# CONFIG_FEATURE_FBSET_READMODE is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+CONFIG_FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FEATURE_FDISK_WRITABLE is not set
+# CONFIG_FEATURE_AIX_LABEL is not set
+# CONFIG_FEATURE_SGI_LABEL is not set
+# CONFIG_FEATURE_SUN_LABEL is not set
+# CONFIG_FEATURE_OSF_LABEL is not set
+# CONFIG_FEATURE_FDISK_ADVANCED is not set
+# CONFIG_FINDFS is not set
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_FEATURE_MINIX2 is not set
+# CONFIG_MKFS_VFAT is not set
+# CONFIG_GETOPT is not set
+# CONFIG_FEATURE_GETOPT_LONG is not set
+CONFIG_HEXDUMP=y
+# CONFIG_FEATURE_HEXDUMP_REVERSE is not set
+# CONFIG_HD is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_FEATURE_HWCLOCK_LONG_OPTIONS is not set
+# CONFIG_FEATURE_HWCLOCK_ADJTIME_FHS is not set
+# CONFIG_IPCRM is not set
+# CONFIG_IPCS is not set
+# CONFIG_LOSETUP is not set
+CONFIG_MDEV=y
+CONFIG_FEATURE_MDEV_CONF=y
+CONFIG_FEATURE_MDEV_RENAME=y
+CONFIG_FEATURE_MDEV_RENAME_REGEXP=y
+CONFIG_FEATURE_MDEV_EXEC=y
+CONFIG_FEATURE_MDEV_LOAD_FIRMWARE=y
+# CONFIG_MKSWAP is not set
+# CONFIG_FEATURE_MKSWAP_UUID is not set
+# CONFIG_MORE is not set
+# CONFIG_FEATURE_USE_TERMIOS is not set
+# CONFIG_VOLUMEID is not set
+# CONFIG_FEATURE_VOLUMEID_EXT is not set
+# CONFIG_FEATURE_VOLUMEID_REISERFS is not set
+# CONFIG_FEATURE_VOLUMEID_FAT is not set
+# CONFIG_FEATURE_VOLUMEID_HFS is not set
+# CONFIG_FEATURE_VOLUMEID_JFS is not set
+# CONFIG_FEATURE_VOLUMEID_XFS is not set
+# CONFIG_FEATURE_VOLUMEID_NTFS is not set
+# CONFIG_FEATURE_VOLUMEID_ISO9660 is not set
+# CONFIG_FEATURE_VOLUMEID_UDF is not set
+# CONFIG_FEATURE_VOLUMEID_LUKS is not set
+# CONFIG_FEATURE_VOLUMEID_LINUXSWAP is not set
+# CONFIG_FEATURE_VOLUMEID_CRAMFS is not set
+# CONFIG_FEATURE_VOLUMEID_ROMFS is not set
+# CONFIG_FEATURE_VOLUMEID_SYSV is not set
+# CONFIG_FEATURE_VOLUMEID_OCFS2 is not set
+# CONFIG_FEATURE_VOLUMEID_LINUXRAID is not set
+CONFIG_MOUNT=y
+# CONFIG_FEATURE_MOUNT_FAKE is not set
+# CONFIG_FEATURE_MOUNT_VERBOSE is not set
+# CONFIG_FEATURE_MOUNT_HELPERS is not set
+# CONFIG_FEATURE_MOUNT_LABEL is not set
+# CONFIG_FEATURE_MOUNT_NFS is not set
+# CONFIG_FEATURE_MOUNT_CIFS is not set
+# CONFIG_FEATURE_MOUNT_FLAGS is not set
+# CONFIG_FEATURE_MOUNT_FSTAB is not set
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_RDEV is not set
+# CONFIG_READPROFILE is not set
+# CONFIG_RTCWAKE is not set
+# CONFIG_SCRIPT is not set
+# CONFIG_SCRIPTREPLAY is not set
+# CONFIG_SETARCH is not set
+# CONFIG_SWAPONOFF is not set
+# CONFIG_FEATURE_SWAPON_PRI is not set
+# CONFIG_SWITCH_ROOT is not set
+CONFIG_UMOUNT=y
+# CONFIG_FEATURE_UMOUNT_ALL is not set
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_BBCONFIG is not set
+# CONFIG_BEEP is not set
+CONFIG_FEATURE_BEEP_FREQ=0
+CONFIG_FEATURE_BEEP_LENGTH_MS=0
+# CONFIG_CHAT is not set
+# CONFIG_FEATURE_CHAT_NOFAIL is not set
+# CONFIG_FEATURE_CHAT_TTY_HIFI is not set
+# CONFIG_FEATURE_CHAT_IMPLICIT_CR is not set
+# CONFIG_FEATURE_CHAT_SWALLOW_OPTS is not set
+# CONFIG_FEATURE_CHAT_SEND_ESCAPES is not set
+# CONFIG_FEATURE_CHAT_VAR_ABORT_LEN is not set
+# CONFIG_FEATURE_CHAT_CLR_ABORT is not set
+# CONFIG_CHRT is not set
+# CONFIG_CROND is not set
+# CONFIG_FEATURE_CROND_D is not set
+# CONFIG_FEATURE_CROND_CALL_SENDMAIL is not set
+CONFIG_FEATURE_CROND_DIR=""
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_FEATURE_DC_LIBM is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_DEVFSD_MODLOAD is not set
+# CONFIG_DEVFSD_FG_NP is not set
+# CONFIG_DEVFSD_VERBOSE is not set
+# CONFIG_FEATURE_DEVFS is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_EJECT is not set
+# CONFIG_FEATURE_EJECT_SCSI is not set
+# CONFIG_FBSPLASH is not set
+# CONFIG_FLASH_LOCK is not set
+# CONFIG_FLASH_UNLOCK is not set
+# CONFIG_FLASH_ERASEALL is not set
+# CONFIG_IONICE is not set
+# CONFIG_INOTIFYD is not set
+# CONFIG_LAST is not set
+# CONFIG_FEATURE_LAST_SMALL is not set
+# CONFIG_FEATURE_LAST_FANCY is not set
+# CONFIG_LESS is not set
+CONFIG_FEATURE_LESS_MAXLINES=0
+# CONFIG_FEATURE_LESS_BRACKETS is not set
+# CONFIG_FEATURE_LESS_FLAGS is not set
+# CONFIG_FEATURE_LESS_MARKS is not set
+# CONFIG_FEATURE_LESS_REGEXP is not set
+# CONFIG_FEATURE_LESS_WINCH is not set
+# CONFIG_FEATURE_LESS_DASHCMD is not set
+# CONFIG_FEATURE_LESS_LINENUMS is not set
+# CONFIG_HDPARM is not set
+# CONFIG_FEATURE_HDPARM_GET_IDENTITY is not set
+# CONFIG_FEATURE_HDPARM_HDIO_SCAN_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_DRIVE_RESET is not set
+# CONFIG_FEATURE_HDPARM_HDIO_TRISTATE_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_GETSET_DMA is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_FEATURE_MAKEDEVS_LEAF is not set
+# CONFIG_FEATURE_MAKEDEVS_TABLE is not set
+# CONFIG_MAN is not set
+# CONFIG_MICROCOM is not set
+# CONFIG_MOUNTPOINT is not set
+# CONFIG_MT is not set
+# CONFIG_RAIDAUTORUN is not set
+# CONFIG_READAHEAD is not set
+# CONFIG_RUNLEVEL is not set
+# CONFIG_RX is not set
+# CONFIG_SETSID is not set
+# CONFIG_STRINGS is not set
+# CONFIG_TASKSET is not set
+# CONFIG_FEATURE_TASKSET_FANCY is not set
+# CONFIG_TIME is not set
+# CONFIG_TIMEOUT is not set
+# CONFIG_TTYSIZE is not set
+# CONFIG_VOLNAME is not set
+CONFIG_WATCHDOG=y
+CONFIG_FACTORYRESET=y
+CONFIG_ETHREG=y
+CONFIG_MDMM=y
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+# CONFIG_FEATURE_UNIX_LOCAL is not set
+# CONFIG_FEATURE_PREFER_IPV4_ADDRESS is not set
+# CONFIG_VERBOSE_RESOLUTION_ERRORS is not set
+# CONFIG_ARP is not set
+# CONFIG_ARPING is not set
+CONFIG_BRCTL=y
+CONFIG_FEATURE_BRCTL_FANCY=y
+CONFIG_FEATURE_BRCTL_SHOW=y
+# CONFIG_DNSD is not set
+# CONFIG_ETHER_WAKE is not set
+# CONFIG_FAKEIDENTD is not set
+# CONFIG_FTPD is not set
+# CONFIG_FEATURE_FTP_WRITE is not set
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_FEATURE_FTPGETPUT_LONG_OPTIONS is not set
+CONFIG_HOSTNAME=y
+
+CONFIG_HTTPD=y
+CONFIG_FEATURE_HTTPD_RANGES=n
+CONFIG_FEATURE_HTTPD_USE_SENDFILE=n
+# CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY is not set
+CONFIG_FEATURE_HTTPD_BASIC_AUTH=y
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR=n
+CONFIG_FEATURE_HTTPD_CGI=y
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
+CONFIG_FEATURE_HTTPD_ERROR_PAGES=n
+CONFIG_FEATURE_HTTPD_PROXY=n
+CONFIG_IFCONFIG=y
+# CONFIG_FEATURE_IFCONFIG_S26QOS is not set
+# CONFIG_FEATURE_IFCONFIG_VLAN_IGMP is not set
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_S26QOS=y
+CONFIG_FEATURE_IFCONFIG_VLAN_IGMP=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFENSLAVE is not set
+# CONFIG_IFPLUGD is not set
+# CONFIG_IFUPDOWN is not set
+CONFIG_IFUPDOWN_IFSTATE_PATH=""
+# CONFIG_FEATURE_IFUPDOWN_IP is not set
+# CONFIG_FEATURE_IFUPDOWN_IP_BUILTIN is not set
+# CONFIG_FEATURE_IFUPDOWN_IFCONFIG_BUILTIN is not set
+# CONFIG_FEATURE_IFUPDOWN_IPV4 is not set
+# CONFIG_FEATURE_IFUPDOWN_IPV6 is not set
+# CONFIG_FEATURE_IFUPDOWN_MAPPING is not set
+# CONFIG_FEATURE_IFUPDOWN_EXTERNAL_DHCP is not set
+# CONFIG_INETD is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN is not set
+# CONFIG_FEATURE_INETD_RPC is not set
+# CONFIG_IP is not set
+# CONFIG_FEATURE_IP_ADDRESS is not set
+# CONFIG_FEATURE_IP_LINK is not set
+# CONFIG_FEATURE_IP_ROUTE is not set
+# CONFIG_FEATURE_IP_TUNNEL is not set
+# CONFIG_FEATURE_IP_RULE is not set
+# CONFIG_FEATURE_IP_SHORT_FORMS is not set
+# CONFIG_FEATURE_IP_RARE_PROTOCOLS is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+CONFIG_IPROUTE=y
+# CONFIG_IPTUNNEL is not set
+# CONFIG_IPRULE is not set
+# CONFIG_IPCALC is not set
+# CONFIG_FEATURE_IPCALC_FANCY is not set
+# CONFIG_FEATURE_IPCALC_LONG_OPTIONS is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_FEATURE_NAMEIF_EXTENDED is not set
+# CONFIG_NC is not set
+# CONFIG_NC_SERVER is not set
+# CONFIG_NC_EXTRA is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_FEATURE_NETSTAT_WIDE is not set
+# CONFIG_FEATURE_NETSTAT_PRG is not set
+# CONFIG_NSLOOKUP is not set
+CONFIG_PING=y
+# CONFIG_PING6 is not set
+CONFIG_FEATURE_FANCY_PING=y
+# CONFIG_PSCAN is not set
+CONFIG_ROUTE=y
+# CONFIG_SLATTACH is not set
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_TELNETD=y
+CONFIG_FEATURE_TELNETD_STANDALONE=y
+CONFIG_FEATURE_TELNETD_NO_DAEMONIZE=y
+CONFIG_TFTP=y
+# CONFIG_TFTPD is not set
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+# CONFIG_FEATURE_TRACEROUTE_VERBOSE is not set
+# CONFIG_FEATURE_TRACEROUTE_SOURCE_ROUTE is not set
+# CONFIG_FEATURE_TRACEROUTE_USE_ICMP is not set
+# CONFIG_APP_UDHCPD is not set
+# CONFIG_APP_DHCPRELAY is not set
+# CONFIG_APP_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCPD_WRITE_LEASES_EARLY is not set
+CONFIG_DHCPD_LEASES_FILE=""
+CONFIG_APP_UDHCPC=y
+CONFIG_FEATURE_UDHCPC_ARPING=y
+CONFIG_FEATURE_UDHCP_PORT=y
+CONFIG_UDHCP_DEBUG=9
+CONFIG_FEATURE_UDHCP_RFC3397=y
+CONFIG_UDHCPC_DEFAULT_SCRIPT="/usr/share/udhcpc/default.script"
+CONFIG_UDHCPC_SLACK_FOR_BUGGY_SERVERS=80
+CONFIG_IFUPDOWN_UDHCPC_CMD_OPTIONS=""
+CONFIG_VCONFIG=y
+CONFIG_WGET=y
+# CONFIG_FEATURE_WGET_STATUSBAR is not set
+# CONFIG_FEATURE_WGET_AUTHENTICATION is not set
+# CONFIG_FEATURE_WGET_LONG_OPTIONS is not set
+# CONFIG_ZCIP is not set
+# CONFIG_TCPSVD is not set
+# CONFIG_TUNCTL is not set
+# CONFIG_FEATURE_TUNCTL_UG is not set
+# CONFIG_UDPSVD is not set
+
+#
+# Print Utilities
+#
+# CONFIG_LPD is not set
+# CONFIG_LPR is not set
+# CONFIG_LPQ is not set
+
+#
+# Mail Utilities
+#
+# CONFIG_MAKEMIME is not set
+CONFIG_FEATURE_MIME_CHARSET=""
+# CONFIG_POPMAILDIR is not set
+# CONFIG_FEATURE_POPMAILDIR_DELIVERY is not set
+# CONFIG_REFORMIME is not set
+# CONFIG_FEATURE_REFORMIME_COMPAT is not set
+# CONFIG_SENDMAIL is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+# CONFIG_FUSER is not set
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+# CONFIG_KILLALL5 is not set
+# CONFIG_NMETER is not set
+# CONFIG_PGREP is not set
+# CONFIG_PIDOF is not set
+# CONFIG_FEATURE_PIDOF_SINGLE is not set
+# CONFIG_FEATURE_PIDOF_OMIT is not set
+# CONFIG_PKILL is not set
+CONFIG_PS=y
+# CONFIG_FEATURE_PS_WIDE is not set
+# CONFIG_FEATURE_PS_TIME is not set
+# CONFIG_FEATURE_PS_ADDITIONAL_COLUMNS is not set
+# CONFIG_FEATURE_PS_UNUSUAL_SYSTEMS is not set
+# CONFIG_RENICE is not set
+# CONFIG_BB_SYSCTL is not set
+CONFIG_TOP=y
+CONFIG_FEATURE_TOP_CPU_USAGE_PERCENTAGE=y
+CONFIG_FEATURE_TOP_CPU_GLOBAL_PERCENTS=y
+# CONFIG_FEATURE_TOP_SMP_CPU is not set
+# CONFIG_FEATURE_TOP_DECIMALS is not set
+# CONFIG_FEATURE_TOP_SMP_PROCESS is not set
+# CONFIG_FEATURE_TOPMEM is not set
+# CONFIG_UPTIME is not set
+# CONFIG_WATCH is not set
+
+#
+# Runit Utilities
+#
+# CONFIG_RUNSV is not set
+# CONFIG_RUNSVDIR is not set
+# CONFIG_FEATURE_RUNSVDIR_LOG is not set
+# CONFIG_SV is not set
+CONFIG_SV_DEFAULT_SERVICE_DIR=""
+# CONFIG_SVLOGD is not set
+# CONFIG_CHPST is not set
+# CONFIG_SETUIDGID is not set
+# CONFIG_ENVUIDGID is not set
+# CONFIG_ENVDIR is not set
+# CONFIG_SOFTLIMIT is not set
+# CONFIG_CHCON is not set
+# CONFIG_FEATURE_CHCON_LONG_OPTIONS is not set
+# CONFIG_GETENFORCE is not set
+# CONFIG_GETSEBOOL is not set
+# CONFIG_LOAD_POLICY is not set
+# CONFIG_MATCHPATHCON is not set
+# CONFIG_RESTORECON is not set
+# CONFIG_RUNCON is not set
+# CONFIG_FEATURE_RUNCON_LONG_OPTIONS is not set
+# CONFIG_SELINUXENABLED is not set
+# CONFIG_SETENFORCE is not set
+# CONFIG_SETFILES is not set
+# CONFIG_FEATURE_SETFILES_CHECK_OPTION is not set
+# CONFIG_SETSEBOOL is not set
+# CONFIG_SESTATUS is not set
+
+#
+# Shells
+#
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_ASH=y
+CONFIG_ASH_BASH_COMPAT=y
+CONFIG_ASH_JOB_CONTROL=y
+# CONFIG_ASH_READ_NCHARS is not set
+# CONFIG_ASH_READ_TIMEOUT is not set
+# CONFIG_ASH_ALIAS is not set
+# CONFIG_ASH_GETOPTS is not set
+CONFIG_ASH_BUILTIN_ECHO=y
+# CONFIG_ASH_BUILTIN_PRINTF is not set
+# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_ASH_EXPAND_PRMT is not set
+# CONFIG_HUSH is not set
+# CONFIG_HUSH_BASH_COMPAT is not set
+# CONFIG_HUSH_HELP is not set
+# CONFIG_HUSH_INTERACTIVE is not set
+# CONFIG_HUSH_JOB is not set
+# CONFIG_HUSH_TICK is not set
+# CONFIG_HUSH_IF is not set
+# CONFIG_HUSH_LOOPS is not set
+# CONFIG_HUSH_CASE is not set
+# CONFIG_HUSH_FUNCTIONS is not set
+# CONFIG_HUSH_LOCAL is not set
+# CONFIG_HUSH_EXPORT_N is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+CONFIG_SH_MATH_SUPPORT=y
+CONFIG_SH_MATH_SUPPORT_64=y
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE is not set
+# CONFIG_FEATURE_SH_NOFORK is not set
+# CONFIG_CTTYHACK is not set
+
+#
+# System Logging Utilities
+#
+CONFIG_SYSLOGD=y
+CONFIG_FEATURE_ROTATE_LOGFILE=y
+# CONFIG_FEATURE_REMOTE_LOG is not set
+# CONFIG_FEATURE_SYSLOGD_DUP is not set
+# CONFIG_FEATURE_IPC_SYSLOG is not set
+CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE=0
+# CONFIG_LOGREAD is not set
+# CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING is not set
+# CONFIG_KLOGD is not set
+# CONFIG_LOGGER is not set
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/include/applets.h apps_1.2/busybox-1.15.0/include/applets.h
--- apps/busybox-1.15.0/include/applets.h	2014-05-30 03:41:18.471250874 -0700
+++ apps_1.2/busybox-1.15.0/include/applets.h	2014-05-30 03:43:44.084943563 -0700
@@ -1,5 +1,23 @@
 /* vi: set sw=4 ts=4: */
 /*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */
+/*
  * applets.h - a listing of all busybox applets.
  *
  * If you write a new applet, you need to add an entry to this list to make
@@ -145,8 +163,10 @@
 IF_ENVDIR(APPLET_ODDNAME(envdir, chpst, _BB_DIR_USR_BIN, _BB_SUID_DROP, envdir))
 IF_ENVUIDGID(APPLET_ODDNAME(envuidgid, chpst, _BB_DIR_USR_BIN, _BB_SUID_DROP, envuidgid))
 IF_ETHER_WAKE(APPLET_ODDNAME(ether-wake, ether_wake, _BB_DIR_USR_BIN, _BB_SUID_DROP, ether_wake))
+IF_ETHREG(APPLET(ethreg, _BB_DIR_BIN, _BB_SUID_DROP))
 IF_EXPAND(APPLET(expand, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_EXPR(APPLET(expr, _BB_DIR_USR_BIN, _BB_SUID_DROP))
+IF_FACTORYRESET(APPLET(factoryreset, _BB_DIR_BIN, _BB_SUID_DROP))
 IF_FAKEIDENTD(APPLET(fakeidentd, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
 IF_FALSE(APPLET_NOFORK(false, false, _BB_DIR_BIN, _BB_SUID_DROP, false))
 IF_FBSET(APPLET(fbset, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
@@ -159,6 +179,7 @@
 IF_FINDFS(APPLET(findfs, _BB_DIR_SBIN, _BB_SUID_MAYBE))
 IF_FLASH_ERASEALL(APPLET(flash_eraseall, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
 IF_FLASH_LOCK(APPLET_ODDNAME(flash_lock, flash_lock_unlock, _BB_DIR_USR_SBIN, _BB_SUID_DROP, flash_lock))
+//IF_FLASH_MAC(APPLET(flash_mac, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_FLASH_UNLOCK(APPLET_ODDNAME(flash_unlock, flash_lock_unlock, _BB_DIR_USR_SBIN, _BB_SUID_DROP, flash_unlock))
 IF_FOLD(APPLET(fold, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_FREE(APPLET(free, _BB_DIR_USR_BIN, _BB_SUID_DROP))
@@ -252,6 +273,7 @@
 IF_MAKEMIME(APPLET(makemime, _BB_DIR_BIN, _BB_SUID_DROP))
 IF_MAN(APPLET(man, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_MATCHPATHCON(APPLET(matchpathcon, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
+IF_MDMM(APPLET(md, _BB_DIR_BIN, _BB_SUID_DROP))
 IF_MD5SUM(APPLET_ODDNAME(md5sum, md5_sha1_sum, _BB_DIR_USR_BIN, _BB_SUID_DROP, md5sum))
 IF_MDEV(APPLET(mdev, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_MESG(APPLET(mesg, _BB_DIR_USR_BIN, _BB_SUID_DROP))
@@ -268,6 +290,7 @@
 IF_CRYPTPW(APPLET_ODDNAME(mkpasswd, cryptpw, _BB_DIR_USR_BIN, _BB_SUID_DROP, mkpasswd))
 IF_MKSWAP(APPLET(mkswap, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_MKTEMP(APPLET(mktemp, _BB_DIR_BIN, _BB_SUID_DROP))
+IF_MDMM(APPLET(mm, _BB_DIR_BIN, _BB_SUID_DROP))
 IF_MODPROBE(APPLET(modprobe, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_MODPROBE_SMALL(APPLET(modprobe, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_MORE(APPLET(more, _BB_DIR_BIN, _BB_SUID_DROP))
@@ -288,6 +311,7 @@
 //IF_PARSE(APPLET(parse, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_PASSWD(APPLET(passwd, _BB_DIR_USR_BIN, _BB_SUID_REQUIRE))
 IF_PATCH(APPLET(patch, _BB_DIR_USR_BIN, _BB_SUID_DROP))
+//IF_PEEK(APPLET(peek, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_PGREP(APPLET(pgrep, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_PIDOF(APPLET(pidof, _BB_DIR_BIN, _BB_SUID_DROP))
 IF_PING(APPLET(ping, _BB_DIR_BIN, _BB_SUID_MAYBE))
@@ -366,6 +390,7 @@
 IF_SUM(APPLET(sum, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_SV(APPLET(sv, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_SVLOGD(APPLET(svlogd, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
+//IF_SW_RESET(APPLET(sw_reset, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_SWAPONOFF(APPLET_ODDNAME(swapoff, swap_on_off, _BB_DIR_SBIN, _BB_SUID_DROP,swapoff))
 IF_SWAPONOFF(APPLET_ODDNAME(swapon, swap_on_off, _BB_DIR_SBIN, _BB_SUID_DROP, swapon))
 IF_SWITCH_ROOT(APPLET(switch_root, _BB_DIR_SBIN, _BB_SUID_DROP))
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/include/athrs_ctrl.h apps_1.2/busybox-1.15.0/include/athrs_ctrl.h
--- apps/busybox-1.15.0/include/athrs_ctrl.h	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.15.0/include/athrs_ctrl.h	2014-05-30 03:43:44.084943563 -0700
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+#ifndef ATHRS_CTRL_H
+#define ATHRS_CTRL_H
+
+/* Ioctl subroutines */
+#define ATHR_GMAC_QOS_CTRL_IOC      (SIOCDEVPRIVATE | 0x01)
+#define ATHR_GMAC_CTRL_IOC          (SIOCDEVPRIVATE | 0x02)
+#define ATHR_PHY_CTRL_IOC           (SIOCDEVPRIVATE | 0x03)
+#define ATHR_VLAN_IGMP_IOC          (SIOCDEVPRIVATE | 0x04)
+#define ATHR_HW_ACL_IOC             (SIOCDEVPRIVATE | 0x05)
+
+/* 
+ *GMAC_CTRL_IOC_COMMANDS
+ */
+#define ATHR_GMAC_TX_FLOW_CTRL            ((ATHR_GMAC_CTRL_IOC << 16) | 0x1)
+#define ATHR_GMAC_RX_FLOW_CTRL            ((ATHR_GMAC_CTRL_IOC << 16) | 0x2)
+#define ATHR_GMAC_DMA_CHECK               ((ATHR_GMAC_CTRL_IOC << 16) | 0x3)
+#define ATHR_GMAC_SOFT_LED_BLINK          ((ATHR_GMAC_CTRL_IOC << 16) | 0x4)
+#define ATHR_GMAC_SW_ONLY_MODE            ((ATHR_GMAC_CTRL_IOC << 16) | 0x5)
+#define ATHR_GMAC_STATS                   ((ATHR_GMAC_CTRL_IOC << 16) | 0x6)
+#define ATHR_JUMBO_FRAME                  ((ATHR_GMAC_CTRL_IOC << 16) | 0x7)
+#define ATHR_FRAME_SIZE_CTL               ((ATHR_GMAC_CTRL_IOC << 16) | 0x8)
+
+/*
+ *PHY_CTRL_COMMANDS
+ */
+#define ATHR_PHY_FORCE           ((ATHR_PHY_CTRL_IOC << 16) | 0x1)
+#define ATHR_PHY_RD              ((ATHR_PHY_CTRL_IOC << 16) | 0x2)
+#define ATHR_PHY_WR              ((ATHR_PHY_CTRL_IOC << 16) | 0x3)
+#define ATHR_PHY_MIB             ((ATHR_PHY_CTRL_IOC << 16) | 0X4)
+#define ATHR_PHY_STATS           ((ATHR_PHY_CTRL_IOC << 16) | 0X5)
+#define ATHR_PORT_STATS          ((ATHR_PHY_CTRL_IOC << 16) | 0X6)
+#define ATHR_PORT_LINK           ((ATHR_PHY_CTRL_IOC << 16) | 0x7)
+#define ATHR_FLOW_LINK_EN        ((ATHR_PHY_CTRL_IOC << 16) | 0x8)
+#define ATHR_PHY_RXFCTL          ((ATHR_PHY_CTRL_IOC << 16) | 0x9)
+#define ATHR_PHY_TXFCTL          ((ATHR_PHY_CTRL_IOC << 16) | 0x10)
+
+#define ATHR_PACKET_FLAG         ((ATHR_VLAN_IGMP_IOC << 16) | 0x1)
+#define ATHR_VLAN_ADDPORTS       ((ATHR_VLAN_IGMP_IOC << 16) | 0x2)
+#define ATHR_VLAN_DELPORTS       ((ATHR_VLAN_IGMP_IOC << 16) | 0x3)
+#define ATHR_VLAN_SETTAGMODE     ((ATHR_VLAN_IGMP_IOC << 16) | 0x4)
+#define ATHR_VLAN_SETDEFAULTID   ((ATHR_VLAN_IGMP_IOC << 16) | 0x5)
+#define ATHR_VLAN_ENABLE         ((ATHR_VLAN_IGMP_IOC << 16) | 0x6)
+#define ATHR_VLAN_DISABLE        ((ATHR_VLAN_IGMP_IOC << 16) | 0x7)
+#define ATHR_IGMP_ON_OFF         ((ATHR_VLAN_IGMP_IOC << 16) | 0x8)
+#define ATHR_LINK_GETSTAT        ((ATHR_VLAN_IGMP_IOC << 16) | 0x9)
+#define ATHR_ARL_ADD             ((ATHR_VLAN_IGMP_IOC << 16) | 0xa)
+#define ATHR_ARL_DEL             ((ATHR_VLAN_IGMP_IOC << 16) | 0xb)
+#define ATHR_MCAST_CLR           ((ATHR_VLAN_IGMP_IOC << 16) | 0xc)
+/*
+ * GMC_QOS_COMMANDS
+ */
+#define ATHR_QOS_ETH_SOFT_CLASS   ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x1)
+#define ATHR_QOS_ETH_PORT         ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x2)
+#define ATHR_QOS_ETH_VLAN         ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x3)
+#define ATHR_QOS_ETH_DA           ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x4)
+#define ATHR_QOS_ETH_IP           ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x5)
+#define ATHR_QOS_PORT_ILIMIT      ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x6)
+#define ATHR_QOS_PORT_ELIMIT      ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x7)
+#define ATHR_QOS_PORT_EQLIMIT     ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x8)
+#define MAX_QOS_COMMAND           ((ATHR_GMAC_QOS_CTRL_IOC << 16) | 0x9)
+
+/*
+ * ACL COMMANDS
+ */
+#define ATHR_ACL_COMMIT ((ATHR_HW_ACL_IOC << 16) | 0x1)
+#define ATHR_ACL_FLUSH  ((ATHR_HW_ACL_IOC << 16) | 0x2)
+
+
+struct rx_stats{
+        int rx_broad;
+        int rx_pause;
+        int rx_multi;
+        int rx_fcserr;
+        int rx_allignerr;
+        int rx_runt;
+        int rx_frag;
+        int rx_64b;
+        int rx_128b;
+        int rx_256b;
+        int rx_512b;
+        int rx_1024b;
+        int rx_1518b;
+        int rx_maxb;
+        int rx_tool;
+        int rx_goodbl;
+        int rx_goodbh;
+        int rx_overflow;
+        int rx_badbl;
+        int rx_badbu;
+};
+
+struct tx_stats{
+        int tx_broad;
+        int tx_pause;
+        int tx_multi;
+        int tx_underrun;
+        int tx_64b;
+        int tx_128b;
+        int tx_256b;
+        int tx_512b;
+        int tx_1024b;
+        int tx_1518b;
+        int tx_maxb;
+        int tx_oversiz;
+        int tx_bytel;
+        int tx_byteh;
+        int tx_collision;
+        int tx_abortcol;
+        int tx_multicol;
+        int tx_singalcol;
+        int tx_execdefer;
+        int tx_defer;
+        int tx_latecol;
+};
+
+struct tx_mac_stats {
+
+        int pkt_cntr;
+        int byte_cntr;
+        int mcast_cntr;
+        int bcast_cntr;
+        int pctrlframe_cntr;
+        int deferal_cntr;
+        int excess_deferal_cntr;
+        int single_col_cntr;
+        int multi_col_cntr;
+        int late_col_cntr;
+        int excess_col_cntr;
+        int total_col_cntr;
+        int honored_cntr;
+        int dropframe_cntr;
+        int jabberframe_cntr;
+        int fcserr_cntr;
+        int ctrlframe_cntr;
+        int oz_frame_cntr;
+        int us_frame_cntr;
+        int frag_frame_cntr;
+
+};
+
+struct rx_mac_stats {
+
+        int byte_cntr;
+        int pkt_cntr;
+        int fcserr_cntr;
+        int mcast_cntr;
+        int bcast_cntr;
+        int ctrlframe_cntr;
+        int pausefr_cntr;
+        int unknownop_cntr;
+        int allignerr_cntr;
+        int framelerr_cntr;
+        int codeerr_cntr;
+        int carriersenseerr_cntr;
+        int underszpkt_cntr;
+        int ozpkt_cntr;
+        int fragment_cntr;
+        int jabber_cntr;
+        int rcvdrop_cntr;
+};
+
+struct port_phy_state {
+    int link;
+    int fdx;
+    int speed;
+    int valid;
+};
+
+struct eth_cfg_params {
+     int  cmd;
+     char    ad_name[IFNAMSIZ];      /* if name, e.g. "eth0" */
+     uint16_t vlanid;
+     uint16_t portnum;
+     uint32_t phy_reg;
+     uint32_t tos;
+     uint32_t val;
+     uint8_t duplex;
+     uint8_t  mac_addr[6];
+     struct rx_stats rxcntr;
+     struct tx_stats txcntr;
+     struct tx_mac_stats txmac;
+     struct rx_mac_stats rxmac;
+     struct port_phy_state ppst;
+};
+#endif       //ATHR_CTRL_H
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/include/usage.h apps_1.2/busybox-1.15.0/include/usage.h
--- apps/busybox-1.15.0/include/usage.h	2014-05-30 03:41:18.479250966 -0700
+++ apps_1.2/busybox-1.15.0/include/usage.h	2014-05-30 03:43:44.084943563 -0700
@@ -1,5 +1,23 @@
 /* vi: set sw=8 ts=8: */
 /*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */
+/*
  * This file suffers from chronically incorrect tabification
  * of messages. Before editing this file:
  * 1. Switch you editor to 8-space tab mode.
@@ -191,28 +209,6 @@
      "\n	stp BRIDGE [1|0]		STP on/off" \
 	) \
 
-#define brctl_trivial_usage \
-	"COMMAND [OPTIONS]"
-#define brctl_full_usage \
-	"Create, delete and configue ethernet bridge.\n\n" \
-	"Commands:\n" \
-	"\taddbr\t\t<bridge>\t\tadd bridge\n" \
-	"\taddif\t\t<bridge> <device>\tadd interface to bridge\n" \
-	"\tdelbr\t\t<bridge>\t\tdelete bridge\n" \
-	"\tdelif\t\t<bridge> <device>\tdelete interface from bridge\n" \
-	"\tshow\t\t\t\t\tshow a list of bridges\n" \
-	"\tshowmacs\t<bridge>\t\tshow a list of mac addrs\n" \
-	"\tshowstp\t\t<bridge>\t\tshow bridge stp info\n" \
-	"\tsetageing\t<bridge> <time>\t\tset ageing time\n" \
-	"\tsetbridgeprio\t<bridge> <prio>\t\tset bridge priority\n" \
-	"\tsetfd\t\t<bridge> <time>\t\tset bridge forward delay\n" \
-	"\tsetgcint\t<bridge> <time>\t\tset garbage collection interval\n" \
-	"\tsethello\t<bridge> <time>\t\tset hello time\n" \
-	"\tsetmaxage\t<bridge> <time>\t\tset max message age\n" \
-	"\tsetpathcost\t<bridge> <port> <cost>\tset path cost\n" \
-	"\tsetportprio\t<bridge> <port> <prio>\tset port priority\n" \
-	"\tstp\t\t<bridge> <state>\tturn stp on/off\n"
-
 #define bunzip2_trivial_usage \
        "[OPTIONS] [FILE]"
 #define bunzip2_full_usage "\n\n" \
@@ -1090,6 +1086,26 @@
      "\n	-i iface	Interface to use (default eth0)" \
      "\n	-p pass		Append four or six byte password PW to the packet" \
 
+#define ethreg_trivial_usage \
+	"[-i ifname] [-p portnum] offset[=value]\n" \
+	"[-f]  portnum=10/100/0 [-d duplex]\n"
+#define ethreg_full_usage \
+	" Can be used to read/write both MAC and PHY registers\n" \
+	", to change the mode and speed settings for individual PHYs\n" \
+	"Options:\n" \
+	"\t[-i ifname] [-p portnum] offset[=value]\n" \
+	"\t[-f]  portnum=10/100/0 [-d duplex]\n"
+
+#define factoryreset_trivial_usage \
+	"fr device path "
+#define factoryreset_full_usage \
+	"Waits for the factory reset event from the kernel \n" \
+	"and restores the factory default configuration once \n" \
+	"user holds the jumpstart button for more \n" \
+	"than 3 seconds\n" \
+	"Options:\n" \
+	"\t<dev> -\tpath to the factory reset device \n"
+
 #define expand_trivial_usage \
        "[-i] [-t NUM] [FILE|-]"
 #define expand_full_usage "\n\n" \
@@ -1770,26 +1786,77 @@
        "$ id\n" \
        "uid=1000(andersen) gid=1000(andersen)\n"
 
+#ifdef CONFIG_FEATURE_IFCONFIG_VLAN_IGMP
 #define ifconfig_trivial_usage \
 	IF_FEATURE_IFCONFIG_STATUS("[-a]") " interface [address]"
 #define ifconfig_full_usage "\n\n" \
-       "Configure a network interface\n" \
-     "\nOptions:" \
-     "\n" \
+	"Configure a network interface\n" \
+	"\nOptions:" \
+	"\n" \
+	IF_FEATURE_IPV6( \
+	"	[add ADDRESS[/PREFIXLEN]]\n") \
+	IF_FEATURE_IPV6( \
+	"	[del ADDRESS[/PREFIXLEN]]\n") \
+	"	[[-]broadcast [ADDRESS]] [[-]pointopoint [ADDRESS]]\n" \
+	"	[netmask ADDRESS] [dstaddr ADDRESS]\n" \
+	IF_FEATURE_IFCONFIG_SLIP( \
+	"	[outfill NN] [keepalive NN]\n") \
+	"	" IF_FEATURE_IFCONFIG_HW("[hw ether" IF_FEATURE_HWIB("|infiniband")" ADDRESS] ") "[metric NN] [mtu NN]\n" \
+	"	[[-]trailers] [[-]arp] [[-]allmulti]\n" \
+	"	[multicast] [[-]promisc] [txqueuelen NN] [[-]dynamic]\n" \
+	IF_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ( \
+	"	[mem_start NN] [io_addr NN] [irq NN]\n") \
+	"	[up|down] ...\n" \
+	"\t[addports|delports] <vlan-id> <ports> -----add/del ports to/from the given vlan-id.\n" \
+	"\t[igmpon|igmpoff] <vlan-id> -----turn on/off the igmp snoop for the given vlan-id.\n" \
+	"\t[setid|setmode] <vlan-id> <portno> -----set an default vlan-id (egress mode) for the given port" \
+	"\t[getstat] <portno> ---- get the status of the link for the given port.\n" \
+	"\t[startvlan |stopvlan]---- please start vlan before you want to start a vlan.\n" \
+	"\tports: bit0->port0,bit1->port1 ... \n" \
+	"\tmode: 0->unmodified,1->untagged,2->tagged \n" \
+	"\tgetstat: portno [1-5];return 0--> down,1-->up \n"
+
+#else
+#define ifconfig_trivial_usage \
+	IF_FEATURE_IFCONFIG_STATUS("[-a]") " interface [address]"
+#define ifconfig_full_usage "\n\n" \
+	"Configure a network interface\n" \
+	"\nOptions:" \
+	"\n" \
 	IF_FEATURE_IPV6( \
-       "	[add ADDRESS[/PREFIXLEN]]\n") \
+	"	[add ADDRESS[/PREFIXLEN]]\n") \
 	IF_FEATURE_IPV6( \
-       "	[del ADDRESS[/PREFIXLEN]]\n") \
-       "	[[-]broadcast [ADDRESS]] [[-]pointopoint [ADDRESS]]\n" \
-       "	[netmask ADDRESS] [dstaddr ADDRESS]\n" \
+	"	[del ADDRESS[/PREFIXLEN]]\n") \
+	"	[[-]broadcast [ADDRESS]] [[-]pointopoint [ADDRESS]]\n" \
+	"	[netmask ADDRESS] [dstaddr ADDRESS]\n" \
 	IF_FEATURE_IFCONFIG_SLIP( \
-       "	[outfill NN] [keepalive NN]\n") \
-       "	" IF_FEATURE_IFCONFIG_HW("[hw ether" IF_FEATURE_HWIB("|infiniband")" ADDRESS] ") "[metric NN] [mtu NN]\n" \
-       "	[[-]trailers] [[-]arp] [[-]allmulti]\n" \
-       "	[multicast] [[-]promisc] [txqueuelen NN] [[-]dynamic]\n" \
+	"	[outfill NN] [keepalive NN]\n") \
+	"	" IF_FEATURE_IFCONFIG_HW("[hw ether" IF_FEATURE_HWIB("|infiniband")" ADDRESS] ") "[metric NN] [mtu NN]\n" \
+	"	[[-]trailers] [[-]arp] [[-]allmulti]\n" \
+	"	[multicast] [[-]promisc] [txqueuelen NN] [[-]dynamic]\n" \
 	IF_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ( \
-       "	[mem_start NN] [io_addr NN] [irq NN]\n") \
-       "	[up|down] ..."
+	"	[mem_start NN] [io_addr NN] [irq NN]\n") \
+	"	[up|down] ..."
+#endif
+
+#define peek_trivial_usage "peek <addr> <len>\n"
+#define peek_full_usage "peek <addr> <len>\n"
+
+#define sw_reset_trivial_usage "reset board\n"
+
+#define sw_reset_full_usage \
+	"resets board if pressed for less than 4\n" \
+	"If pressed for more than 4 seconds reinstalls default configuration\n"
+
+
+#define flash_mac_trivial_usage "flash_mac sets MAC addr\n"
+#define flash_mac_full_usage "flash_mac sets MAC addr\n"
+
+#define md_trivial_usage "md <addr> <len>\n"
+#define md_full_usage "md <addr> <len>\n"
+
+#define mm_trivial_usage "mm <addr> <len>\n"
+#define mm_full_usage "mm <addr> <len>\n"
 
 #define ifenslave_trivial_usage \
        "[-cdf] master-iface <slave-iface...>"
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/init/init.c apps_1.2/busybox-1.15.0/init/init.c
--- apps/busybox-1.15.0/init/init.c	2014-05-30 03:41:18.483251012 -0700
+++ apps_1.2/busybox-1.15.0/init/init.c	2014-05-30 03:43:44.092943656 -0700
@@ -5,6 +5,7 @@
  * Copyright (C) 1995, 1996 by Bruce Perens <bruce@pixar.com>.
  * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
  * Adjusted by so many folks, it's impossible to keep track.
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  *
  * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  */
@@ -720,7 +721,9 @@
 		 * Thus don't need to worry about preserving errno
 		 * and such.
 		 */
+		dbg_message(L_CONSOLE, "Restart! -- shutdown now.");
 		run_shutdown_and_kill_processes();
+		dbg_message(L_CONSOLE, "Restart! -- shutdown done.");
 
 		/* Allow Ctrl-Alt-Del to reboot the system.
 		 * This is how kernel sets it up for init, we follow suit.
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/libbb/safe_strncpy.c apps_1.2/busybox-1.15.0/libbb/safe_strncpy.c
--- apps/busybox-1.15.0/libbb/safe_strncpy.c	2014-05-30 03:41:18.507251291 -0700
+++ apps_1.2/busybox-1.15.0/libbb/safe_strncpy.c	2014-05-30 03:43:44.108943842 -0700
@@ -3,6 +3,7 @@
  * Utility routines.
  *
  * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  *
  * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  */
@@ -25,3 +26,61 @@
 		src++;
 	}
 }
+
+extern
+int safe_strtoi(char *arg, int* value)
+{
+    int error;
+    long lvalue = *value;
+    error = safe_strtol(arg, &lvalue);
+    *value = (int) lvalue;
+    return error;
+}
+
+extern
+int safe_strtoul(char *arg, unsigned long* value)
+{
+    char *endptr;
+    int errno_save = errno;
+//    assert(arg!=NULL);
+    errno = 0;
+    *value = strtoul(arg, &endptr, 0);
+    if (errno != 0 || *endptr!='\0' || endptr==arg) {
+        return 1;
+    }
+    errno = errno_save;
+    return 0;
+}
+
+extern
+int safe_strtod(char *arg, double* value)
+{
+   char *endptr;
+   int errno_save = errno;
+//   assert(arg!=NULL);
+   errno = 0;
+   *value = strtod(arg, &endptr);
+   if (errno != 0 || *endptr!='\0' || endptr==arg) {
+       return 1;
+   }
+   errno = errno_save;
+   return 0;
+}
+
+extern
+int safe_strtol(char *arg, long* value)
+{
+    char *endptr;
+    int errno_save = errno;
+
+//    assert(arg!=NULL);
+    errno = 0;
+    *value = strtol(arg, &endptr, 0);
+    if (errno != 0 || *endptr!='\0' || endptr==arg) {
+        return 1;
+    }
+    errno = errno_save;
+    return 0;
+}
+
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/loginutils/Config.in apps_1.2/busybox-1.15.0/loginutils/Config.in
--- apps/busybox-1.15.0/loginutils/Config.in	2014-05-30 03:41:18.515251384 -0700
+++ apps_1.2/busybox-1.15.0/loginutils/Config.in	2014-05-30 03:43:44.076943469 -0700
@@ -1,4 +1,22 @@
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+#
+
+#
 # For a description of the syntax of this configuration file,
 # see scripts/kbuild/config-language.txt.
 #
@@ -208,6 +226,13 @@
 	  Note that Busybox binary must be setuid root for this applet to
 	  work properly.
 
+config REMOTE_LOGIN_RESTRICT
+	bool "Support restrict for remote login"
+	default n
+	depends on LOGIN
+	help
+	  Set allowed remote user's username into /etc/remoteuser.
+
 config PAM
 	bool "Support for PAM (Pluggable Authentication Modules)"
 	default n
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/loginutils/login.c apps_1.2/busybox-1.15.0/loginutils/login.c
--- apps/busybox-1.15.0/loginutils/login.c	2014-05-30 03:41:18.519251431 -0700
+++ apps_1.2/busybox-1.15.0/loginutils/login.c	2014-05-30 03:43:44.076943469 -0700
@@ -1,6 +1,22 @@
 /* vi: set sw=4 ts=4: */
+
 /*
- * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
  */
 
 #include "libbb.h"
@@ -287,6 +303,9 @@
 	char *full_tty;
 	IF_SELINUX(security_context_t user_sid = NULL;)
 	IF_FEATURE_UTMP(struct utmp utent;)
+#if ENABLE_REMOTE_LOGIN_RESTRICT
+	FILE *fp_remote_user;
+#endif
 #if ENABLE_PAM
 	int pamret;
 	pam_handle_t *pamh;
@@ -350,7 +369,31 @@
 
 		if (!username[0])
 			get_username_or_die(username, sizeof(username));
+#if ENABLE_REMOTE_LOGIN_RESTRICT
+		if(strstr(short_tty, "pts"))
+		{
+			if((fp_remote_user = fopen("/etc/remoteuser", "r")))
+			{
+				char buf[100];
+				while(fgets(buf, sizeof(buf), fp_remote_user))
+				{
+					if('\n' == buf[strlen(buf) - 1])
+						buf[strlen(buf) - 1] = '\0';
+					if(!strcmp(buf, username))
+					{
+						fclose(fp_remote_user);
+						goto remote_login_chk_pass;
+					}
+				}
 
+				fclose(fp_remote_user);
+			}
+
+			goto auth_failed;
+		}
+			
+remote_login_chk_pass:
+#endif
 #if ENABLE_PAM
 		pamret = pam_start("login", username, &conv, &pamh);
 		if (pamret != PAM_SUCCESS) {
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/Makefile apps_1.2/busybox-1.15.0/Makefile
--- apps/busybox-1.15.0/Makefile	2014-05-30 03:41:18.263248460 -0700
+++ apps_1.2/busybox-1.15.0/Makefile	2014-05-30 03:43:44.100943749 -0700
@@ -1,3 +1,21 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+#
+
 VERSION = 1
 PATCHLEVEL = 15
 SUBLEVEL = 0
@@ -463,6 +481,7 @@
 		networking/ \
 		networking/libiproute/ \
 		networking/udhcp/ \
+		networking/libbridge/ \
 		printutils/ \
 		procps/ \
 		runit/ \
@@ -474,6 +493,14 @@
 
 endif # KBUILD_EXTMOD
 
+ifeq ($(BOARD_TYPE), ap71)
+DIRS:=$(DIRS) ../ap71/flash_mac ../ap71/peek ../ap71/sw_reset
+else
+ifeq ($(BOARD_TYPE), ob42)
+DIRS:=$(DIRS) ../ap71/flash_mac
+endif
+endif
+
 ifeq ($(dot-config),1)
 # In this section, we need .config
 
@@ -935,7 +962,7 @@
 
 # Directories & files removed with 'make clean'
 CLEAN_DIRS  += $(MODVERDIR) _install 0_lib
-CLEAN_FILES +=	busybox busybox_unstripped* busybox.links \
+CLEAN_FILES +=	busybox busybox_unstripped* busybox.links .config \
                 System.map .kernelrelease \
                 .tmp_kallsyms* .tmp_version .tmp_busybox* .tmp_System.map
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/Makefile.flags apps_1.2/busybox-1.15.0/Makefile.flags
--- apps/busybox-1.15.0/Makefile.flags	2014-05-30 03:41:18.263248460 -0700
+++ apps_1.2/busybox-1.15.0/Makefile.flags	2014-05-30 03:43:44.112943889 -0700
@@ -1,3 +1,21 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+#
+
 # ==========================================================================
 # Build system
 # ==========================================================================
@@ -10,7 +28,7 @@
 CPPFLAGS += $(call cc-option,-std=gnu99,)
 
 CPPFLAGS += \
-	-Iinclude -Ilibbb \
+	-Iinclude -Ilibbb -I$(srctree)/../ethctl\
 	$(if $(KBUILD_SRC),-Iinclude2 -I$(srctree)/include -I$(srctree)/libbb) \
 	-include include/autoconf.h \
 	-D_GNU_SOURCE -DNDEBUG \
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/miscutils/Config.in apps_1.2/busybox-1.15.0/miscutils/Config.in
--- apps/busybox-1.15.0/miscutils/Config.in	2014-05-30 03:41:18.523251477 -0700
+++ apps_1.2/busybox-1.15.0/miscutils/Config.in	2014-05-30 03:43:44.112943889 -0700
@@ -1,4 +1,22 @@
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+#
+
+#
 # For a description of the syntax of this configuration file,
 # see scripts/kbuild/config-language.txt.
 #
@@ -623,4 +641,26 @@
 	  certain amount of time, the watchdog device assumes the system has
 	  hung, and will cause the hardware to reboot.
 
+config FACTORYRESET
+	bool "Factory reset"
+	default n
+	help
+	  The factory reset utility will restore the configuration files to
+	  the default factory settings and will reboot the board if the factory
+	  reset/jumpstart button is held for more than 3 seconds.
+
+config ETHREG
+	bool "Ethreg Utility"
+	default n
+	help
+	  The ethreg utility can be used to read/write MAC and PHY registers
+	  to change the duplex and speed setting for individual PHYS.
+
+config MDMM
+	bool "MDMM Utility"
+	default n
+	help
+	  The md/mm utility can be used to read/write memory and memory
+	  mapped registers.
+
 endmenu
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/miscutils/ethreg.c apps_1.2/busybox-1.15.0/miscutils/ethreg.c
--- apps/busybox-1.15.0/miscutils/ethreg.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.15.0/miscutils/ethreg.c	2014-05-30 03:43:44.112943889 -0700
@@ -0,0 +1,747 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <getopt.h>
+#include <errno.h>
+#include <err.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <net/if.h>
+#include <fcntl.h>
+#include "busybox.h"
+#include <athrs_ctrl.h>
+
+struct ifreq ifr;
+struct eth_cfg_params etd;
+int s,opt_force = 0,duplex = 1;
+const char *progname;
+static void rx_stats(void)
+{
+        //printf ("\n\n%s\n", __func__);
+        printf ("\t%d\t port%d :Rx bcast cntr\n", etd.rxcntr.rx_broad, etd.portnum);
+        printf ("\t%d\t port%d :Rx pause cntr\n", etd.rxcntr.rx_pause, etd.portnum);
+        printf ("\t%d\t port%d :Rx multi frames rcvd\n", etd.rxcntr.rx_multi, etd.portnum);
+        printf ("\t%d\t port%d :Rx fcs err cntr\n", etd.rxcntr.rx_fcserr,  etd.portnum);
+        printf ("\t%d\t port%d :Rx allign err cntr\n", etd.rxcntr.rx_allignerr, etd.portnum);
+        printf ("\t%d\t port%d :Rx runt cntr \n", etd.rxcntr.rx_runt, etd.portnum);
+        printf ("\t%d\t port%d :Rx fragment cntr\n", etd.rxcntr.rx_frag, etd.portnum);
+        printf ("\t%d\t port%d :Rx 64b byte cntr\n", etd.rxcntr.rx_64b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 128b byte cntr\n", etd.rxcntr.rx_128b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 256b byte cntr\n", etd.rxcntr.rx_256b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 512b byte cntr\n", etd.rxcntr.rx_512b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 1024b byte cntr\n", etd.rxcntr.rx_1024b, etd.portnum);
+        printf ("\t%d\t port%d :Rx 1518b byte cntr\n ", etd.rxcntr.rx_1518b, etd.portnum);
+        printf ("\t%d\t port%d :Rx total pkt rcvd\n", (etd.rxcntr.rx_64b + etd.rxcntr.rx_128b + etd.rxcntr.rx_256b +
+                                etd.rxcntr.rx_512b + etd.rxcntr.rx_1024b + etd.rxcntr.rx_1518b), etd.portnum);
+        printf ("\t%d\t port%d :Rx maxb cntr\n", etd.rxcntr.rx_maxb, etd.portnum);
+        printf ("\t%d\t port%d :Rx too long cntr\n", etd.rxcntr.rx_tool, etd.portnum);
+        printf ("\t%d\t port%d :Rx byte_l\n", etd.rxcntr.rx_goodbl, etd.portnum);
+        printf ("\t%d\t port%d :Rx byte_h\n", etd.rxcntr.rx_goodbh, etd.portnum);
+        printf ("\t%d\t port%d :Rx overflow cntr\n", etd.rxcntr.rx_overflow, etd.portnum);
+        printf ("\t%d\t port%d :Rx bad byte_l cntr\n", etd.rxcntr.rx_badbl, etd.portnum);
+        printf ("\t%d\t port%d :Rx bad byte_u cntr\n", etd.rxcntr.rx_badbu, etd.portnum);
+}
+
+static void tx_stats(void)
+{
+        printf ("\n\n%s\n", __func__);
+        printf ("\t%d\t port%d : Tx bcast cntr \n", etd.txcntr.tx_broad, etd.portnum);
+        printf ("\t%d\t port%d : Tx pause cntr\n", etd.txcntr.tx_pause, etd.portnum);
+        printf ("\t%d\t port%d : Tx multi cntr\n", etd.txcntr.tx_multi, etd.portnum);
+        printf ("\t%d\t port%d : Tx under run cntr\n", etd.txcntr.tx_underrun, etd.portnum);
+        printf ("\t%d\t port%d : Tx 64b byte cntr\n", etd.txcntr.tx_64b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 128b byte cntr\n", etd.txcntr.tx_128b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 256b byte cntr\n", etd.txcntr.tx_256b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 512b byte cntr\n", etd.txcntr.tx_512b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 1024b byte cntr\n", etd.txcntr.tx_1024b, etd.portnum);
+        printf ("\t%d\t port%d : Tx 1518b byte cntr\n", etd.txcntr.tx_1518b, etd.portnum);
+        printf ("\t%d\t port%d : Tx total pkt txmtd cntr\n", (etd.txcntr.tx_64b + etd.txcntr.tx_128b
+                                      + etd.txcntr.tx_256b+ etd.txcntr.tx_512b + etd.txcntr.tx_1024b
+                                      + etd.txcntr.tx_1518b), etd.portnum);
+        printf ("\t%d\t port%d : Tx max byte cntr\n", etd.txcntr.tx_maxb, etd.portnum);
+        printf ("\t%d\t port%d : Tx oversize \n", etd.txcntr.tx_oversiz, etd.portnum);
+        printf ("\t%d\t port%d : Tx byte _l \n", etd.txcntr.tx_bytel, etd.portnum);
+        printf ("\t%d\t port%d : Tx byte _h \n", etd.txcntr.tx_byteh, etd.portnum);
+        printf ("\t%d\t port%d : Tx collision err cntr\n", etd.txcntr.tx_collision, etd.portnum);
+        printf ("\t%d\t port%d : Tx abort collision err cntr\n", etd.txcntr.tx_abortcol, etd.portnum);
+        printf ("\t%d\t port%d : Tx multi collision err cntr\n", etd.txcntr.tx_multicol, etd.portnum);
+        printf ("\t%d\t port%d : Tx single collision err cntr\n", etd.txcntr.tx_singalcol, etd.portnum);
+        printf ("\t%d\t port%d : Tx exec deffer err cntr\n", etd.txcntr.tx_execdefer, etd.portnum);
+        printf ("\t%d\t port%d : Tx defer err cntr\n", etd.txcntr.tx_defer, etd.portnum);
+        printf ("\t%d\t port%d : Tx late collision err cntr\n", etd.txcntr.tx_latecol, etd.portnum);
+
+}
+static void tx_mac_stats(void)
+{
+        printf ("\n\n%s\n", __func__);
+        printf ("\t%d\t : Tx pkt cntr\n", etd.txmac.pkt_cntr);
+        printf ("\t%d\t : Tx byte cntr\n", etd.txmac.byte_cntr);
+        printf ("\t%d\t : Tx mcast pkt cntr\n", etd.txmac.mcast_cntr);
+        printf ("\t%d\t : Tx bcast pkt cntr\n", etd.txmac.bcast_cntr);
+        printf ("\t%d\t : Tx pause frame pkt cntr\n", etd.txmac.pctrlframe_cntr);
+        printf ("\t%d\t : Tx deferal pkt cntr\n", etd.txmac.deferal_cntr);
+        printf ("\t%d\t : Tx excessive deferal pkt cntr\n", etd.txmac.excess_deferal_cntr);
+        printf ("\t%d\t : Tx single collision pkt cntr\n", etd.txmac.single_col_cntr);
+        printf ("\t%d\t : Tx multiple collision pkt cntr\n", etd.txmac.multi_col_cntr);
+        printf ("\t%d\t : Tx late collision pkt cntr\n", etd.txmac.late_col_cntr);
+        printf ("\t%d\t : Tx excessive collison pkt cntr\n", etd.txmac.excess_col_cntr);
+        printf ("\t%d\t : Tx total collison pkt cntr\n", etd.txmac.total_col_cntr);
+        printf ("\t%d\t : Tx drop frame cntr\n", etd.txmac.dropframe_cntr);
+        printf ("\t%d\t : Tx jabber frame cntr\n", etd.txmac.jabberframe_cntr);
+        printf ("\t%d\t : Tx fcs err cntr\n", etd.txmac.fcserr_cntr);
+        printf ("\t%d\t : Tx control frame cntr\n", etd.txmac.ctrlframe_cntr);
+        printf ("\t%d\t : Tx oversize frame cntr\n", etd.txmac.oz_frame_cntr);
+        printf ("\t%d\t : Tx undersize frame cntr\n", etd.txmac.us_frame_cntr);
+        printf ("\t%d\t : Tx fragments frame cntr\n", etd.txmac.frag_frame_cntr);
+
+}
+static void rx_mac_stats (void)
+{
+        printf ("\n\n%s\n", __func__);
+        printf ("\t%d\t: Rx byte cntr\n", etd.rxmac.byte_cntr);
+        printf ("\t%d\t: Rx pkt cntr\n", etd.rxmac.pkt_cntr);
+        printf ("\t%d\t: Rx fcs err cntr\n", etd.rxmac.fcserr_cntr);
+        printf ("\t%d\t: Rx mcast pkt cntr\n", etd.rxmac.mcast_cntr);
+        printf ("\t%d\t: Rx bcast pkt cntr\n", etd.rxmac.bcast_cntr);
+        printf ("\t%d\t: Rx ctrl frame cntr\n", etd.rxmac.ctrlframe_cntr);
+        printf ("\t%d\t: Rx pause frame pkt cntr\n", etd.rxmac.pausefr_cntr);
+        printf ("\t%d\t: Rx unknown opcode cntr\n", etd.rxmac.unknownop_cntr);
+        printf ("\t%d\t: Rx alignment err cntr\n", etd.rxmac.allignerr_cntr);
+        printf ("\t%d\t: Rx frame length err cntr\n", etd.rxmac.framelerr_cntr);
+        printf ("\t%d\t: Rx code err cntr\n", etd.rxmac.codeerr_cntr);
+        printf ("\t%d\t: Rx carrier sense err cntr\n", etd.rxmac.carriersenseerr_cntr);
+        printf ("\t%d\t: Rx under sz pkt cntr\n", etd.rxmac.underszpkt_cntr);
+        printf ("\t%d\t: Rx over sz pkt cntr\n", etd.rxmac.ozpkt_cntr);
+        printf ("\t%d\t: Rx fragment cntr\n", etd.rxmac.fragment_cntr);
+        printf ("\t%d\t: Rx jabber cntr\n", etd.rxmac.jabber_cntr);
+        printf ("\t%d\t: RX drop cntr\n",etd.rxmac.rcvdrop_cntr);
+}
+
+
+
+u_int32_t
+regread(u_int32_t phy_reg,u_int16_t portno)
+{
+
+	etd.phy_reg = phy_reg;
+	etd.cmd     = ATHR_PHY_RD;
+	etd.portnum = portno;
+	if (ioctl(s,ATHR_PHY_CTRL_IOC, &ifr) < 0)
+        	err(1, etd.ad_name);
+    	return etd.val;
+}
+static void athr_en_jumboframe(int value)
+{
+	etd.cmd = ATHR_JUMBO_FRAME;
+	etd.val=value;
+	if (ioctl(s,ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+        	err(1,etd.ad_name);
+}
+static void athr_set_framesize(int sz)
+{
+	etd.cmd = ATHR_FRAME_SIZE_CTL;
+    	etd.val = sz;
+    	if (ioctl(s,ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+        	err(1,etd.ad_name);
+  
+}
+static void athr_commit_acl_rules(void)
+{
+	etd.cmd = ATHR_ACL_COMMIT;
+    	if (ioctl(s,ATHR_HW_ACL_IOC,&ifr) < 0)
+        	 err(1,etd.ad_name);
+  
+}
+static void athr_flush_acl_rules(void)
+{
+	etd.cmd = ATHR_ACL_FLUSH;
+    	if (ioctl(s,ATHR_HW_ACL_IOC,&ifr) < 0)
+        	err(1,etd.ad_name);
+}
+static void athr_flow_link (int portno, int val)
+{
+	etd.cmd = ATHR_FLOW_LINK_EN;
+	etd.val = val;
+	etd.portnum = portno;
+	if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+	       	err(1,etd.ad_name);
+}
+static void athr_txflctrl (int portno, int val)
+{
+	if (portno == 0x3f) {
+		etd.val = val; 
+        	etd.cmd = ATHR_GMAC_TX_FLOW_CTRL; 
+        if (ioctl (s, ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+        	printf("%s ioctl error\n",__func__);
+            
+    	} else { 
+        	etd.cmd		= ATHR_PHY_TXFCTL;
+        	etd.portnum 	= portno;
+		etd.val		= val; 
+        if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+            printf("%s ioctl error\n",__func__);
+              
+    	}
+    
+       
+}
+static void athr_rxflctrl (int portno, int val)
+{
+	if (portno == 0x3f) {
+		etd.val = val; 
+        	etd.cmd = ATHR_GMAC_RX_FLOW_CTRL; 
+        	if (ioctl (s, ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+            		printf("%s ioctl error\n",__func__);
+            
+    	} else { 
+        	etd.cmd	    = ATHR_PHY_RXFCTL;
+        	etd.portnum = portno;
+		etd.val	    = val; 
+        if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+            printf("%s ioctl error\n",__func__);
+              
+    }
+    
+       
+}
+static void athr_set_mib(int val)
+{
+	etd.cmd       = ATHR_PHY_MIB;
+        etd.portnum = 0x3f;
+	etd.val       = val;
+	if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+        	err(1, etd.ad_name);
+}
+static void athr_disp_stats(int portno)
+{
+	if (portno == 0x3f) {
+		etd.cmd = ATHR_GMAC_STATS;
+       		if (ioctl (s, ATHR_GMAC_CTRL_IOC, &ifr) < 0){
+           	err(1, etd.ad_name);
+		} else {
+			rx_mac_stats ();
+           		tx_mac_stats ();
+
+	}
+       
+   	} else {
+       		etd.cmd = ATHR_PHY_STATS;
+       		etd.portnum = portno;
+       		if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+           		err(1, etd.ad_name);
+        	else{
+            		rx_stats ();
+            		tx_stats ();
+
+       		}
+   	}
+	
+}
+static void athr_dma_check(int val)
+{
+	etd.cmd = ATHR_GMAC_DMA_CHECK;
+	etd.val = val;
+    	if (ioctl (s, ATHR_GMAC_CTRL_IOC, &ifr) < 0)
+		err(1, etd.ad_name);
+    
+}
+
+static void athr_set_qos(int val)
+{
+	etd.cmd = ATHR_QOS_ETH_SOFT_CLASS;
+	etd.val = val;
+	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+}
+static void athr_set_port_pri(int portno, int val)
+{
+	etd.cmd     = ATHR_QOS_ETH_PORT;
+   	etd.portnum = portno;
+   	etd.val     = val;
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+      
+}
+static void athr_ip_qos (int tos, int val)
+{
+	etd.cmd = ATHR_QOS_ETH_IP;
+   	etd.val = val;
+   	etd.tos = tos;
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+        	err (1, etd.ad_name);
+       
+}
+static void athr_vlan_qos (int vlan_id, int val)
+{
+	etd.cmd    = ATHR_QOS_ETH_VLAN;
+   	etd.val    = val;
+   	etd.vlanid = vlan_id;
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+      
+}
+static void athr_mac_qos(int portno, int val, char *mac_addr)
+{
+	etd.cmd     = ATHR_QOS_ETH_DA;
+   	etd.val     = val;
+   	etd.portnum = portno;
+   	sscanf (mac_addr, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+              &etd.mac_addr[0], &etd.mac_addr[1],
+              &etd.mac_addr[2], &etd.mac_addr[3],
+              &etd.mac_addr[4], &etd.mac_addr[5]);
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+       
+}
+
+static int athr_port_st(int portno)
+{
+#define MAX_SIZ 20
+    char str[][MAX_SIZ] = {"10Mbps","100Mbps","1000Mbps"};
+    char dup[][MAX_SIZ] = {"Half-duplex","Full-duplex"};
+    char lnk_al[][MAX_SIZ] = {"FALSE","TRUE"};
+	
+    etd.cmd     = ATHR_PORT_STATS;
+   	etd.portnum = portno;
+   	if (etd.portnum > 5 || etd.portnum == 0){
+       		printf ("port usage <1-5>\n");
+       		return -EINVAL;
+   	}
+   	if (ioctl (s, ATHR_PHY_CTRL_IOC, &ifr) < 0)
+       		err (1, etd.ad_name);
+    
+    if(etd.ppst.valid != 0){
+        printf("Port %d status:\n",etd.portnum);
+        printf("\tLink_alive:\t%s\n\tMode:\t\t%s\n\tSpeed:\t\t%s\n\n",
+                 lnk_al[etd.ppst.link],dup[etd.ppst.fdx],str[etd.ppst.speed]);
+    }else{
+        printf("Could not get the port states\n");
+    }
+
+   	return 0;
+#undef MAX_SIZE 
+}
+static void athr_process_egress(int portno, int val)
+{
+	etd.cmd =  ATHR_QOS_PORT_ELIMIT;
+	etd.val = val;
+	etd. portnum  = portno;
+	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+		err (1, etd.ad_name);
+       
+}
+static void athr_process_igress(int portno, int val)
+{
+	etd.cmd =  ATHR_QOS_PORT_ILIMIT;
+   	etd.val = val;
+   	etd. portnum  = portno;
+   	if (ioctl (s, ATHR_GMAC_QOS_CTRL_IOC, &ifr) < 0)
+       	     	err (1, etd.ad_name);
+       
+}
+
+
+static void regwrite(u_int32_t phy_reg,u_int32_t val,u_int16_t portno)
+{
+        
+	etd.val     = val;
+	etd.phy_reg = phy_reg;
+        etd.portnum = portno;
+        if(opt_force)  {
+             etd.duplex   = duplex;
+             etd.cmd      = ATHR_PHY_FORCE;
+	    if (ioctl(s,ATHR_PHY_CTRL_IOC, &ifr) < 0)
+		err(1, etd.ad_name);
+            opt_force = 0;
+        }
+        else {
+            etd.cmd = ATHR_PHY_WR;
+	    if (ioctl(s,ATHR_PHY_CTRL_IOC, &ifr) < 0)
+		err(1, etd.ad_name);
+        }
+}
+
+static void usage(void)
+{
+	fprintf(stderr, "usage: %s [-i ifname] [-p portnum] offset[=value]\n", progname);
+	fprintf(stderr, "usage: %s [-f]  -p portnum =10/100/0 [-d duplex]\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-x]\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-c]\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-s value]\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-j 0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--txfctl] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--txfctl] [-i ifname] -v [0|1] -p <portno>\n", progname);
+        fprintf(stderr, "usage: %s [--rxfctl] [-i ifname] -v [0|1]\n",progname);
+        fprintf(stderr, "usage: %s [--rxfctl] [-i ifname] -v [0|1] -p <portno>\n", progname);
+        fprintf(stderr, "usage: %s [--dma] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--f_link] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--mib] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--stats] [-i ifname]\n", progname);
+        fprintf(stderr, "usage: %s [--stats] [-i ifname] -p <portno>\n", progname);
+        fprintf(stderr, "usage: %s [--qos] [-i ifname] -v [0|1]\n", progname);
+        fprintf(stderr, "usage: %s [--ipqos] [-i ifname] -t <tos> -v <val>\n", progname);
+        fprintf(stderr, "usage: %s [--vqos] [-i ifname] -l <vlanid> -v <val>\n", progname);
+        fprintf(stderr, "usage: %s [--mqos [-i ifname] -v <val> -p <portnum> -m <macaddr>\n", progname);
+        fprintf(stderr, "usage: %s [--p_st] [-i ifname] -p <portno>\n", progname);
+        fprintf(stderr, "usage: %s [--igrl] [-i ifname] -p <portno> -v <val>\n", progname);
+        fprintf(stderr, "usage: %s [--egrl] [-i ifname] -p <portno> -v <val>\n", progname);
+        fprintf(stderr, "usage: %s [-i ifname][-s value]\n",progname);
+        fprintf(stderr, "usage: %s [-i ifname][-j 0|1]\n",progname);
+        exit(-1);
+}
+
+
+int
+ethreg_main(int argc, char *argv[])
+{
+	const char *ifname = "eth0";
+	int c,portnum = 0x3f,cmd = 0,value = -1;
+        int optionindex = 0;
+        int vlanid = 0;
+        char *mac = NULL;
+        int tos = -1;
+        char *opt = "xfhci:d:s:j:v:t:p:m:l:";
+
+	s = socket(AF_INET, SOCK_DGRAM, 0);
+	if (s < 0)
+		err(1, "socket");
+
+        opt_force = 0;
+	progname = argv[0];
+        
+
+	struct option long_options[] =
+        {
+            { "f_link", no_argument, 0, ATHR_FLOW_LINK_EN},
+            { "txfctl", no_argument, 0, ATHR_PHY_TXFCTL},
+            { "rxfctl", no_argument, 0, ATHR_PHY_RXFCTL},
+            { "stats" , no_argument, 0, ATHR_GMAC_STATS},
+            { "mib"   , no_argument, 0, ATHR_PHY_MIB},
+            { "dma"   , no_argument, 0, ATHR_GMAC_DMA_CHECK},
+            { "qos"   , no_argument, 0, ATHR_QOS_ETH_SOFT_CLASS},
+            { "ppri"  , no_argument, 0, ATHR_QOS_ETH_PORT},
+            { "ipqos" , no_argument, 0, ATHR_QOS_ETH_IP},
+            { "vqos"  , no_argument, 0, ATHR_QOS_ETH_VLAN},
+            { "mqos"  , no_argument, 0, ATHR_QOS_ETH_DA},
+            { "igrl"  , no_argument, 0, ATHR_QOS_PORT_ELIMIT},
+            { "egrl"  , no_argument, 0, ATHR_QOS_PORT_ILIMIT},
+            { "p_st"  , no_argument, 0, ATHR_PORT_STATS},
+            { 0,0,0,0}
+       	};
+          
+           
+	while ((c = getopt_long(argc, argv,
+                    opt, long_options, &optionindex)) != -1) { 
+	switch (c) {
+        	case ATHR_FLOW_LINK_EN:
+                	cmd = ATHR_FLOW_LINK_EN;
+                        break;
+        	case ATHR_PHY_TXFCTL:
+                        cmd = ATHR_PHY_TXFCTL;
+                        break;
+                case ATHR_PHY_RXFCTL:
+                        cmd = ATHR_PHY_RXFCTL;
+                        break;
+                case ATHR_PHY_MIB:
+                        cmd = ATHR_PHY_MIB;
+                        break;
+                case ATHR_GMAC_STATS:
+                        cmd = ATHR_GMAC_STATS;
+                        break;
+                case ATHR_GMAC_DMA_CHECK:
+                        cmd = ATHR_GMAC_DMA_CHECK;
+                        break;
+                case ATHR_QOS_ETH_SOFT_CLASS:
+                        cmd = ATHR_QOS_ETH_SOFT_CLASS;
+                        break;
+                case ATHR_QOS_ETH_PORT:
+                        cmd = ATHR_QOS_ETH_PORT;
+                        break;
+                case ATHR_QOS_ETH_VLAN:
+                        cmd = ATHR_QOS_ETH_VLAN;
+                        break;
+                case ATHR_QOS_ETH_IP:
+                        cmd = ATHR_QOS_ETH_IP;
+                        break;
+                case ATHR_QOS_ETH_DA:
+                        cmd = ATHR_QOS_ETH_DA;
+                        break; 
+                case ATHR_PORT_STATS:
+                        cmd = ATHR_PORT_STATS;
+                        break;
+                case ATHR_QOS_PORT_ELIMIT:
+                        cmd = ATHR_QOS_PORT_ELIMIT;
+                        break;
+                case ATHR_QOS_PORT_ILIMIT:
+                        cmd = ATHR_QOS_PORT_ILIMIT;
+                        break;
+                case 'm':
+                        mac = optarg;
+                        break;
+                case 'v':
+                        value = strtoul(optarg, 0, 0);
+                        break;
+		case 'i':
+			ifname = optarg;
+			break;
+                case 't':
+                        tos = strtoul(optarg, 0, 0);
+                        break;
+		case 'p':
+                        portnum = strtoul(optarg, 0, 0);
+			break;
+		case 'f':
+			opt_force = 1;
+			break;
+                case 'd':
+			duplex = strtoul(optarg, 0, 0);
+			break;
+                case 'c':
+			cmd = ATHR_ACL_COMMIT;
+                        break;
+                case 'x':
+			cmd = ATHR_ACL_FLUSH;
+                        break;
+                case 's':
+                        cmd = ATHR_FRAME_SIZE_CTL;
+                        value = strtoul(optarg, 0, 0);
+                        break;
+		case 'j':
+                        cmd = ATHR_JUMBO_FRAME;
+                        value = strtoul(optarg, 0, 0);
+                        break;
+                case 'l':
+                        vlanid = strtoul (optarg, 0, 0);
+                        break;
+                case 'h':
+                        usage();
+                        break;
+		default:
+			usage();
+			/*NOTREACHED*/
+		}
+
+        }
+
+	argc -= optind;
+	argv += optind;
+	strncpy(etd.ad_name, ifname, sizeof (etd.ad_name));
+        strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+        ifr.ifr_data = (void *) &etd;
+
+        if (cmd == ATHR_ACL_COMMIT) {
+        	athr_commit_acl_rules();
+              	return 0;
+        }
+        else if (cmd == ATHR_ACL_FLUSH) {
+              	athr_flush_acl_rules();
+              	return 0;
+        }
+        else if(cmd == ATHR_FRAME_SIZE_CTL) {
+        	if (value == -1) {
+                	printf ("usage:ethreg -i <if_name> -s <val>\n");
+                  	return -1; 
+              	} else {
+	          	athr_set_framesize(value);
+              	}
+              	return 0;
+        }
+        else if (cmd == ATHR_JUMBO_FRAME) {
+        	if (value == -1) {
+                	printf ("usage: ethreg -i <if_name> -j <0|1>\n");
+                	return -1;
+             	} else {
+	        	athr_en_jumboframe(value);
+             	}
+             return 0;
+	}
+        else if (cmd == ATHR_FLOW_LINK_EN) {
+        	if (value == -1 || portnum == 0x3f) {
+                	printf ("usage: ethreg --f_link -i <ifname> -p <portnum> -v 1\n");
+                 	return -1;
+             	} else {
+                	athr_flow_link(portnum, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_PHY_RXFCTL) {
+        	if (value == -1) {
+                	printf ("usage: ethreg --rxfctl -i <ifname> -p <portnum> -v [0|1]\n");
+                	printf ("usage: ethreg --rxfctl -i <ifname> -v [0|1]\n");
+                 	return -1;
+             	} else {
+                 	athr_rxflctrl(portnum, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_PHY_TXFCTL) {
+        	if (value == -1) {
+                	printf ("usage: ethreg --txfctl -i <ifname> -p <portnum> -v [0|1]\n");
+                	printf ("usage: ethreg --txfctl -i <ifname> -v [0|1]\n");
+                 	return -1;
+             	} else {
+                	 athr_txflctrl(portnum, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_PHY_MIB) {
+        	if (value == -1) {
+        		printf ("usage: ethreg --mib -i <ifname> -v 1\n");
+		 	return -1;
+             	} else {
+                	athr_set_mib(value);
+             	}
+             	return 0;
+        }
+	else if (cmd == ATHR_GMAC_STATS) {
+        	athr_disp_stats(portnum);
+	     	return 0;
+	}
+	else if (cmd == ATHR_GMAC_DMA_CHECK) {
+                if (value == -1) {
+                	printf ("usage: ethreg --dma -i <ifname> -v [0|1]\n");
+                        return -1;
+                } else {
+        		athr_dma_check(value);
+                }
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_ETH_SOFT_CLASS) {
+        	if (value == -1) {
+                	printf ("usage: ethreg --qos -i <ifname> -v [0|1]\n");
+                	return -1;
+             	} else {
+                	athr_set_qos(value);
+             	}
+             	return 0;
+               
+        }
+        else if (cmd == ATHR_QOS_ETH_PORT) {
+        	if (value == -1) {
+                	printf("usage: ethreg --ppri -i <ifname> -p <portno> -v <val>\n");
+                	return -1;
+             	} else {
+                 	athr_set_port_pri(portnum, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_ETH_IP) {
+        	if (tos == -1 || value == -1) {
+                 	printf ("usage: ethreg --ipqos -i <ifname> -v <val> -t <tos>\n");
+                 	return -1;
+             	} else {
+                 	athr_ip_qos(tos, value);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_ETH_VLAN) {
+        	if (value == -1 || vlanid == -1) {
+                	printf ("usage: ethreg --vqos -i <ifname> -v <val> -l <vlanid>\n");
+                 	return -1;
+             	} else {
+                	athr_vlan_qos(vlanid, value);
+                 
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_ETH_DA) {
+        	if (portnum == 0x3f || value == -1 || mac == NULL) {
+                	printf ("usage: ethreg --mqos -i <ifname> -v <val> -p <portnum> -m <macaddr>\n");
+                 	return -1;
+             	} else {
+                	athr_mac_qos(portnum, value, mac);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_PORT_STATS) {
+        	if (portnum == 0x3f) {
+                	printf ("usage: ethreg --port_st -i <ifname> -p <portno>\n");
+			return -1;
+             	} else {
+                	athr_port_st(portnum);
+             	}
+             	return 0;
+        }
+        else if (cmd == ATHR_QOS_PORT_ELIMIT) {
+        	if (portnum == 0x3f || value == -1 ) {
+                	printf("usage: ethreg --egrl -i <ifname> -p <portnum> -v <val>\n");
+                 	return -1;
+             	} else {
+                	athr_process_egress(portnum, value);
+             	}
+             	return 0;
+       	}
+       	else if (cmd == ATHR_QOS_PORT_ILIMIT) {
+       		if (portnum == 0x3f || value == -1 ) {
+                	printf("usage: ethreg --igrl -i <ifname> -p <portnum> -v <val>\n");
+                 	return -1;
+             	} else {
+                 	athr_process_igress(portnum, value);
+             	}
+             	return 0;
+	}
+	for (; argc > 0; argc--, argv++) {
+		u_int32_t   off;
+                u_int32_t  val, oval;
+                char *cp;
+
+                cp = strchr(argv[0], '=');
+
+                if (cp != NULL)
+                        *cp = '\0';
+
+                off = (u_int) strtoul(argv[0], 0, 0);
+
+                if (off == 0 && errno == EINVAL)
+               		errx(1, "%s: invalid reg offset %s",
+                              progname, argv[0]);
+
+                if (cp == NULL) {
+                	val = regread(off,portnum);
+                    	printf("Read Reg: 0x%08x = 0x%08x\n",off, val);
+                    	return 0;
+                } else {
+                	val = (u_int32_t) strtoul(cp+1, 0, 0);
+                    	if (val == 0 && errno == EINVAL) {
+                        	errx(1, "%s: invalid reg value %s",
+                                        progname, cp+1);
+                    	}
+                     	else {
+                        	oval = regread(off,portnum);
+				            if(opt_force == 0) {
+                            		printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", off, oval, val);
+                            		regwrite(off,val,portnum);
+                        	}
+                        	if(opt_force == 1 && portnum == 0x3f) {
+                            		fprintf(stderr, "usage: %s [-f]  -p portnum =10/100/0 [-d duplex]\n", progname);
+                            		return -1;
+                        	} else {
+                            		regwrite(off,val,portnum);
+                        	}
+                     	}	
+                }
+        }
+        return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/miscutils/factoryreset.c apps_1.2/busybox-1.15.0/miscutils/factoryreset.c
--- apps/busybox-1.15.0/miscutils/factoryreset.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.15.0/miscutils/factoryreset.c	2014-05-30 03:43:44.112943889 -0700
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <sys/reboot.h>
+#include "busybox.h"
+
+static volatile int fd = 0;
+
+static void siginthnd(int signo)
+{
+    printf("signal caught. closing fr device\n");
+    if (fd != 0)
+        close(fd);
+    exit(0);
+}
+
+extern int factoryreset_main(int argc, char **argv)
+{
+	if (daemon(0, 1) < 0)
+		bb_perror_msg_and_die("Failed forking factory reset daemon");
+
+	signal(SIGHUP, siginthnd);
+	signal(SIGINT, siginthnd);
+
+	fd = open(argv[argc - 1], O_WRONLY);
+
+        if (fd < 0)
+		bb_perror_msg_and_die("Failed to open factory reset device");
+
+        ioctl(fd, 0x89ABCDEF, 0);
+
+	close(fd);
+
+        printf("\nRestoring the factory default configuration ....\n");
+        fflush(stdout);
+
+        /* Restore the factory default settings */
+        system("factoryrestore");
+        sleep(1);
+
+        reboot(RB_AUTOBOOT);
+	return EXIT_SUCCESS;
+}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/miscutils/Kbuild apps_1.2/busybox-1.15.0/miscutils/Kbuild
--- apps/busybox-1.15.0/miscutils/Kbuild	2014-05-30 03:41:18.523251477 -0700
+++ apps_1.2/busybox-1.15.0/miscutils/Kbuild	2014-05-30 03:43:44.112943889 -0700
@@ -1,45 +1,49 @@
 # Makefile for busybox
 #
 # Copyright (C) 1999-2005 by Erik Andersen <andersen@codepoet.org>
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
 #
 # Licensed under the GPL v2, see the file LICENSE in this tarball.
 
 lib-y:=
-lib-$(CONFIG_ADJTIMEX)    += adjtimex.o
-lib-$(CONFIG_BBCONFIG)    += bbconfig.o
-lib-$(CONFIG_BEEP)        += beep.o
-lib-$(CONFIG_CHAT)        += chat.o
-lib-$(CONFIG_CHRT)        += chrt.o
-lib-$(CONFIG_CROND)       += crond.o
-lib-$(CONFIG_CRONTAB)     += crontab.o
-lib-$(CONFIG_DC)          += dc.o
-lib-$(CONFIG_DEVFSD)      += devfsd.o
-lib-$(CONFIG_DEVMEM)      += devmem.o
-lib-$(CONFIG_EJECT)       += eject.o
-lib-$(CONFIG_FBSPLASH)    += fbsplash.o
-lib-$(CONFIG_FLASH_ERASEALL) += flash_eraseall.o
-lib-$(CONFIG_FLASH_LOCK)     += flash_lock_unlock.o
-lib-$(CONFIG_FLASH_UNLOCK)   += flash_lock_unlock.o
-lib-$(CONFIG_IONICE)      += ionice.o
-lib-$(CONFIG_HDPARM)      += hdparm.o
-lib-$(CONFIG_INOTIFYD)    += inotifyd.o
+lib-$(CONFIG_ADJTIMEX)		+= adjtimex.o
+lib-$(CONFIG_BBCONFIG)		+= bbconfig.o
+lib-$(CONFIG_BEEP)		+= beep.o
+lib-$(CONFIG_CHAT)		+= chat.o
+lib-$(CONFIG_CHRT)		+= chrt.o
+lib-$(CONFIG_CROND)		+= crond.o
+lib-$(CONFIG_CRONTAB)		+= crontab.o
+lib-$(CONFIG_DC)		+= dc.o
+lib-$(CONFIG_DEVFSD)		+= devfsd.o
+lib-$(CONFIG_DEVMEM)		+= devmem.o
+lib-$(CONFIG_EJECT)		+= eject.o
+lib-$(CONFIG_FBSPLASH)		+= fbsplash.o
+lib-$(CONFIG_FLASH_ERASEALL)	+= flash_eraseall.o
+lib-$(CONFIG_FLASH_LOCK)	+= flash_lock_unlock.o
+lib-$(CONFIG_FLASH_UNLOCK)	+= flash_lock_unlock.o
+lib-$(CONFIG_IONICE)		+= ionice.o
+lib-$(CONFIG_HDPARM)		+= hdparm.o
+lib-$(CONFIG_INOTIFYD)		+= inotifyd.o
 lib-$(CONFIG_FEATURE_LAST_SMALL)+= last.o
 lib-$(CONFIG_FEATURE_LAST_FANCY)+= last_fancy.o
-lib-$(CONFIG_LESS)        += less.o
-lib-$(CONFIG_MAKEDEVS)    += makedevs.o
-lib-$(CONFIG_MAN)         += man.o
-lib-$(CONFIG_MICROCOM)    += microcom.o
-lib-$(CONFIG_MOUNTPOINT)  += mountpoint.o
-lib-$(CONFIG_MT)          += mt.o
-lib-$(CONFIG_RAIDAUTORUN) += raidautorun.o
-lib-$(CONFIG_READAHEAD)   += readahead.o
-lib-$(CONFIG_RUNLEVEL)    += runlevel.o
-lib-$(CONFIG_RX)          += rx.o
-lib-$(CONFIG_SETSID)      += setsid.o
-lib-$(CONFIG_STRINGS)     += strings.o
-lib-$(CONFIG_TASKSET)     += taskset.o
-lib-$(CONFIG_TIME)        += time.o
-lib-$(CONFIG_TIMEOUT)     += timeout.o
-lib-$(CONFIG_TTYSIZE)     += ttysize.o
-lib-$(CONFIG_VOLNAME)     += volname.o
-lib-$(CONFIG_WATCHDOG)    += watchdog.o
+lib-$(CONFIG_LESS)		+= less.o
+lib-$(CONFIG_MAKEDEVS)		+= makedevs.o
+lib-$(CONFIG_MAN)		+= man.o
+lib-$(CONFIG_MICROCOM)		+= microcom.o
+lib-$(CONFIG_MOUNTPOINT)	+= mountpoint.o
+lib-$(CONFIG_MT)		+= mt.o
+lib-$(CONFIG_RAIDAUTORUN)	+= raidautorun.o
+lib-$(CONFIG_READAHEAD)		+= readahead.o
+lib-$(CONFIG_RUNLEVEL)		+= runlevel.o
+lib-$(CONFIG_RX)		+= rx.o
+lib-$(CONFIG_SETSID)		+= setsid.o
+lib-$(CONFIG_STRINGS)		+= strings.o
+lib-$(CONFIG_TASKSET)		+= taskset.o
+lib-$(CONFIG_TIME)		+= time.o
+lib-$(CONFIG_TIMEOUT)		+= timeout.o
+lib-$(CONFIG_TTYSIZE)		+= ttysize.o
+lib-$(CONFIG_VOLNAME)		+= volname.o
+lib-$(CONFIG_WATCHDOG)		+= watchdog.o
+lib-$(CONFIG_MDMM)		+= mdmm.o
+lib-$(CONFIG_ETHREG)		+= ethreg.o
+lib-$(CONFIG_FACTORYRESET)	+= factoryreset.o
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/miscutils/mdmm.c apps_1.2/busybox-1.15.0/miscutils/mdmm.c
--- apps/busybox-1.15.0/miscutils/mdmm.c	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.15.0/miscutils/mdmm.c	2014-05-30 03:43:44.112943889 -0700
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+ *
+ */ 
+
+/*
+ * Simple Atheros-specific tool to inspect and monitor network traffic
+ * statistics.
+ *	athstats [-i interface] [interval]
+ * (default interface is ath0).  If interval is specified a rolling output
+ * a la netstat -i is displayed every interval seconds.
+ *
+ * To build: cc -o athstats athstats.c -lkvm
+ */
+#include <sys/types.h>
+#include <sys/file.h>
+#include <sys/ioctl.h>
+//#include <sys/sockio.h>
+#include <sys/socket.h>
+#include <net/if.h>
+//#include <net/if_media.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/signal.h>
+#include <string.h>
+#include <limits.h>
+#include <err.h>
+#include <errno.h>
+#include <unistd.h>
+
+void usage(void);
+int opendev(int);
+int md_main(int, char *[]);
+int mm_main(int, char *[]);
+int main(int, char *[]);
+
+void
+usage(void)
+{
+	fprintf(stderr, "Usage:\n"
+			"md address [count]\n"
+			"mm address value\n");
+	exit(1);
+}
+
+int
+opendev(int mode)
+{
+	int		fd;
+	extern int	errno;
+#define AR_MEM_DEV_NAME	"/dev/armem"
+	fd = open(AR_MEM_DEV_NAME, mode);
+
+	if (fd < 0) {
+		perror("open: " AR_MEM_DEV_NAME);
+		fprintf(stderr, "Create using: mknod " AR_MEM_DEV_NAME " c 1 13\n");
+	}
+
+	return fd;
+}
+
+int
+closedev(int fd)
+{
+	return close(fd);
+}
+
+int
+md_main(int argc, char *argv[])
+{
+	int		i, fd, count;
+	unsigned	val;
+	loff_t		addr;
+	off_t	 	ret;
+
+	if (argc < 2 || argc > 3) {
+		usage();
+		return EINVAL;
+	}
+
+	if ((fd = opendev(O_RDONLY)) < 0) {
+		return fd;
+	}
+
+	if (argc == 2) {
+		count = 1;
+	} else {
+		count = atoi(argv[2]);
+	}
+
+	addr = strtoul(argv[1], NULL, 16) & 0xffffffff;
+
+	lseek(fd, addr, SEEK_SET);
+	for (i = 0; i < count; i++, addr += sizeof(val)) {
+		if (read(fd, &val, sizeof(val)) != sizeof(val)) {
+			perror("read");
+			closedev(fd);
+			return -1;
+		}
+                printf("%08llx : 0x%08x %12d\n", addr, val, val);
+	}
+
+	closedev(fd);
+	return 0;
+}
+
+int
+mm_main(int argc, char *argv[])
+{
+	int		fd;
+	unsigned	new;
+	loff_t		addr;
+
+	if (argc != 3) {
+		usage();
+		return EINVAL;
+	}
+
+	if ((fd = opendev(O_RDWR)) < 0) {
+		return fd;
+	}
+
+	addr = strtoul(argv[1], NULL, 16) & 0xffffffff;
+	new = strtoul(argv[2], NULL, 16);
+
+	lseek(fd, addr, SEEK_SET);
+	if (write(fd, &new, sizeof(new)) != sizeof(new)) {
+		perror("write");
+		closedev(fd);
+		return -1;
+	}
+
+	closedev(fd);
+	return 0;
+}
+
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/networking/Config.in apps_1.2/busybox-1.15.0/networking/Config.in
--- apps/busybox-1.15.0/networking/Config.in	2014-05-30 03:41:18.543251709 -0700
+++ apps_1.2/busybox-1.15.0/networking/Config.in	2014-05-30 03:43:44.080943516 -0700
@@ -1,4 +1,22 @@
 #
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+#
+
+#
 # For a description of the syntax of this configuration file,
 # see scripts/kbuild/config-language.txt.
 #
@@ -259,6 +277,20 @@
 	help
 	  Ifconfig is used to configure the kernel-resident network interfaces.
 
+config FEATURE_IFCONFIG_S26QOS
+        bool "  Enable s26 qos commands in ifconfig "
+        default n
+        depends on IFCONFIG
+        help
+          Use ifconfig to control s26 qos of AR7240 S26 switch.
+
+config FEATURE_IFCONFIG_VLAN_IGMP
+	bool "  Enable vlan and igmp commands in ifconfig "
+	default n
+	depends on IFCONFIG
+	help
+	  Use ifconfig to control vlan and igmp of AR7240 S26 switch.
+
 config FEATURE_IFCONFIG_STATUS
 	bool "Enable status reporting output (+7k)"
 	default y
@@ -788,6 +820,13 @@
 	help
 	  Selecting this will make telnetd able to run standalone.
 
+config FEATURE_TELNETD_NO_DAEMONIZE
+	bool "  Disable daemonized feature"
+	default n
+	depends on TELNETD
+	help
+	  Selecting this will make telnetd run in foreground (no daemonize).
+
 config TFTP
 	bool "tftp"
 	default n
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/networking/ifconfig.c apps_1.2/busybox-1.15.0/networking/ifconfig.c
--- apps/busybox-1.15.0/networking/ifconfig.c	2014-05-30 03:41:18.567251987 -0700
+++ apps_1.2/busybox-1.15.0/networking/ifconfig.c	2014-05-30 03:43:44.080943516 -0700
@@ -25,6 +25,7 @@
  * 2002-04-20
  * IPV6 support added by Bart Visscher <magick@linux-fan.com>
  */
+ /* Copyright (c) 2013 Qualcomm Atheros, Inc. */
 
 #include <net/if.h>
 #include <net/if_arp.h>
@@ -43,6 +44,8 @@
 # include <net/if_slip.h>
 #endif
 
+#include <athrs_ctrl.h>
+
 /* I don't know if this is needed for busybox or not.  Anyone? */
 #define QUESTIONABLE_ALIAS_CASE
 
@@ -140,6 +143,41 @@
 /*
  * Define the bit masks signifying which operations to perform for each arg.
  */
+#ifdef ENABLE_FEATURE_IFCONFIG_VLAN_IGMP
+#define ARG_PORT         (A_ARG_REQ | A_MAP_ULONG)
+
+typedef struct {
+	u_int8_t uc[6];
+} mac_addr_t;
+
+struct arl_struct {
+	mac_addr_t mac_addr;
+	int port_map;
+	int sa_drop;
+};
+
+#endif
+
+#ifdef ENABLE_FEATURE_IFCONFIG_S26QOS
+struct qosoption {
+	const char *name;
+	const unsigned int selector;
+	const unsigned int paranum;
+};
+
+static const struct qosoption qosOptArray[] = {
+	{"enable", ATHR_QOS_ETH_SOFT_CLASS, 1},
+	{"disable", ATHR_QOS_ETH_SOFT_CLASS, 1},
+	{"portqos", ATHR_QOS_ETH_PORT, 3},
+	{"vlanqos", ATHR_QOS_ETH_VLAN, 3},
+	{"ipqos", ATHR_QOS_ETH_IP, 1},
+    {"macqos", ATHR_QOS_ETH_DA, 4},
+    {"portin", ATHR_QOS_PORT_ILIMIT, 3},
+    {"portout", ATHR_QOS_PORT_ELIMIT, 3},
+    {"portqout",ATHR_QOS_PORT_EQLIMIT, 4},
+	{NULL, 0}
+};
+#endif
 
 #define ARG_METRIC       (A_ARG_REQ /*| A_CAST_INT*/)
 #define ARG_MTU          (A_ARG_REQ /*| A_CAST_INT*/)
@@ -164,8 +202,8 @@
 
 struct arg1opt {
 	const char *name;
-	unsigned short selector;
-	unsigned short ifr_offset;
+	unsigned int selector;
+	unsigned int ifr_offset;
 };
 
 struct options {
@@ -177,7 +215,7 @@
 	const unsigned char flags;
 	const unsigned char arg_flags;
 #endif
-	const unsigned short selector;
+	const unsigned int selector;
 };
 
 #define ifreq_offsetof(x)  offsetof(struct ifreq, x)
@@ -209,6 +247,23 @@
 	{ "SIFADDR",    SIOCSIFADDR,    ifreq_offsetof(ifr_addr) }, /* IPv6 version ignores the offset */
 	{ "DIFADDR",    SIOCDIFADDR,    ifreq_offsetof(ifr_addr) }, /* IPv6 version ignores the offset */
 #endif
+#ifdef ENABLE_FEATURE_IFCONFIG_S26QOS
+	{"S26_QOS_CTL",    ATHR_GMAC_QOS_CTRL_IOC,    ifreq_offsetof(ifr_data)},
+#endif
+#ifdef ENABLE_FEATURE_IFCONFIG_VLAN_IGMP
+	{"S26_VLAN_ADDPORTS",	ATHR_VLAN_ADDPORTS,	ifreq_offsetof(ifr_metric)},
+	{"S26_VLAN_DELPORTS",	ATHR_VLAN_DELPORTS,	ifreq_offsetof(ifr_metric)},
+	{"S26_VLAN_SETTAGMODE",	ATHR_VLAN_SETTAGMODE,	ifreq_offsetof(ifr_metric)},
+	{"S26_VLAN_SETDEFAULTID",	ATHR_VLAN_SETDEFAULTID,	ifreq_offsetof(ifr_metric)},
+	{"S26_IGMP_ON_OFF",     ATHR_IGMP_ON_OFF,    ifreq_offsetof(ifr_data)},
+	{"S26_LINK_GETSTAT",	ATHR_LINK_GETSTAT,	ifreq_offsetof(ifr_data)},
+	{"S26_VLAN_ENABLE",		ATHR_VLAN_ENABLE,	ifreq_offsetof(ifr_data)},
+	{"S26_VLAN_DISABLE",	ATHR_VLAN_DISABLE,	ifreq_offsetof(ifr_data)},
+	{"S26_ARL_ADD",			ATHR_ARL_ADD,	ifreq_offsetof(ifr_data)},
+	{"S26_ARL_DEL",			ATHR_ARL_DEL,	ifreq_offsetof(ifr_data)},
+	{"S26_MCAST_CLR",		ATHR_MCAST_CLR,	ifreq_offsetof(ifr_data)},
+	{"S26_PACKET_FLAG",		ATHR_PACKET_FLAG,	ifreq_offsetof(ifr_data)},
+#endif
 	{ "SIFADDR",    SIOCSIFADDR,    ifreq_offsetof(ifr_addr) },
 };
 
@@ -238,6 +293,23 @@
 	{ "add",         N_ARG,         ARG_ADD_DEL,     0 },
 	{ "del",         N_ARG,         ARG_ADD_DEL,     0 },
 #endif
+#ifdef ENABLE_FEATURE_IFCONFIG_S26QOS
+	{"s26qos",     N_ARG,         0,            0},
+#endif
+#ifdef ENABLE_FEATURE_IFCONFIG_VLAN_IGMP
+	{"addports",		N_ARG,			ARG_PORT,	0},
+	{"delports",		N_ARG,			ARG_PORT,	0},
+	{"setmode",			N_ARG,			ARG_PORT,	0},
+	{"setid",			N_ARG,			ARG_PORT,	0},
+	{"igmpon",			N_ARG,			0,			0},
+	{"getstat",			N_ARG,			0,			0},
+	{"startvlan",		N_ARG,			0,			0},
+	{"stopvlan",		N_ARG,			0,			0},
+	{"addarl",			N_ARG,			0,			0},
+	{"delarl",			N_ARG,			0,			0},
+	{"setcast",			N_ARG,			0,			0},
+	{"setpacketflag",	N_ARG,			0,			0},
+#endif
 	{ "arp",         N_CLR | M_SET, 0,               IFF_NOARP },
 	{ "trailers",    N_CLR | M_SET, 0,               IFF_NOTRAILERS },
 	{ "promisc",     N_SET | M_CLR, 0,               IFF_PROMISC },
@@ -264,12 +336,17 @@
 {
 	struct ifreq ifr;
 	struct sockaddr_in sai;
+#ifdef ENABLE_FEATURE_IPV6	
+	struct sockaddr_in6 sai6;
+#endif
+
 #if ENABLE_FEATURE_IFCONFIG_HW
 	struct sockaddr sa;
 #endif
 	const struct arg1opt *a1op;
 	const struct options *op;
 	int sockfd;			/* socket fd we use to manipulate stuff with */
+	int goterr;
 	int selector;
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
 	unsigned int mask;
@@ -280,9 +357,9 @@
 	unsigned char did_flags;
 #endif
 	char *p;
-	/*char host[128];*/
-	const char *host = NULL; /* make gcc happy */
+	char host[128];
 
+	goterr = 0;
 	did_flags = 0;
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
 	sai_hostname = 0;
@@ -310,10 +387,12 @@
 	}
 
 	/* Create a channel to the NET kernel. */
-	sockfd = xsocket(AF_INET, SOCK_DGRAM, 0);
+	if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+		bb_perror_msg_and_die("socket");
+	}
 
 	/* get interface name */
-	strncpy_IFNAMSIZ(ifr.ifr_name, *argv);
+	safe_strncpy(ifr.ifr_name, *argv, IFNAMSIZ);
 
 	/* Process the remaining arguments. */
 	while (*++argv != (char *) NULL) {
@@ -325,17 +404,18 @@
 		}
 		for (op = OptArray; op->name; op++) {	/* Find table entry. */
 			if (strcmp(p, op->name) == 0) {	/* If name matches... */
-				mask &= op->flags;
-				if (mask)	/* set the mask and go. */
-					goto FOUND_ARG;
+				if ((mask &= op->flags)) {	/* set the mask and go. */
+					goto FOUND_ARG;;
+				}
 				/* If we get here, there was a valid arg with an */
 				/* invalid '-' prefix. */
-				bb_error_msg_and_die("bad: '%s'", p-1);
+				++goterr;
+				goto LOOP;
 			}
 		}
 
 		/* We fell through, so treat as possible hostname. */
-		a1op = Arg1Opt + ARRAY_SIZE(Arg1Opt) - 1;
+		a1op = Arg1Opt + (sizeof(Arg1Opt) / sizeof(Arg1Opt[0])) - 1;
 		mask = op->arg_flags;
 		goto HOSTNAME;
 
@@ -343,13 +423,318 @@
 		if (mask & ARG_MASK) {
 			mask = op->arg_flags;
 			a1op = Arg1Opt + (op - OptArray);
-			if (mask & A_NETMASK & did_flags)
+			if (mask & A_NETMASK & did_flags) {
 				bb_show_usage();
+			}
+#ifdef ENABLE_FEATURE_IFCONFIG_VLAN_IGMP
+			struct eth_cfg_params vlan_para = {};
+			struct arl_struct arl = {};
+			// Note: the argv has been added by 2; the argc has been substrated by one.
+			if(!strcmp("igmpon",op->name)||!strcmp("igmpoff",op->name))
+			{
+				if(argc!=4) goto VLAN_ERR;
+				unsigned int i = strtoul(argv[1], NULL, 0);
+				unsigned int j = strtoul(argv[2], NULL, 0);
+				vlan_para.val = i&0x1f;
+				if(j != 0)
+					j = 1;
+				vlan_para.val |= j << 7;
+				vlan_para.cmd = a1op->selector;
+				ifr.ifr_ifru.ifru_data = &vlan_para;
+
+				if (ioctl(sockfd, ATHR_VLAN_IGMP_IOC, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			// bit0-->port0,bit1-->port1,so it can be added or deleted many ports at the same time.
+			if(!strcmp("addports",op->name)||!strcmp("delports",op->name)||!strcmp("setid",op->name))
+			{
+				if(argc!=4) goto VLAN_ERR;
+				unsigned int data1 = strtoul(argv[1], NULL, 0);
+				unsigned int data2 = strtoul(argv[2], NULL, 0);
+
+				data1 &=0xfff; //vlan-id
+				data2 &=0xff;  //ports
+
+				vlan_para.val = (data1 << 16) | (data2);
+
+				vlan_para.cmd = a1op->selector;
+				ifr.ifr_ifru.ifru_data = &vlan_para;
+
+				if (ioctl(sockfd, ATHR_VLAN_IGMP_IOC, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			if(!strcmp("startvlan",op->name)||!strcmp("stopvlan",op->name))
+			{
+				if(argc!=2) goto VLAN_ERR;
+
+                vlan_para.cmd = a1op->selector;
+                ifr.ifr_ifru.ifru_data = &vlan_para;
+				//No arguments needed.
+				if (ioctl(sockfd, ATHR_VLAN_IGMP_IOC, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			if(!strcmp("setmode",op->name))
+			{
+
+				if(argc!=4) goto VLAN_ERR;
+				unsigned int data1 = strtoul(argv[1], NULL, 0);
+				unsigned int data2 = strtoul(argv[2], NULL, 0);
+
+				data1 &=0xf;   //mode:0-2 (0->unmodified,1->untagged,2->tagged)
+				data2 &=0x7;   //port:0-5 (cpu:port0)
+
+                vlan_para.val = (data1 << 16) | (data2);
+                vlan_para.cmd = a1op->selector;
+                ifr.ifr_ifru.ifru_data = &vlan_para;
+
+				if (ioctl(sockfd, ATHR_VLAN_IGMP_IOC, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			if(!strcmp("getstat",op->name))
+			{
+				if(argc!=3) goto VLAN_ERR;
+				unsigned int data1 = strtoul(argv[1], NULL, 0);
+
+				data1 &=0x7;  //port: 1-5
+				
+				vlan_para.val = data1;
+                vlan_para.cmd = a1op->selector;
+                ifr.ifr_ifru.ifru_data = &vlan_para;
+
+				if (ioctl(sockfd, ATHR_VLAN_IGMP_IOC, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				printf("phy port:%d--status %d.\n",data1,ifr.ifr_ifru.ifru_ivalue);//1--->up,0---->down
+				return 0;
+
+			}
+
+			if(!strcmp("setcast",op->name))
+			{
+				if(argc!=3) goto VLAN_ERR;
+				unsigned int data1 = strtoul(argv[1], NULL, 0);
+
+				data1 &=0x7;  //port: 1-5
+				
+				vlan_para.val = data1;
+                vlan_para.cmd = a1op->selector;
+                ifr.ifr_ifru.ifru_data = &vlan_para;
+				if (ioctl(sockfd, ATHR_VLAN_IGMP_IOC, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+
+				//1--->enable,0---->disable
+				printf("Enable or disable unknow multicast packets over vlans %d.\n",data1);
+				return 0;
+
+			}
+
+			if(!strcmp("addarl",op->name))
+			{
+
+				if(argc!=5) goto VLAN_ERR;
+
+				safe_strncpy(host, argv[1], (sizeof host));
+
+				if (in_ether(host, &sa)) {
+					bb_error_msg("invalid hw-addr %s", host);
+					++goterr;
+					continue;
+				}
+
+				memcpy(&arl.mac_addr,&sa.sa_data,6);
+				arl.port_map = strtoul(argv[2], NULL, 0);
+				arl.sa_drop = strtoul(argv[3], NULL, 0);
+
+
+				memcpy(&vlan_para.vlanid,&arl,sizeof(arl));
+
+                vlan_para.cmd = a1op->selector;
+                ifr.ifr_ifru.ifru_data = &vlan_para;
+
+				if (ioctl(sockfd, ATHR_VLAN_IGMP_IOC, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+
+			if(!strcmp("delarl",op->name))
+			{
+
+				if(argc!=3) goto VLAN_ERR;
+
+				safe_strncpy(host, argv[1], (sizeof host));
+
+				if (in_ether(host, &sa)) {
+					bb_error_msg("invalid hw-addr %s", host);
+					++goterr;
+					continue;
+				}
+
+				memcpy(&arl.mac_addr,&sa.sa_data,6);
+				memcpy(&vlan_para.vlanid,&arl,sizeof(arl));
+                vlan_para.cmd = a1op->selector;
+                ifr.ifr_ifru.ifru_data = &vlan_para;
+
+				if (ioctl(sockfd, ATHR_VLAN_IGMP_IOC, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+            if(!strcmp("setpacketflag",op->name))
+            {
+                if(argc!=3) goto VLAN_ERR;
+                unsigned int data1 = strtoul(argv[1], NULL, 0);
+
+                vlan_para.val = data1;
+                vlan_para.cmd = a1op->selector;
+                ifr.ifr_ifru.ifru_data = &vlan_para;
+
+                if (ioctl(sockfd, ATHR_VLAN_IGMP_IOC, &ifr) < 0) {
+                    perror(a1op->name);
+                    ++goterr;
+                    return goterr;
+                }
+                printf("Set  packet ignoring flag in eth1 to %d.\n",data1);//1--->up,0---->down
+                return 0;
+
+            }
+#endif
+#ifdef ENABLE_FEATURE_IFCONFIG_S26QOS
+			if(!strcmp("s26qos",op->name))
+			{
+				if (ioctl(sockfd, SIOCGIFFLAGS, &ifr) < 0) {
+					printf("ioctl sockfd error.\n");
+					return 0;
+				}
+				if((ifr.ifr_flags&IFF_UP) == 0){
+					printf("Please up the %s first.\n", ifr.ifr_name);
+					return 0;
+				}
+				--argc;
+				if(argc < 2) goto QOS_ERR;
+				const struct qosoption *qosop;
+				unsigned int data0, data1;
+				struct eth_cfg_params qos_para;
+				++argv;
+				--argc;
+		        for (qosop = qosOptArray; qosop->name; qosop++) {   /* Find table entry. */
+        		    if (strcmp(*argv, qosop->name) == 0) { /* If name matches... */
+           				break; 
+					}
+       			 }
+				if((qosop->name == NULL) || ((argc != qosop->paranum)&&(qosop->selector != ATHR_QOS_ETH_IP)))
+					goto QOS_ERR;
+				memset((unsigned char *)&qos_para, 0x0, sizeof(struct eth_cfg_params));
+				switch(qosop->selector){
+					case ATHR_QOS_ETH_SOFT_CLASS:
+						if (strcmp("enable", qosop->name) == 0)
+							qos_para.val = 1;
+						else
+							qos_para.val = 0;
+						break;
+					case ATHR_QOS_ETH_PORT:
+						qos_para.portnum = strtoul(argv[1], NULL, 0);
+						qos_para.val = strtoul(argv[2], NULL, 0);
+						break;
+					case ATHR_QOS_ETH_VLAN:
+						qos_para.vlanid = strtoul(argv[1], NULL, 0);
+						qos_para.val = strtoul(argv[2], NULL, 0);
+						break;
+					case ATHR_QOS_ETH_IP:
+						if(argc == 3){
+							qos_para.tos = strtoul(argv[1], NULL, 16);
+							qos_para.val = strtoul(argv[2], NULL, 0);
+						}
+						break;
+					case ATHR_QOS_ETH_DA:
+						{
+							int i,j,k;
+							char tmp[3];
+							tmp[2] = '\0';
+							k = 0;
+							for(i=0; i<6; i++){
+								for(j=0; j<2; j++)
+									tmp[j]=argv[1][k++];
+								qos_para.mac_addr[i] = strtoul(tmp, NULL, 16);
+								k++;
+							}
+				//			printf("%x:%x:%x:%x:%x:%x\n", qos_para.mac_addr[0],qos_para.mac_addr[1],
+				//				qos_para.mac_addr[2],qos_para.mac_addr[3],qos_para.mac_addr[4],qos_para.mac_addr[5]);
+							qos_para.val = strtoul(argv[2], NULL, 0);
+							qos_para.portnum=strtoul(argv[3],NULL,0);
+						}
+						break;
+                    case ATHR_QOS_PORT_ILIMIT:
+                    case ATHR_QOS_PORT_ELIMIT:
+                        {
+                            qos_para.portnum = strtoul(argv[1], NULL, 0);
+                            qos_para.val = strtoul(argv[2], NULL, 16);
+                        }
+                        break;
+                    case ATHR_QOS_PORT_EQLIMIT:
+                        {
+                            qos_para.portnum = strtoul(argv[1], NULL, 0);
+                            qos_para.phy_reg = strtoul(argv[2], NULL, 0);
+                            qos_para.val = strtoul(argv[3], NULL, 16);
+                        }
+                        break;
+				}
+
+				strcpy(qos_para.ad_name, ifr.ifr_name);
+				qos_para.cmd = qosop->selector;
+				
+				ifr.ifr_ifru.ifru_data = &qos_para;
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					return goterr;
+				}
+				return 0;
+
+			}
+#endif
 			if (*++argv == NULL) {
-				if (mask & A_ARG_REQ)
+				if (mask & A_ARG_REQ) {
 					bb_show_usage();
+				} else {
 				--argv;
 				mask &= A_SET_AFTER;	/* just for broadcast */
+				}
 			} else {	/* got an arg so process it */
  HOSTNAME:
 				did_flags |= (mask & (A_NETMASK|A_HOSTNAME));
@@ -361,57 +746,68 @@
 						char *prefix;
 						int prefix_len = 0;
 #endif
-						/*safe_strncpy(host, *argv, (sizeof host));*/
-						host = *argv;
+					     safe_strncpy(host, *argv, (sizeof host));
 #if ENABLE_FEATURE_IPV6
-						prefix = strchr(host, '/');
-						if (prefix) {
-							prefix_len = xatou_range(prefix + 1, 0, 128);
-							*prefix = '\0';
+						if ((prefix = strchr(host, '/'))) {
+							if (safe_strtoi(prefix + 1, &prefix_len) ||
+								(prefix_len < 0) || (prefix_len > 128))
+							{
+								++goterr;
+								goto LOOP;
+							}
+							*prefix = 0;
 						}
 #endif
+
 						sai.sin_family = AF_INET;
 						sai.sin_port = 0;
 						if (!strcmp(host, bb_str_default)) {
 							/* Default is special, meaning 0.0.0.0. */
 							sai.sin_addr.s_addr = INADDR_ANY;
-						}
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
-						else if ((host[0] == '+' && !host[1]) && (mask & A_BROADCAST)
+						} else if ((host[0] == '+' && !host[1]) && (mask & A_BROADCAST)
 						 && (did_flags & (A_NETMASK|A_HOSTNAME)) == (A_NETMASK|A_HOSTNAME)
 						) {
 							/* + is special, meaning broadcast is derived. */
 							sai.sin_addr.s_addr = (~sai_netmask) | (sai_hostname & sai_netmask);
 						}
 #endif
-						else {
-							len_and_sockaddr *lsa;
-							if (strcmp(host, "inet") == 0)
-								continue; /* compat stuff */
-							lsa = xhost2sockaddr(host, 0);
+
 #if ENABLE_FEATURE_IPV6
-							if (lsa->u.sa.sa_family == AF_INET6) {
-								int sockfd6;
-								struct in6_ifreq ifr6;
-
-								memcpy((char *) &ifr6.ifr6_addr,
-										(char *) &(lsa->u.sin6.sin6_addr),
-										sizeof(struct in6_addr));
-
-								/* Create a channel to the NET kernel. */
-								sockfd6 = xsocket(AF_INET6, SOCK_DGRAM, 0);
-								xioctl(sockfd6, SIOGIFINDEX, &ifr);
-								ifr6.ifr6_ifindex = ifr.ifr_ifindex;
-								ifr6.ifr6_prefixlen = prefix_len;
-								ioctl_or_perror_and_die(sockfd6, a1op->selector, &ifr6, "SIOC%s", a1op->name);
-								if (ENABLE_FEATURE_CLEAN_UP)
-									free(lsa);
+} else if (inet_pton(AF_INET6, host, &sai6.sin6_addr) > 0) {
+							int sockfd6;
+							struct in6_ifreq ifr6;
+
+							memcpy((char *) &ifr6.ifr6_addr,
+								   (char *) &sai6.sin6_addr,
+								   sizeof(struct in6_addr));
+
+							/* Create a channel to the NET kernel. */
+							if ((sockfd6 = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
+								bb_perror_msg_and_die("socket6");
+							}
+							if (ioctl(sockfd6, SIOGIFINDEX, &ifr) < 0) {
+								perror("SIOGIFINDEX");
+								++goterr;
 								continue;
 							}
+							ifr6.ifr6_ifindex = ifr.ifr_ifindex;
+							ifr6.ifr6_prefixlen = prefix_len;
+							if (ioctl(sockfd6, a1op->selector, &ifr6) < 0) {
+								perror(a1op->name);
+								++goterr;
+							}
+							continue;
 #endif
-							sai.sin_addr = lsa->u.sin.sin_addr;
-							if (ENABLE_FEATURE_CLEAN_UP)
-								free(lsa);
+						} else if (inet_aton(host, &sai.sin_addr) == 0) {
+							/* It's not a dotted quad. */
+							struct hostent *hp;
+							if ((hp = gethostbyname(host)) == (struct hostent *)NULL) {
+								++goterr;
+								continue;
+							}
+							memcpy((char *) &sai.sin_addr, (char *) hp->h_addr_list[0],
+							sizeof(struct in_addr));
 						}
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
 						if (mask & A_HOSTNAME)
@@ -423,14 +819,15 @@
 #if ENABLE_FEATURE_IFCONFIG_HW
 					} else {	/* A_CAST_HOST_COPY_IN_ETHER */
 						/* This is the "hw" arg case. */
-						smalluint hw_class= index_in_substrings("ether\0"
-								IF_FEATURE_HWIB("infiniband\0"), *argv) + 1;
-						if (!hw_class || !*++argv)
+						if (strcmp("ether", *argv) || (*++argv == NULL)) {
 							bb_show_usage();
-						/*safe_strncpy(host, *argv, sizeof(host));*/
-						host = *argv;
-						if (hw_class == 1 ? in_ether(host, &sa) : in_ib(host, &sa))
-							bb_error_msg_and_die("invalid hw-addr %s", host);
+						}
+						safe_strncpy(host, *argv, (sizeof host));
+						if (in_ether(host, &sa)) {
+							bb_error_msg("invalid hw-addr %s", host);
+							++goterr;
+							continue;
+						}
 						p = (char *) &sa;
 					}
 #endif
@@ -442,13 +839,17 @@
 					p = ((char *)&ifr) + a1op->ifr_offset;
 #if ENABLE_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
 					if (mask & A_MAP_TYPE) {
-						xioctl(sockfd, SIOCGIFMAP, &ifr);
-						if ((mask & A_MAP_UCHAR) == A_MAP_UCHAR)
+						if (ioctl(sockfd, SIOCGIFMAP, &ifr) < 0) {
+							++goterr;
+							continue;
+						}
+						if ((mask & A_MAP_UCHAR) == A_MAP_UCHAR) {
 							*((unsigned char *) p) = i;
-						else if (mask & A_MAP_USHORT)
+						} else if (mask & A_MAP_USHORT) {
 							*((unsigned short *) p) = i;
-						else
+						} else {
 							*((unsigned long *) p) = i;
+						}
 					} else
 #endif
 					if (mask & A_CAST_CHAR_PTR)
@@ -456,8 +857,11 @@
 					else	/* A_CAST_INT */
 						*((int *) p) = i;
 				}
-
-				ioctl_or_perror_and_die(sockfd, a1op->selector, &ifr, "SIOC%s", a1op->name);
+				if (ioctl(sockfd, a1op->selector, &ifr) < 0) {
+					perror(a1op->name);
+					++goterr;
+					continue;
+				}
 #ifdef QUESTIONABLE_ALIAS_CASE
 				if (mask & A_COLON_CHK) {
 					/*
@@ -482,18 +886,37 @@
 			mask = N_SET;
 		}
 
-		xioctl(sockfd, SIOCGIFFLAGS, &ifr);
-		selector = op->selector;
-		if (mask & SET_MASK)
-			ifr.ifr_flags |= selector;
-		else
-			ifr.ifr_flags &= ~selector;
-		xioctl(sockfd, SIOCSIFFLAGS, &ifr);
+		if (ioctl(sockfd, SIOCGIFFLAGS, &ifr) < 0) {
+			perror("SIOCGIFFLAGS");
+			++goterr;
+		} else {
+			selector = op->selector;
+			if (mask & SET_MASK) {
+				ifr.ifr_flags |= selector;
+			} else {
+				ifr.ifr_flags &= ~selector;
+			}
+			if (ioctl(sockfd, SIOCSIFFLAGS, &ifr) < 0) {
+				perror("SIOCSIFFLAGS");
+				++goterr;
+			}
+		}
+	  LOOP:
+		continue;
 	} /* while () */
 
 	if (ENABLE_FEATURE_CLEAN_UP)
 		close(sockfd);
-	return 0;
+		return goterr;
+#ifdef ENABLE_FEATURE_IFCONFIG_VLAN_IGMP
+VLAN_ERR:
+	bb_show_usage();
+#endif
+#ifdef ENABLE_FEATURE_IFCONFIG_S26QOS
+QOS_ERR:
+	printf("Here we need to show the usage of QosCtl\n");
+#endif
+	return -1;
 }
 
 #if ENABLE_FEATURE_IFCONFIG_HW
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/networking/libbridge/Kbuild apps_1.2/busybox-1.15.0/networking/libbridge/Kbuild
--- apps/busybox-1.15.0/networking/libbridge/Kbuild	1969-12-31 16:00:00.000000000 -0800
+++ apps_1.2/busybox-1.15.0/networking/libbridge/Kbuild	2014-05-30 03:43:44.080943516 -0700
@@ -0,0 +1,33 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+#
+
+#ifndef HAVE_IF_INDEX
+#COMPAT_SOURCES=  \
+#	libbridge_compat.c
+#else
+#COMPAT_SOURCES=
+#endif
+
+LIBBRIDGE_SOURCES= \
+	$(COMPAT_SOURCES) \
+	libbridge_devif.c \
+	libbridge_if.c \
+	libbridge_init.c \
+	libbridge_misc.c
+
+lib-$(CONFIG_BRCTL):=$(LIBBRIDGE_SOURCES:.c=.o)
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/networking/ping.c apps_1.2/busybox-1.15.0/networking/ping.c
--- apps/busybox-1.15.0/networking/ping.c	2014-05-30 03:41:18.575252080 -0700
+++ apps_1.2/busybox-1.15.0/networking/ping.c	2014-05-30 03:43:44.080943516 -0700
@@ -8,6 +8,8 @@
  * Copyright (c) 1989 The Regents of the University of California.
  * All rights reserved.
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * This code is derived from software contributed to Berkeley by
  * Mike Muuss.
  *
@@ -527,7 +529,7 @@
 	}
 }
 #if ENABLE_PING6
-static void unpack6(char *packet, int sz, /*struct sockaddr_in6 *from,*/ int hoplimit)
+static void unpack6(char *packet, int sz, struct sockaddr_in6 *from, int hoplimit)
 {
 	struct icmp6_hdr *icmppkt;
 	char buf[INET6_ADDRSTRLEN];
@@ -547,7 +549,7 @@
 		if (sz >= sizeof(struct icmp6_hdr) + sizeof(uint32_t))
 			tp = (uint32_t *) &icmppkt->icmp6_data8[4];
 		unpack_tail(sz, tp,
-			inet_ntop(AF_INET6, &pingaddr.sin6.sin6_addr,
+			inet_ntop(AF_INET6, &from->sin6_addr,
 					buf, sizeof(buf)),
 			recv_seq, hoplimit);
 	} else if (icmppkt->icmp6_type != ICMP6_ECHO_REQUEST) {
@@ -692,7 +694,7 @@
 				hoplimit = *(int*)CMSG_DATA(mp);
 			}
 		}
-		unpack6(packet, c, /*&from,*/ hoplimit);
+		unpack6(packet, c, &from, hoplimit);
 		if (pingcount && nreceived >= pingcount)
 			break;
 	}
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/networking/telnetd.c apps_1.2/busybox-1.15.0/networking/telnetd.c
--- apps/busybox-1.15.0/networking/telnetd.c	2014-05-30 03:41:18.575252080 -0700
+++ apps_1.2/busybox-1.15.0/networking/telnetd.c	2014-05-30 03:43:44.080943516 -0700
@@ -19,6 +19,8 @@
  *
  * Vladimir Oleynik <dzo@simtreas.ru> 2001
  * Set process group corrections, initial busybox port
+ *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 #define DEBUG 0
@@ -460,11 +462,13 @@
 		/* inform that we start in standalone mode?
 		 * May be useful when people forget to give -i */
 		/*bb_error_msg("listening for connections");*/
+#ifndef CONFIG_FEATURE_TELNETD_NO_DAEMONIZE
 		if (!(opt & OPT_FOREGROUND)) {
 			/* DAEMON_CHDIR_ROOT was giving inconsistent
 			 * behavior with/without -F, -i */
 			bb_daemonize_or_rexec(0 /*was DAEMON_CHDIR_ROOT*/, argv);
 		}
+#endif
 	}
 	/* Redirect log to syslog early, if needed */
 	if (IS_INETD || !(opt & OPT_FOREGROUND)) {
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/networking/traceroute.c apps_1.2/busybox-1.15.0/networking/traceroute.c
--- apps/busybox-1.15.0/networking/traceroute.c	2014-05-30 03:41:18.575252080 -0700
+++ apps_1.2/busybox-1.15.0/networking/traceroute.c	2014-05-30 03:43:44.080943516 -0700
@@ -5,6 +5,8 @@
  *
  * Busybox port by Vladimir Oleynik (C) 2005 <dzo@simtreas.ru>
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc. 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that: (1) source code distributions
  * retain the above copyright notice and this paragraph in its entirety, (2)
@@ -192,6 +194,7 @@
  *  -- Van Jacobson (van@ee.lbl.gov)
  *     Tue Dec 20 03:50:13 PST 1988
  */
+#define ATHEROS_TRACEROUTE_DIAG
 
 #define TRACEROUTE_SO_DEBUG 0
 
@@ -241,13 +244,21 @@
 	OPT_WAITTIME     = (1 << 14),   /* w */
 	OPT_PAUSE_MS     = (1 << 15),   /* z */
 	OPT_FIRST_TTL    = (1 << 16),   /* f */
+#ifdef ATHEROS_TRACEROUTE_DIAG
+	OPT_RESULT_OUT   = (1 << 17),   /* o */
+#endif
 };
 #define verbose (option_mask32 & OPT_VERBOSE)
 
 enum {
 	SIZEOF_ICMP_HDR = 8,
+#ifdef ATHEROS_TRACEROUTE_DIAG
+	rcvsock = 4, /* receive (icmp) socket file descriptor */
+	sndsock = 5, /* send (udp/icmp) socket file descriptor */
+#else
 	rcvsock = 3, /* receive (icmp) socket file descriptor */
 	sndsock = 4, /* send (udp/icmp) socket file descriptor */
+#endif
 };
 
 /* Data section of the probe packet */
@@ -304,6 +315,9 @@
 #define outicmp ((struct icmp *)(outip + 1))
 #define outudp  ((struct udphdr *)(outip + 1))
 
+#ifdef ATHEROS_TRACEROUTE_DIAG
+    FILE *output_fp;
+#endif
 
 static int
 wait_for_reply(struct sockaddr_in *fromp)
@@ -556,6 +570,12 @@
 		printf("  %s (%s)", (n ? n : ina), ina);
 		free(n);
 	}
+#ifdef ATHEROS_TRACEROUTE_DIAG
+	if(output_fp)
+	{
+		fprintf(output_fp, "record={\nHopHost=%s\nHopHostAddress=%s\n", ina, ina);
+	}
+#endif
 }
 
 static void
@@ -578,6 +598,12 @@
 {
 	unsigned tt = t2p - t1p;
 	printf("  %u.%03u ms", tt / 1000, tt % 1000);
+#ifdef ATHEROS_TRACEROUTE_DIAG
+	if(output_fp)
+	{
+		fprintf(output_fp, "HopRTTimes=%d\n", tt);
+	}
+#endif
 }
 
 /*
@@ -611,6 +637,11 @@
 	llist_t *source_route_list = NULL;
 	int lsrr = 0;
 #endif
+#ifdef ATHEROS_TRACEROUTE_DIAG
+	char *result_output_file;
+	int numOfRecords = 0;
+	unsigned time_start, time_end;
+#endif
 
 	INIT_G();
 
@@ -624,11 +655,17 @@
 #if ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE
 					"g:"
 #endif
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					"o:"
+#endif
 		, &tos_str, &device, &max_ttl_str, &port_str, &nprobes_str
 		, &source, &waittime_str, &pausemsecs_str, &first_ttl_str
 #if ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE
 		, &source_route_list
 #endif
+#ifdef ATHEROS_TRACEROUTE_DIAG
+		, &result_output_file
+#endif
 	);
 
 #if 0 /* IGNORED */
@@ -696,6 +733,10 @@
 	/* Ensure the socket fds won't be 0, 1 or 2 */
 	bb_sanitize_stdio();
 
+#ifdef ATHEROS_TRACEROUTE_DIAG
+	output_fp = fopen(result_output_file, "w+");
+#endif
+
 	xmove_fd(xsocket(AF_INET, SOCK_RAW, IPPROTO_ICMP), rcvsock);
 #if TRACEROUTE_SO_DEBUG
 	if (op & OPT_DEBUG)
@@ -795,7 +836,11 @@
 	if (op & OPT_SOURCE)
 		printf(" from %s", source);
 	printf(", %d hops max, %d byte packets\n", max_ttl, packlen);
-
+#ifdef ATHEROS_TRACEROUTE_DIAG
+	numOfRecords = 0;
+	time_start = monotonic_us();
+	output_fp = fopen(result_output_file, "w+");
+#endif
 	for (ttl = first_ttl; ttl <= max_ttl; ++ttl) {
 //TODO: make it protocol agnostic (get rid of sockaddr_in)
 		struct sockaddr_in from;
@@ -842,78 +887,189 @@
 					if (ip->ip_ttl <= 1)
 						printf(" !");
 					got_there = 1;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_REPLY_OK\n}\n");
+					}
+#endif
 					break;
 				}
 				/* time exceeded in transit */
 				if (i == -1)
+#ifdef ATHEROS_TRACEROUTE_DIAG
+				{
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_TTL_EXCEED\n}\n");
+					}
 					break;
+				}
+#else
+					break;
+#endif
 				i--;
 				switch (i) {
 				case ICMP_UNREACH_PORT:
 					if (ip->ip_ttl <= 1)
 						printf(" !");
 					got_there = 1;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_PORT\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_NET:
 					printf(" !N");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_NET\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_HOST:
 					printf(" !H");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_HOST\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_PROTOCOL:
 					printf(" !P");
 					got_there = 1;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_PROTOCOL\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_NEEDFRAG:
 					printf(" !F-%d", pmtu);
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_NEEDFRAG\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_SRCFAIL:
 					printf(" !S");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_SRCFAIL\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_FILTER_PROHIB:
 				case ICMP_UNREACH_NET_PROHIB:   /* misuse */
 					printf(" !A");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_FILTER_PROHIB\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_HOST_PROHIB:
 					printf(" !C");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_HOST_PROHIB\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_HOST_PRECEDENCE:
 					printf(" !V");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_HOST_PRECEDENCE\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_PRECEDENCE_CUTOFF:
 					printf(" !C");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_PRECEDENCE_CUTOFF\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_NET_UNKNOWN:
 				case ICMP_UNREACH_HOST_UNKNOWN:
 					printf(" !U");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_NET_UNKNOWN\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_ISOLATED:
 					printf(" !I");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_ISOLATED\n}\n");
+					}
+#endif
 					break;
 				case ICMP_UNREACH_TOSNET:
 				case ICMP_UNREACH_TOSHOST:
 					printf(" !T");
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=ICMP_UNREACH_TOSNET\n}\n");
+					}
+#endif
 					break;
 				default:
 					printf(" !<%d>", i);
 					++unreachable;
+#ifdef ATHEROS_TRACEROUTE_DIAG
+					if(output_fp)
+					{
+						fprintf(output_fp, "HopErrorCode=UNKNOWN_ERROR\n}\n");
+					}
+#endif
 					break;
 				}
 				break;
 			}
 			if (cc == 0)
+#ifdef ATHEROS_TRACEROUTE_DIAG
+			{
+				printf("  *");
+				if(output_fp)
+				{
+					fprintf(output_fp, "record={\nHopHost=*\nHopHostAddress=*\nHopErrorCode=*\nHopRTTimes=*\n}\n");
+				}
+			}
+			numOfRecords++;
+#else
 				printf("  *");
+#endif
 		}
 		bb_putchar('\n');
 		if (got_there
@@ -922,5 +1078,15 @@
 			break;
 		}
 	}
+#ifdef ATHEROS_TRACEROUTE_DIAG
+	time_end = monotonic_us();
+	if(output_fp)
+	{
+		fprintf(output_fp, "RouteHopsNumberOfEntries=%d\n", numOfRecords);
+		fprintf(output_fp, "ResponseTime=%d\n", time_end-time_start);
+		fclose(output_fp);
+		output_fp = NULL;
+	}
+#endif	
 	return 0;
 }
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/sysklogd/syslogd.c apps_1.2/busybox-1.15.0/sysklogd/syslogd.c
--- apps/busybox-1.15.0/sysklogd/syslogd.c	2014-05-30 03:41:18.719253751 -0700
+++ apps_1.2/busybox-1.15.0/sysklogd/syslogd.c	2014-05-30 03:43:44.112943889 -0700
@@ -8,6 +8,8 @@
  *
  * "circular buffer" Copyright (C) 2001 by Gennady Feldman <gfeldman@gena01.com>
  *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
  * Maintainer: Gennady Feldman <gfeldman@gena01.com> as of Mar 12, 2001
  *
  * Licensed under the GPL v2 or later, see the file LICENSE in this tarball.
@@ -25,6 +27,19 @@
 #include <sys/un.h>
 #include <sys/uio.h>
 
+const char *log_severities[] = {
+	"Emergency",
+	"Alert",
+	"Critical",
+	"Error",
+	"Warning",
+	"Notice",
+	"Informational",
+	"Debug",
+};
+
+static int log_level = LOG_INFO;
+
 #if ENABLE_FEATURE_REMOTE_LOG
 #include <netinet/in.h>
 #endif
@@ -118,14 +133,14 @@
 };
 
 static const struct init_globals init_data = {
-	.logFilePath = "/var/log/messages",
+	.logFilePath = "/var/log/messages.txt",
 	.logFD = -1,
 #ifdef SYSLOGD_MARK
 	.markInterval = 20 * 60,
 #endif
 	.logLevel = 8,
 #if ENABLE_FEATURE_ROTATE_LOGFILE
-	.logFileSize = 200 * 1024,
+	.logFileSize = 100 * 1024,
 	.logFileRotate = 1,
 #endif
 #if ENABLE_FEATURE_REMOTE_LOG
@@ -420,29 +435,39 @@
  * that there is no timestamp, short-circuiting the test. */
 static void timestamp_and_log(int pri, char *msg, int len)
 {
-	char *timestamp;
+    int flag = 0;
+	char timestamp[40];
 	time_t now;
+    struct tm *stm = NULL;
+
+    if(log_level < LOG_PRI(pri))
+        return;
 
+    time(&now);
+    stm = localtime(&now);
+    bzero(timestamp, sizeof timestamp);
+    snprintf(timestamp, sizeof timestamp, "%04u-%02u-%02u %02u:%02u:%02u [%s]",
+                stm->tm_year + 1900,
+                stm->tm_mon + 1,
+                stm->tm_mday,
+                stm->tm_hour,
+                stm->tm_min,
+                stm->tm_sec,
+				log_severities[LOG_PRI(pri)]);
 	/* Jan 18 00:11:22 msg... */
 	/* 01234567890123456 */
 	if (len < 16 || msg[3] != ' ' || msg[6] != ' '
-	 || msg[9] != ':' || msg[12] != ':' || msg[15] != ' '
-	) {
-		time(&now);
-		timestamp = ctime(&now) + 4; /* skip day of week */
-	} else {
-		now = 0;
-		timestamp = msg;
-		msg += 16;
-	}
-	timestamp[15] = '\0';
+	 || msg[9] != ':' || msg[12] != ':' || msg[15] != ' ') {
+        flag = 1;
+	} 
 
 	if (option_mask32 & OPT_small)
-		sprintf(G.printbuf, "%s %s\n", timestamp, msg);
+		sprintf(G.printbuf, "%s %s\n", timestamp, (flag ? msg : msg+16));
 	else {
 		char res[20];
 		parse_fac_prio_20(pri, res);
-		sprintf(G.printbuf, "%s %.64s %s %s\n", timestamp, G.hostname, res, msg);
+		sprintf(G.printbuf, "%s %.64s %s %s\n", 
+                timestamp, G.hostname, res, (flag ? msg : msg+16));
 	}
 
 	/* Log message locally (to file or shared mem) */
@@ -680,8 +705,12 @@
 #if ENABLE_FEATURE_ROTATE_LOGFILE
 	if (opts & OPT_filesize) // -s
 		G.logFileSize = xatou_range(opt_s, 0, INT_MAX/1024) * 1024;
-	if (opts & OPT_rotatecnt) // -b
-		G.logFileRotate = xatou_range(opt_b, 0, 99);
+	if (opts & OPT_rotatecnt) {// -b
+		//G.logFileRotate = xatou_range(opt_b, 0, 99);
+        log_level = xatou_range(opt_b, 0, 99);
+        if(log_level > LOG_DEBUG)
+                log_level = LOG_DEBUG;
+	}
 #endif
 #if ENABLE_FEATURE_IPC_SYSLOG
 	if (opt_C) // -Cn
@@ -696,9 +725,12 @@
 	G.hostname = safe_gethostname();
 	*strchrnul(G.hostname, '.') = '\0';
 
+#if 0
 	if (!(opts & OPT_nofork)) {
 		bb_daemonize_or_rexec(DAEMON_CHDIR_ROOT, argv);
 	}
+#endif
+
 	umask(0);
 	write_pidfile("/var/run/syslogd.pid");
 	do_syslogd();
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/busybox-1.15.0/TODO_config_nommu apps_1.2/busybox-1.15.0/TODO_config_nommu
--- apps/busybox-1.15.0/TODO_config_nommu	2014-05-30 03:41:18.267248507 -0700
+++ apps_1.2/busybox-1.15.0/TODO_config_nommu	2014-05-30 03:43:44.100943749 -0700
@@ -673,6 +673,9 @@
 CONFIG_FEATURE_HTTPD_ENCODE_URL_STR=y
 CONFIG_FEATURE_HTTPD_ERROR_PAGES=y
 CONFIG_FEATURE_HTTPD_PROXY=y
+CONFIG_HYCTL=y
+CONFIG_FEATURE_HYCTL_FANCY=y
+CONFIG_FEATURE_HYCTL_SHOW=y
 CONFIG_IFCONFIG=y
 CONFIG_FEATURE_IFCONFIG_STATUS=y
 CONFIG_FEATURE_IFCONFIG_SLIP=y
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/sysstat-6.0.1/build/CONFIG apps_1.2/sysstat-6.0.1/build/CONFIG
--- apps/sysstat-6.0.1/build/CONFIG	2014-05-30 03:41:18.967256629 -0700
+++ apps_1.2/sysstat-6.0.1/build/CONFIG	2014-05-30 03:43:44.052943190 -0700
@@ -1,37 +1,54 @@
 # Configuration file for sysstat
 # (C) 2000 Sebastien GODARD (sysstat <at> wanadoo.fr)
+#  Copyright (c) 2013 Qualcomm Atheros, Inc.
 
 # Directories
-PREFIX = /usr/local
-SA_LIB_DIR = /usr/local/lib/sa
+PREFIX = ../../tools/ap71-rootdir/
+SA_LIB_DIR = ../../tools/ap71-rootdir//lib/sa
 SADC_PATH = ${SA_LIB_DIR}/sadc
-SA_DIR = /var/log/sa
-MAN_DIR = ${PREFIX}/man
+SA_DIR = ../../tools/ap71-rootdir/var/log/sa
+MAN_DIR = ../../tools/ap71-rootdir//man
 CLEAN_SA_DIR = n
-YESTERDAY =
+YESTERDAY = 
 HISTORY = 7
 
+#override vars with board specific locations...
+ifeq ($(BOARD_TYPE), pb42)
+PREFIX = ../../tools/rootdir/
+SA_LIB_DIR = ../../tools/rootdir//lib/sa
+SADC_PATH = ${SA_LIB_DIR}/sadc
+SA_DIR = /tmp
+MAN_DIR = ../../tools/rootdir//man
+endif
+
 DFLAGS =
 SAS_DFLAGS =
 
+ENABLE_NLS = n
+ENABLE_SMP_WRKARD = n
+
+ifeq ($(ENABLE_NLS),y)
 # NLS (National Language Support)
 REQUIRE_NLS = -DUSE_NLS -DPACKAGE=\"$(PACKAGE)\" -DLOCALEDIR=\"$(PREFIX)/share/locale\"
+endif
 ifdef REQUIRE_NLS
    DFLAGS += $(REQUIRE_NLS)
 endif
 
+ifeq ($(ENABLE_SMP_WRKARD),y)
 # Uncomment this to enable workaround for Linux kernel SMP race condition
-#SAS_DFLAGS += -DSMP_RACE
+SAS_DFLAGS += -DSMP_RACE
+endif
 
 # Man page group
-MAN_GROUP = root
+MAN_GROUP = man
 
 # Crontab owner
 CRON_OWNER = adm
 
 # Run-command directories
-RC_DIR = /etc/rc.d
-INIT_DIR = /etc/rc.d/init.d
+RC_DIR = /etc
+INIT_DIR = /etc/init.d
 INITD_DIR = init.d
 
 INSTALL_CRON = n
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/sysstat-6.0.1/common.c apps_1.2/sysstat-6.0.1/common.c
--- apps/sysstat-6.0.1/common.c	2014-05-30 03:41:18.967256629 -0700
+++ apps_1.2/sysstat-6.0.1/common.c	2014-05-30 03:43:44.052943190 -0700
@@ -1,6 +1,7 @@
 /*
  * sar, sadc, sadf, mpstat and iostat common routines.
  * (C) 1999-2005 by Sebastien GODARD (sysstat <at> wanadoo.fr)
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  *
  ***************************************************************************
  * This program is free software; you can redistribute it and/or modify it *
@@ -35,7 +36,7 @@
  * PAGE_SHIFT no longer necessarily exists in <asm/page.h>. So
  * we use PAGE_SIZE to compute PAGE_SHIFT...
  */
-#include <asm/page.h>
+#include <sys/user.h>
 
 #include "common.h"
 #include "ioconf.h"
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/wireless_tools.29/ifrename.c apps_1.2/wireless_tools.29/ifrename.c
--- apps/wireless_tools.29/ifrename.c	2014-05-30 03:41:18.999256999 -0700
+++ apps_1.2/wireless_tools.29/ifrename.c	2014-05-30 03:43:44.064943330 -0700
@@ -9,6 +9,7 @@
  *
  * This file is released under the GPL license.
  *     Copyright (c) 2007 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 /* 
@@ -451,6 +452,72 @@
   0, { NULL, NULL, NULL, NULL, NULL },
 };
 
+#ifdef ANDROID
+ssize_t
+getdelim(char **lineptr, size_t *n, int delim, FILE *stream)
+{
+        char *p;                    // reads stored here
+        size_t const rchunk = 512;  // number of bytes to read
+        size_t const mchunk = 512;  // number of extra bytes to malloc
+        size_t m = rchunk + 1;      // initial buffer size
+
+        if (*lineptr) {
+                if (*n < m) {
+                        *lineptr = (char*)realloc(*lineptr, m);
+                        if (!*lineptr) return -1;
+                        *n = m;
+                }
+        } else {
+                *lineptr = (char*)malloc(m);
+                if (!*lineptr) return -1;
+                *n = m;
+        }
+
+        m = 0; // record length including seperator
+
+        do {
+                size_t i;     // number of bytes read etc
+                size_t j = 0; // number of bytes searched
+
+                p = *lineptr + m;
+
+                i = fread(p, 1, rchunk, stream);
+                if (i < rchunk && ferror(stream))
+                        return -1;
+                while (j < i) {
+                        ++j;
+                        if (*p++ == (char)delim) {
+                                *p = '\0';
+                                if (j != i) {
+                                        if (fseek(stream, j - i, SEEK_CUR))
+                                                return -1;
+                                        if (feof(stream))
+                                                clearerr(stream);
+                                }
+                                m += j;
+                                return m;
+                        }
+                }
+
+                m += j;
+                if (feof(stream)) {
+                        if (m) return m;
+                        if (!i) return -1;
+                }
+
+                // allocate space for next read plus possible null terminator
+                i = ((m + (rchunk + 1 > mchunk ? rchunk + 1 : mchunk) +
+                      mchunk - 1) / mchunk) * mchunk;
+                if (i != *n) {
+                        *lineptr = (char*)realloc(*lineptr, i);
+                        if (!*lineptr) return -1;
+                        *n = i;
+                }
+        } while (1);
+}
+#define getline(a,b,c) getdelim(a,b,'\n',c)
+#endif
+
 /******************** INTERFACE NAME MANAGEMENT ********************/
 /*
  * Bunch of low level function for managing interface names.
@@ -540,7 +607,10 @@
   /* Prepare request */
   bzero(&ifr, sizeof(struct ifreq));
   strncpy(ifr.ifr_name, victimname, IFNAMSIZ); 
+  ifr.ifr_name[IFNAMSIZ - 1] = '\0';
+
   strncpy(ifr.ifr_newname, autoname, IFNAMSIZ); 
+  ifr.ifr_newname[IFNAMSIZ - 1] = '\0';
 
   /* Rename victim interface */
   ret = ioctl(skfd, SIOCSIFNAME, &ifr);
@@ -586,7 +656,9 @@
   /* Prepare request */
   bzero(&ifr, sizeof(struct ifreq));
   strncpy(ifr.ifr_name, oldname, IFNAMSIZ); 
+  ifr.ifr_name[IFNAMSIZ - 1] = '\0';
   strncpy(ifr.ifr_newname, newname, IFNAMSIZ); 
+  ifr.ifr_newname[IFNAMSIZ - 1] = '\0';
 
   /* Check for wildcard interface name, such as 'eth*' or 'wlan*'...
    * This require specific kernel support (2.6.2-rc1 and later).
@@ -746,6 +818,7 @@
   /* Get MAC address */
   bzero(&ifr, sizeof(struct ifreq));
   strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+  ifr.ifr_name[IFNAMSIZ - 1] = '\0';
   ret = ioctl(skfd, SIOCGIFHWADDR, &ifr);
   if(ret < 0)
     {
@@ -1040,6 +1113,7 @@
   bzero(&ifr, sizeof(struct ifreq));
   bzero(&drvinfo, sizeof(struct ethtool_drvinfo));
   strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+  ifr.ifr_name[IFNAMSIZ - 1] = '\0';
   drvinfo.cmd = ETHTOOL_GDRVINFO;
   ifr.ifr_data = (caddr_t) &drvinfo;
 
@@ -1206,6 +1280,7 @@
   bzero(&ifr, sizeof(struct ifreq));
   bzero(&map, sizeof(struct ifmap));
   strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+  ifr.ifr_name[IFNAMSIZ - 1] = '\0';
 
   /* Do it */
   ret = ioctl(skfd, SIOCGIFMAP, &ifr);
@@ -1652,6 +1727,8 @@
 		      fprintf(stderr,
 			      "Error: Can't parse /proc/mounts file: %s\n",
 			      strerror(errno)); 
+              if (sdup)
+                free(sdup); /* Accounts for n = 0 case */
 		      return(-1);
 		    }
 		  /* Store it */
@@ -1690,12 +1767,16 @@
       target->sysfs_devpath = fname;
     }
 
+  fname = NULL;
   /* Loop on all sysfs selector */
   for(findex = 0; findex < sysfs_global.filenum; findex++)
     {
       char *	p;
       ssize_t	n;
 
+      if (fname) {
+            free(fname);
+      }
       /* Construct complete filename for the sysfs selector */
       fnsize = (target->sysfs_devplen + 1 +
 		strlen(sysfs_global.filename[findex]) + 1);
@@ -1750,16 +1831,19 @@
 	      pathlen = readlink(fname, linkpath, allocsize);
 	      /* If we did not hit the buffer limit, success */
 	      if(pathlen < allocsize)
-		break;
+		        break;
 	    }
 	  while(retry-- > 0);
 
 	  /* Check for error, most likely ENOENT */
-	  if(pathlen > 0)
+	  if(pathlen > 0) {
 	    /* We have a symlink ;-) Terminate the string. */
-	    linkpath[pathlen] = '\0';
-	  else
-	    {
+        if (pathlen < allocsize) {
+            linkpath[pathlen] = '\0';
+        } else {
+            linkpath[allocsize - 1] = '\0';
+        }
+	  } else {
 	      /* Error ! */
 	      free(linkpath);
 
@@ -1827,6 +1911,9 @@
 	{
 	  fprintf(stderr, "Error: Can't allocate SYSFS value\n"); 
 	  free(linebuf);
+      if (fname) {
+        free(fname);
+      }
 	  return(-1);
 	}
       target->sysfs[findex] = sdup;
@@ -1844,6 +1931,9 @@
 
   /* Cleanup */
   free(linebuf);
+  if (fname) {
+    free(fname);
+  }
 
   return(target->active[SELECT_SYSFS] ? 0 : -1);
 }
@@ -2337,6 +2427,7 @@
        * the interface will load with the old/wrong name.
        */
       strncpy(ifr.ifr_name, ifnode->ifname, IFNAMSIZ);
+      ifr.ifr_name[IFNAMSIZ - 1] = '\0';
       ioctl(skfd, SIOCGIFHWADDR, &ifr);
     }
 }
@@ -2404,6 +2495,7 @@
 
 	      /* Load interface */
 	      strncpy(ifr.ifr_name, p, IFNAMSIZ);
+          ifr.ifr_name[IFNAMSIZ - 1] = '\0';
 	      ioctl(skfd, SIOCGIFHWADDR, &ifr);
 
 	      /* Go to next interface name */
@@ -2503,13 +2595,17 @@
 
   /* Find matching mapping */
   mapping = mapping_find(target);
-  if(mapping == NULL)
+  if(mapping == NULL) {
+    free(target);
     return(-1);
+  }
 
   /* If user specified a new name, keep only interfaces that would
    * match the new name... */
-  if((new_name != NULL) && (if_match_ifname(mapping->ifname, new_name) != 0))
+  if((new_name != NULL) && (if_match_ifname(mapping->ifname, new_name) != 0)) {
+    free(target);
     return(-1);
+  }
 
   /* Check if user want only dry-run.
    * Note that, in the case of wildcard, we don't resolve the wildcard.
@@ -2527,6 +2623,7 @@
 	{
 	  fprintf(stderr, "Error: cannot change name of %s to %s: %s\n",
 		  target->ifname, mapping->ifname, strerror(errno)); 
+      free(target);
 	  return(-1);
 	}
     }
@@ -2550,12 +2647,18 @@
 	    if(!target->sysfs_devpath)
 	      mapping_getsysfs(skfd, ifname, target, 0);
 	    /* Update devpath. Size is large enough. */
-	    pos = strrchr(target->sysfs_devpath, '/');
-	    if((pos != NULL) && (!strcmp(target->ifname, pos + 1)))
-	      strcpy(pos + 1, retname);
-	    /* Return new environment variables */
-	    printf("DEVPATH=%s\nINTERFACE=%s\nINTERFACE_OLD=%s\n",
-		   target->sysfs_devpath, retname, target->ifname);
+        /*
+         * sysfs_devpath could still be NULL, after the call to
+         * mapping_getsysfs()
+         */
+        if (target->sysfs_devpath) {
+	        pos = strrchr(target->sysfs_devpath, '/');
+	        if((pos != NULL) && (!strcmp(target->ifname, pos + 1)))
+	            strcpy(pos + 1, retname);
+	        /* Return new environment variables */
+	        printf("DEVPATH=%s\nINTERFACE=%s\nINTERFACE_OLD=%s\n",
+		        target->sysfs_devpath, retname, target->ifname);
+        }
 	  }
     }
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/wireless_tools.29/iwconfig.c apps_1.2/wireless_tools.29/iwconfig.c
--- apps/wireless_tools.29/iwconfig.c	2014-05-30 03:41:19.003257046 -0700
+++ apps_1.2/wireless_tools.29/iwconfig.c	2014-05-30 03:43:44.064943330 -0700
@@ -9,6 +9,7 @@
  *
  * This file is released under the GPL license.
  *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 #include "iwlib.h"		/* Header */
@@ -58,6 +59,7 @@
       struct ifreq ifr;
 
       strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+      ifr.ifr_name[IFNAMSIZ - 1] = '\0';
       if(ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0)
 	return(-ENODEV);
       else
@@ -1501,7 +1503,10 @@
 		errarg = 0;
 		return(IWERR_ARG_TYPE);
 	      }
-	    wrq.u.rts.value = temp;
+          if (temp == 0)
+            wrq.u.rts.disabled = 1;	/* i.e. max size */
+          else
+    	    wrq.u.rts.value = temp;
 	  }
       }
 
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/wireless_tools.29/iwlib.c apps_1.2/wireless_tools.29/iwlib.c
--- apps/wireless_tools.29/iwlib.c	2014-05-30 03:41:19.007257093 -0700
+++ apps_1.2/wireless_tools.29/iwlib.c	2014-05-30 03:43:44.064943330 -0700
@@ -7,6 +7,7 @@
  *
  * This file is released under the GPL license.
  *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 /***************************** INCLUDES *****************************/
@@ -475,7 +476,7 @@
   union iw_range_raw *	range_raw;
 
   /* Cleanup */
-  bzero(buffer, sizeof(buffer));
+  memset(buffer, 0, sizeof(buffer));
 
   wrq.u.data.pointer = (caddr_t) buffer;
   wrq.u.data.length = sizeof(buffer);
@@ -504,7 +505,7 @@
   else
     {
       /* Zero unknown fields */
-      bzero((char *) range, sizeof(struct iw_range));
+      memset((char *) range, 0, sizeof(struct iw_range));
 
       /* Initial part unmoved */
       memcpy((char *) range,
@@ -707,14 +708,14 @@
 
   /* Get ESSID */
   wrq.u.essid.pointer = (caddr_t) info->essid;
-  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
+  wrq.u.essid.length = IW_ESSID_MAX_SIZE ;
   wrq.u.essid.flags = 0;
   if(iw_get_ext(skfd, ifname, SIOCGIWESSID, &wrq) >= 0)
     {
       info->has_essid = 1;
       info->essid_on = wrq.u.data.flags;
     }
-
+ 
   /* Get operation mode */
   if(iw_get_ext(skfd, ifname, SIOCGIWMODE, &wrq) >= 0)
     {
@@ -2946,6 +2947,10 @@
 {
   struct wireless_scan *	oldwscan;
 
+  if (!wscan && event->cmd != SIOCGIWAP) {
+    return NULL;
+  }
+
   /* Now, let's decode the event */
   switch(event->cmd)
     {
@@ -2960,7 +2965,7 @@
 	oldwscan->next = wscan;
 
       /* Reset it */
-      bzero(wscan, sizeof(struct wireless_scan));
+      memset(wscan, 0, sizeof(struct wireless_scan));
 
       /* Save cell identifier */
       wscan->has_ap_addr = 1;
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/wireless_tools.29/iwlib.h apps_1.2/wireless_tools.29/iwlib.h
--- apps/wireless_tools.29/iwlib.h	2014-05-30 03:41:19.007257093 -0700
+++ apps_1.2/wireless_tools.29/iwlib.h	2014-05-30 03:43:44.064943330 -0700
@@ -7,6 +7,7 @@
  *
  * This file is released under the GPL license.
  *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 #ifndef IWLIB_H
@@ -28,7 +29,11 @@
 #include <string.h>
 #include <unistd.h>
 #include <netdb.h>		/* gethostbyname, getnetbyname */
+#ifdef ANDROID
+#include <net/if_ether.h>	/* struct ether_addr */
+#else
 #include <net/ethernet.h>	/* struct ether_addr */
+#endif
 #include <sys/time.h>		/* struct timeval */
 #include <unistd.h>
 
@@ -510,6 +515,7 @@
 {
   /* Set device name */
   strncpy(pwrq->ifr_name, ifname, IFNAMSIZ);
+  pwrq->ifr_name[IFNAMSIZ - 1] = '\0';
   /* Do the request */
   return(ioctl(skfd, request, pwrq));
 }
@@ -526,6 +532,7 @@
 {
   /* Set device name */
   strncpy(pwrq->ifr_name, ifname, IFNAMSIZ);
+  pwrq->ifr_name[IFNAMSIZ - 1] = '\0';
   /* Do the request */
   return(ioctl(skfd, request, pwrq));
 }
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/wireless_tools.29/iwlist.c apps_1.2/wireless_tools.29/iwlist.c
--- apps/wireless_tools.29/iwlist.c	2014-05-30 03:41:19.007257093 -0700
+++ apps_1.2/wireless_tools.29/iwlist.c	2014-05-30 03:43:44.064943330 -0700
@@ -9,6 +9,7 @@
  *
  * This file is released under the GPL license.
  *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 #include "iwlib.h"		/* Header */
@@ -624,7 +625,11 @@
   struct iw_range	range;
   int			has_range;
   struct timeval	tv;				/* Select timeout */
-  int			timeout = 15000000;		/* 15s */
+#if ATH_SUPPORT_WRAP
+  int           timeout = 60000000;     /* 60s */
+#else
+  int			timeout = 30000000;		/* Changed from 15 to 30s as WAR */ 
+#endif
 
   /* Avoid "Unused parameter" warning */
   args = args; count = count;
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/wireless_tools.29/iwpriv.c apps_1.2/wireless_tools.29/iwpriv.c
--- apps/wireless_tools.29/iwpriv.c	2014-05-30 03:41:19.011257139 -0700
+++ apps_1.2/wireless_tools.29/iwpriv.c	2014-05-30 03:43:44.064943330 -0700
@@ -9,6 +9,7 @@
  *
  * This file is released under the GPL license.
  *     Copyright (c) 1997-2007 Jean Tourrilhes <jt@hpl.hp.com>
+ *     Copyright (c) 2013 Qualcomm Atheros, Inc.
  */
 
 #include "iwlib.h"		/* Header */
@@ -262,16 +263,16 @@
   u_char	buffer[4096];	/* Only that big in v25 and later */
   int		i = 0;		/* Start with first command arg */
   int		k;		/* Index in private description table */
-  int		temp;
+  long long	temp;
   int		subcmd = 0;	/* sub-ioctl index */
   int		offset = 0;	/* Space for sub-ioctl index */
 
   /* Check if we have a token index.
    * Do it now so that sub-ioctl takes precedence, and so that we
    * don't have to bother with it later on... */
-  if((count >= 1) && (sscanf(args[0], "[%i]", &temp) == 1))
+  if((count >= 1) && (sscanf(args[0], "[%lli]", &temp) == 1))
     {
-      subcmd = temp;
+      subcmd = (int) temp;
       args++;
       count--;
     }
@@ -290,15 +291,38 @@
   /* Watch out for sub-ioctls ! */
   if(priv[k].cmd < SIOCDEVPRIVATE)
     {
-      int	j = -1;
+      int j = k;
+      /*Look up for *real* ioctl backward from subioctl index.
+  	  *This could dispatch sub-ioctls command correctly.
+	  *Consider the following example:
+	  *
+	  *{ IEEE80211_IOCTL_A,
+	  *IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 4, 0, "seta" },
+	  *{ IEEE80211_IOCTL_A,
+	  *IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "" },
+	  *sub ioctl of IEEE80211_IOCTL_A
+	  *{ IEEE80211_IOCTL_SUBA
+	  *IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "setsuba" },
+	  *
+	  *{ IEEE80211_IOCTL_B,
+	  *IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 4, 0, "setb" },
+	  *{ IEEE80211_IOCTL_B,
+	  *IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "" },
+	  *sub ioctl of IEEE80211_IOCTL_B
+	  *{ IEEE80211_IOCTL_SUBB
+	  *IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "setsubb" },
+	  *
+      *If searching from beginning, "setsubb" will get mapped to IOCTL_A 
+      *rather than the correct one, IOCTL_B.
+  	  */
 
       /* Find the matching *real* ioctl */
-      while((++j < priv_num) && ((priv[j].name[0] != '\0') ||
+      while((--j >= 0) && ((priv[j].name[0] != '\0') ||
 				 (priv[j].set_args != priv[k].set_args) ||
 				 (priv[j].get_args != priv[k].get_args)));
 
       /* If not found... */
-      if(j == priv_num)
+      if(j == -1)
 	{
 	  fprintf(stderr, "Invalid private ioctl definition for : %s\n",
 		  cmdname);
@@ -332,7 +356,7 @@
 
 	  /* Fetch args */
 	  for(; i < wrq.u.data.length; i++) {
-	    sscanf(args[i], "%i", &temp);
+	    sscanf(args[i], "%lli", &temp);
 	    buffer[i] = (char) temp;
 	  }
 	  break;
@@ -345,7 +369,7 @@
 
 	  /* Fetch args */
 	  for(; i < wrq.u.data.length; i++) {
-	    sscanf(args[i], "%i", &temp);
+	    sscanf(args[i], "%lli", &temp);
 	    ((__s32 *) buffer)[i] = (__s32) temp;
 	  }
 	  break;
@@ -387,7 +411,7 @@
 	    if(strchr(args[i], 'G')) freq *= GIGA;
 	    if(strchr(args[i], 'M')) freq *= MEGA;
 	    if(strchr(args[i], 'k')) freq *= KILO;
-	    sscanf(args[i], "%i", &temp);
+	    sscanf(args[i], "%lli", &temp);
 	    iw_float2freq(freq, ((struct iw_freq *) buffer) + i);
 	  }
 	  break;
@@ -428,6 +452,7 @@
     }
 
   strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+  wrq.ifr_name[IFNAMSIZ - 1] = '\0';
 
   /* Those two tests are important. They define how the driver
    * will have to handle the data */
diff -I '$[^ ]*:.*\$' -u -r -N -a --binary apps/wireless_tools.29/Makefile apps_1.2/wireless_tools.29/Makefile
--- apps/wireless_tools.29/Makefile	2014-05-30 03:41:18.991256907 -0700
+++ apps_1.2/wireless_tools.29/Makefile	2014-05-30 03:43:44.064943330 -0700
@@ -1,3 +1,21 @@
+#
+# Copyright (c) 2013 Qualcomm Atheros, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
+#
+
 ##
 ## Please check the configurion parameters below
 ##
@@ -8,29 +26,29 @@
   PREFIX = /usr/local
 endif
 
-## Compiler to use (modify this for cross compile).
-CC = gcc
-## Other tools you need to modify for cross compile (static lib only).
-AR = ar
-RANLIB = ranlib
+## Compiler to use
+ifneq ($(strip $(TOOLPREFIX)),)
+CROSS:=$(TOOLPREFIX)
+endif
+
+CC = $(CROSS)gcc
+## Other tools you need to modify for cross compile (static lib only)
 
-## Uncomment this to build tools using static version of the library.
+AR = $(CROSS)ar
+
+RANLIB = $(CROSS)ranlib
+## Uncomment this to build tools using static version of the library
 ## Mostly useful for embedded platforms without ldd, or to create
 ## a local version (non-root).
-# BUILD_STATIC = y
+###### BUILD_STATIC = y
 
 ## Uncomment this to build without using libm (less efficient).
 ## This is mostly useful for embedded platforms without maths.
-# BUILD_NOLIBM = y
+BUILD_NOLIBM = y
 
 ## Uncomment this to strip binary from symbols. This reduce binary size.
 ## by a few percent but make debug worse...
-# BUILD_STRIPPING = y
-
-## Uncomment this to build with only essential functionality.
-## This leaves out the less used features and cut in half the tools.
-## This is mostly useful for embedded platforms without limited feature needs.
-# BUILD_WE_ESSENTIAL = y
+####### BUILD_STRIPPING = y
 
 # ***************************************************************************
 # ***** Most users should not need to change anything beyond this point *****
@@ -58,7 +76,7 @@
 OBJS = iwlib.o
 
 # Select which library to build and to link tool with
-ifdef BUILD_STATIC
+ifeq ($(BUILD_STATIC),y)
   IWLIB=$(STATIC)
   IWLIB_INSTALL=install-static
 else
@@ -103,11 +121,12 @@
 
 # Other flags
 CFLAGS=-Os -W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow \
-	-Wpointer-arith -Wcast-qual -Winline -I.
+	-Wpointer-arith -Wcast-qual -Winline -I. -g
 #CFLAGS=-O2 -W -Wall -Wstrict-prototypes -I.
 DEPFLAGS=-MMD
-XCFLAGS=$(CFLAGS) $(DEPFLAGS) $(WARN) $(HEADERS) $(WELIB_FLAG) $(WEDEF_FLAG)
+XCFLAGS+=$(CFLAGS) $(DEPFLAGS) $(WARN) $(HEADERS) $(WELIB_FLAG) $(WEDEF_FLAG)
 PICFLAG=-fPIC
+LDFLAGS += -g
 
 # Standard compilation targets
 all:: $(IWLIB) $(PROGS)
